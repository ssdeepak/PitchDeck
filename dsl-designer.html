<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enterprise DSL Designer - Multi-Layer Visual Designer</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --secondary: #64748b;
            --accent: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --background: #ffffff;
            --surface: #f8fafc;
            --surface-2: #f1f5f9;
            --surface-3: #e2e8f0;
            --border: #e2e8f0;
            --text: #0f172a;
            --text-muted: #64748b;
            --text-light: #94a3b8;
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --radius: 8px;
            --radius-lg: 12px;
        }

        .dark {
            --primary: #3b82f6;
            --primary-dark: #2563eb;
            --secondary: #6b7280;
            --accent: #a855f7;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --background: #0f172a;
            --surface: #1e293b;
            --surface-2: #334155;
            --surface-3: #475569;
            --border: #334155;
            --text: #f8fafc;
            --text-muted: #94a3b8;
            --text-light: #64748b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--background);
            color: var(--text);
            line-height: 1.5;
            overflow: hidden;
        }

        /* Main Layout */
        .designer-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: var(--background);
        }

        /* Header */
        .designer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 24px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            box-shadow: var(--shadow);
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 700;
            font-size: 18px;
            color: var(--primary);
        }

        .plan-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border: none;
            border-radius: var(--radius);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-secondary {
            background: var(--surface-2);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--surface-3);
        }

        .btn-icon {
            padding: 8px;
            background: transparent;
            color: var(--text-muted);
        }

        .btn-icon:hover {
            background: var(--surface-2);
            color: var(--text);
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            overflow-x: auto;
        }

        .tab-button {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 16px 24px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .tab-button:hover {
            background: var(--surface-2);
            color: var(--text);
        }

        .tab-button.active {
            background: var(--surface-2);
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .tab-badge {
            background: var(--primary);
            color: white;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 18px;
            text-align: center;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .tab-content {
            flex: 1;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .tab-content.active {
            display: flex;
        }

        /* Plan Overview Tab */
        .plan-overview {
            padding: 24px;
            overflow-y: auto;
        }

        .overview-section {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 24px;
            margin-bottom: 24px;
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .section-icon {
            width: 40px;
            height: 40px;
            background: var(--primary);
            color: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text);
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text);
        }

        .form-input, .form-textarea, .form-select {
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--background);
            color: var(--text);
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .form-input:focus, .form-textarea:focus, .form-select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgb(37 99 235 / 0.1);
        }

        .form-textarea {
            min-height: 80px;
            resize: vertical;
        }

        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .stat-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Agents Tab */
        .agents-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .agents-sidebar {
            width: 280px;
            background: var(--surface);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 12px;
        }

        .agent-search {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--background);
            color: var(--text);
            font-size: 14px;
        }

        .agents-list {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .agent-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: background-color 0.2s;
            margin-bottom: 8px;
        }

        .agent-item:hover {
            background: var(--surface-2);
        }

        .agent-item.selected {
            background: var(--primary);
            color: white;
        }

        .agent-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
        }

        .agent-orchestrator { background: #8b5cf6; }
        .agent-tool { background: #10b981; }
        .agent-ai { background: #f59e0b; }
        .agent-data { background: #3b82f6; }

        .agent-details {
            flex: 1;
            min-width: 0;
        }

        .agent-name {
            font-size: 14px;
            font-weight: 500;
            color: inherit;
            margin-bottom: 2px;
        }

        .agent-purpose {
            font-size: 12px;
            color: var(--text-muted);
        }

        .agent-item.selected .agent-purpose {
            color: rgba(255, 255, 255, 0.8);
        }

        .agents-workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .workspace-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
        }

        .workspace-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
        }

        .workspace-actions {
            display: flex;
            gap: 8px;
        }

        .agent-canvas {
            flex: 1;
            position: relative;
            background: var(--background);
            overflow: auto;
            background-image: 
                radial-gradient(circle, var(--border) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Store Tab */
        .store-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .store-tree {
            width: 350px;
            background: var(--surface);
            border-right: 1px solid var(--border);
            overflow-y: auto;
        }

        .tree-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        .tree-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .tree-item:hover {
            background: var(--surface-2);
        }

        .tree-item.selected {
            background: var(--primary);
            color: white;
        }

        .tree-indent {
            width: 20px;
        }

        .store-editor {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
        }

        .editor-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        /* Import/Export Tab */
        .import-export {
            padding: 24px;
            overflow-y: auto;
        }

        .xml-editor {
            width: 100%;
            height: 400px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 16px;
            background: var(--surface);
            color: var(--text);
            resize: vertical;
        }

        /* Visual Components */
        .node {
            position: absolute;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            min-width: 200px;
            max-width: 300px;
            box-shadow: var(--shadow);
            cursor: move;
            transition: all 0.2s;
        }

        .node:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }

        .node.selected {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgb(37 99 235 / 0.1);
        }

        .node-header {
            padding: 12px 16px;
            background: var(--surface-2);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .node-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
        }

        .node-body {
            padding: 16px;
        }

        .node-field {
            margin-bottom: 12px;
        }

        .node-field:last-child {
            margin-bottom: 0;
        }

        .node-field label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .node-field input,
        .node-field textarea,
        .node-field select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--background);
            color: var(--text);
            font-size: 13px;
        }

        .node-field textarea {
            min-height: 60px;
            resize: vertical;
        }

        /* Connection handles */
        .handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--primary);
            border: 2px solid white;
            border-radius: 50%;
            cursor: crosshair;
        }

        .handle.in {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .handle.out {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Status indicators */
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-ready {
            background: var(--surface-2);
            color: var(--text-muted);
        }

        .status-running {
            background: #dbeafe;
            color: #1d4ed8;
        }

        .status-completed {
            background: #d1fae5;
            color: #065f46;
        }

        .status-error {
            background: #fee2e2;
            color: #dc2626;
        }

        /* Visual Designer */
        .visual-designer {
            display: flex;
            height: 100%;
            background: var(--background);
        }

        .designer-palette {
            width: 280px;
            background: var(--surface);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .palette-header {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .palette-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 12px;
        }

        .palette-search {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--background);
            color: var(--text);
            font-size: 13px;
        }

        .palette-sections {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .palette-section {
            margin-bottom: 24px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .palette-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: var(--radius);
            cursor: grab;
            transition: all 0.2s;
            margin-bottom: 4px;
            border: 1px solid transparent;
        }

        .palette-item:hover {
            background: var(--surface-2);
            border-color: var(--border);
        }

        .palette-item:active {
            cursor: grabbing;
        }

        .palette-item i {
            font-size: 18px;
            color: var(--primary);
        }

        .palette-item span {
            font-size: 13px;
            font-weight: 500;
            color: var(--text);
        }

        .designer-workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .workspace-toolbar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .toolbar-divider {
            width: 1px;
            height: 20px;
            background: var(--border);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zoom-level {
            font-size: 13px;
            color: var(--text-muted);
            min-width: 40px;
            text-align: center;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: var(--background);
            overflow: hidden;
            background-image: 
                radial-gradient(circle, var(--border) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .connection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .statement-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        .designer-inspector {
            width: 320px;
            background: var(--surface);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .inspector-header {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .inspector-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
        }

        .inspector-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .inspector-empty {
            text-align: center;
            color: var(--text-muted);
            font-style: italic;
            padding: 40px 20px;
        }

        .inspector-section {
            border-top: 1px solid var(--border);
            padding: 16px;
        }

        .inspector-section h5 {
            font-size: 13px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 12px;
        }

        /* Statement Nodes */
        .statement-node {
            position: absolute;
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            min-width: 180px;
            max-width: 280px;
            box-shadow: var(--shadow);
            cursor: move;
            z-index: 10;
            transition: all 0.2s;
        }

        .statement-node:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-1px);
        }

        .statement-node.selected {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgb(37 99 235 / 0.1);
        }

        .statement-node.executing {
            border-color: var(--warning);
            box-shadow: 0 0 0 3px rgb(245 158 11 / 0.2);
            animation: pulse 1.5s infinite;
        }

        .statement-node.completed {
            border-color: var(--success);
        }

        .statement-node.error {
            border-color: var(--error);
        }

        .node-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            border-radius: var(--radius) var(--radius) 0 0;
        }

        .node-type {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text);
        }

        .node-type i {
            font-size: 16px;
            color: var(--primary);
        }

        .node-actions {
            display: flex;
            gap: 4px;
        }

        .node-action {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .node-action:hover {
            background: var(--surface-2);
            color: var(--text);
        }

        .node-action i {
            font-size: 16px;
        }

        .node-body {
            padding: 12px;
        }

        .node-summary {
            font-size: 12px;
            color: var(--text-muted);
            line-height: 1.4;
        }

        .node-key {
            font-size: 11px;
            color: var(--primary);
            font-weight: 500;
            margin-bottom: 2px;
        }

        /* Connection Points */
        .connection-point {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--primary);
            border: 2px solid var(--background);
            border-radius: 50%;
            cursor: crosshair;
            z-index: 20;
        }

        .connection-point.input {
            left: -5px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-point.output {
            right: -5px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-point:hover {
            background: var(--primary-dark);
            transform: translateY(-50%) scale(1.2);
        }

        /* Property Forms */
        .property-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .property-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .property-label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text);
        }

        .property-input, .property-textarea, .property-select {
            padding: 8px 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--background);
            color: var(--text);
            font-size: 13px;
        }

        .property-textarea {
            min-height: 60px;
            resize: vertical;
        }

        .property-help {
            font-size: 11px;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Variables List */
        .variable-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--surface-2);
            border-radius: 4px;
            margin-bottom: 4px;
        }

        .variable-name {
            font-size: 12px;
            font-weight: 500;
            color: var(--text);
        }

        .variable-type {
            font-size: 11px;
            color: var(--text-muted);
            background: var(--surface-3);
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .agents-sidebar {
                width: 240px;
            }
            
            .store-tree {
                width: 280px;
            }
            
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .visual-designer {
                flex-direction: column;
            }

            .designer-palette {
                width: 100%;
                height: 200px;
                border-right: none;
                border-bottom: 1px solid var(--border);
            }

            .designer-inspector {
                width: 100%;
                height: 200px;
                border-left: none;
                border-top: 1px solid var(--border);
            }
        }

        /* Animation classes */
        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            padding: 8px 0;
            z-index: 1000;
            min-width: 160px;
        }

        .context-menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text);
            transition: background-color 0.2s;
        }

        .context-menu-item:hover {
            background: var(--surface-2);
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        /* Execution UI */
        .execution-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .execution-dialog {
            background: var(--surface);
            border-radius: var(--radius-lg);
            width: 80vw;
            max-width: 900px;
            height: 70vh;
            box-shadow: var(--shadow-lg);
            display: flex;
            flex-direction: column;
        }

        .execution-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .execution-header h3 {
            margin: 0;
            color: var(--text);
            font-size: 18px;
        }

        .execution-body {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .execution-log {
            flex: 2;
            padding: 16px;
            overflow-y: auto;
            background: var(--background);
            border-right: 1px solid var(--border);
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .execution-output {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            background: var(--surface-2);
        }

        .execution-footer {
            padding: 20px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        /* Seed Editor Styles */
        .seed-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .seed-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .seed-items {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .seed-item {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            overflow: hidden;
        }

        .seed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--surface-2);
            border-bottom: 1px solid var(--border);
        }

        .seed-key {
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            color: var(--primary);
        }

        .seed-actions {
            display: flex;
            gap: 4px;
        }

        .seed-value {
            padding: 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            background: var(--background);
            white-space: pre-wrap;
            overflow-x: auto;
        }

        .empty-state {
            text-align: center;
            color: var(--text-muted);
            padding: 60px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .empty-state .material-icons {
            font-size: 64px;
            opacity: 0.3;
        }

        .empty-title {
            font-size: 18px;
            font-weight: 600;
        }

        .empty-description {
            font-size: 14px;
            max-width: 400px;
            line-height: 1.5;
        }

        .btn-icon {
            background: none;
            border: none;
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: var(--surface-3);
            color: var(--text);
        }

        /* Canvas Styles */
        .canvas-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
        }

        .canvas-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 18px;
            font-weight: 600;
        }

        .canvas-controls {
            display: flex;
            gap: 12px;
        }

        .canvas-workspace {
            flex: 1;
            position: relative;
            background: var(--background);
            background-image: radial-gradient(var(--border) 1px, transparent 1px);
            background-size: 24px 24px;
            overflow: hidden;
        }

        .canvas-viewport {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .canvas-toolbar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 12px 16px;
            backdrop-filter: blur(8px);
        }

        .canvas-status {
            font-weight: 500;
            color: var(--text);
        }

        .canvas-progress {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: var(--text-muted);
        }

        /* Canvas Node Styles */
        .canvas-node {
            position: absolute;
            min-width: 200px;
            min-height: 100px;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            cursor: move;
            transition: all 0.2s;
            z-index: 10;
        }

        .canvas-node:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }

        .canvas-node.active {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgb(37 99 235 / 0.1);
        }

        .canvas-node.completed {
            border-color: var(--success);
            background: var(--success-bg);
        }

        .canvas-node.error {
            border-color: var(--error);
            background: var(--error-bg);
        }

        .node-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--surface-2);
        }

        .node-title {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .node-content {
            padding: 16px;
            min-height: 60px;
        }

        .node-type-badge {
            background: var(--primary);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .connection-line {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .connection-path {
            stroke: var(--primary);
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .connection-path.active {
            stroke: var(--warning);
            stroke-width: 3;
            animation: dashFlow 2s linear infinite;

        /* LLM Configuration Styles */
        .llm-config-container {
            padding: 24px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
            padding-bottom: 16px;
            border-bottom: 2px solid var(--border);
        }

        .config-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
        }

        .llm-status {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .status-indicator {
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-indicator.online {
            background: #10b981;
            color: white;
        }

        .status-indicator.offline {
            background: #6b7280;
            color: white;
        }

        .status-indicator.loading {
            background: #f59e0b;
            color: white;
            animation: pulse 2s infinite;
        }

        .model-info {
            font-size: 14px;
            color: var(--text-muted);
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 24px;
            margin-bottom: 32px;
        }

        .config-panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        .panel-header {
            padding: 16px 20px;
            background: var(--surface-2);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-header h4 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
        }

        .panel-content {
            padding: 20px;
        }

        .model-source,
        .model-selection {
            margin-bottom: 20px;
        }

        .model-source label,
        .model-selection label,
        .param-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text);
        }

        .model-source select,
        .model-selection select,
        .model-selection input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--background);
            color: var(--text);
            font-size: 14px;
        }

        .model-actions {
            display: flex;
            gap: 12px;
            margin: 20px 0;
        }

        .loading-progress {
            margin-top: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--surface-3);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 12px;
            color: var(--text-muted);
        }

        .param-group {
            margin-bottom: 24px;
        }

        .param-group input[type="range"] {
            width: 100%;
            margin: 8px 0;
        }

        .param-group small {
            color: var(--text-muted);
            font-size: 12px;
            display: block;
            margin-top: 4px;
        }

        .param-group span {
            font-weight: 600;
            color: var(--primary);
        }

        .param-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--background);
            color: var(--text);
            font-family: inherit;
            resize: vertical;
            min-height: 80px;
        }

        .param-group input[type="checkbox"] {
            margin-right: 8px;
        }

        .test-section {
            margin-bottom: 24px;
        }

        .test-section textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--background);
            color: var(--text);
            font-family: inherit;
            margin-bottom: 12px;
        }

        .test-results {
            margin-bottom: 24px;
        }

        .response-box {
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 16px;
            min-height: 100px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            line-height: 1.4;
            overflow-y: auto;
            max-height: 200px;
        }

        .performance-metrics,
        .model-health {
            margin-bottom: 20px;
        }

        .performance-metrics h5,
        .model-health h5 {
            margin-bottom: 12px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--surface-2);
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }

        .metric-label {
            font-size: 12px;
            color: var(--text-muted);
        }

        .metric-value {
            font-weight: 600;
            color: var(--primary);
        }

        .health-indicators {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .health-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--surface-2);
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }

        .health-label {
            font-size: 12px;
            color: var(--text-muted);
        }

        .health-status {
            font-weight: 600;
            font-size: 12px;
        }

        .health-status.healthy {
            color: var(--success);
        }

        .health-status.warning {
            color: var(--warning);
        }

        .health-status.error {
            color: var(--error);
        }

        .config-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            padding: 24px 0;
            border-top: 1px solid var(--border);
        }

        .tab-status {
            margin-left: 8px;
            font-size: 12px;
        }

        .tab-status.online {
            color: var(--success);
        }

        .tab-status.offline {
            color: var(--text-muted);
        }

        .hidden {
            display: none !important;
        }

        /* Provider Configuration Styles */
        .provider-config {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--surface-2);
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }

        .api-key-section,
        .org-id-section,
        .endpoint-section {
            margin-bottom: 16px;
        }

        .api-key-section.hidden,
        .org-id-section.hidden,
        .endpoint-section.hidden {
            display: none;
        }

        .api-key-help {
            display: block;
            margin-top: 4px;
            font-size: 11px;
            color: var(--text-muted);
            line-height: 1.3;
        }

        .model-loading {
            padding: 8px 12px;
            color: var(--text-muted);
            font-size: 12px;
            text-align: center;
            background: var(--surface-2);
            border-radius: var(--radius);
            margin-top: 8px;
        }

        .model-loading.hidden {
            display: none;
        }

        .provider-config input[type="password"],
        .provider-config input[type="text"],
        .provider-config input[type="url"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--background);
            color: var(--text);
            font-size: 13px;
            margin-bottom: 4px;
        }

        .provider-config input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
        }
        }

        @keyframes dashFlow {
            to {
                stroke-dashoffset: -20;
            }
        }

        /* Empty Canvas State */
        .empty-canvas-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-muted);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }

        .empty-canvas-state .material-icons {
            font-size: 64px;
            opacity: 0.3;
        }

        .empty-canvas-state .empty-title {
            font-size: 18px;
            font-weight: 600;
        }

        .empty-canvas-state .empty-description {
            font-size: 14px;
            max-width: 400px;
            line-height: 1.5;
        }
    </style>
    
    <!-- WebLLM Script -->
    <script src="https://cdn.jsdelivr.net/npm/@mlc-ai/web-llm@0.2.46/lib/web-llm.js"></script>
</head>
<body>
    <div class="designer-container">
        <!-- Header -->
        <header class="designer-header">
            <div class="header-left">
                <div class="logo">
                    <i class="material-icons">account_tree</i>
                    <span>Enterprise DSL Designer</span>
                </div>
                <div class="plan-title" id="planTitle">Untitled Plan</div>
            </div>
            <div class="header-actions">
                <button class="btn btn-secondary" id="importBtn">
                    <i class="material-icons">upload</i>
                    Import XML
                </button>
                <button class="btn btn-secondary" id="exportBtn">
                    <i class="material-icons">download</i>
                    Export XML
                </button>
                <button class="btn btn-primary" id="executeBtn">
                    <i class="material-icons">play_arrow</i>
                    Execute Plan
                </button>
                <button class="btn btn-icon" id="themeBtn">
                    <i class="material-icons">dark_mode</i>
                </button>
            </div>
        </header>

        <!-- Tab Navigation -->
        <nav class="tab-nav">
            <button class="tab-button active" data-tab="plan">
                <i class="material-icons">description</i>
                Plan Overview
            </button>
            <button class="tab-button" data-tab="agents">
                <i class="material-icons">smart_toy</i>
                Agents
                <span class="tab-badge" id="agentCount">0</span>
            </button>
            <button class="tab-button" data-tab="store">
                <i class="material-icons">folder</i>
                Store
                <span class="tab-badge" id="storeCount">0</span>
            </button>
            <button class="tab-button" data-tab="schema">
                <i class="material-icons">schema</i>
                Schema
            </button>
            <button class="tab-button" data-tab="seed">
                <i class="material-icons">grass</i>
                Seed
            </button>
            <button class="tab-button" data-tab="canvas">
                <i class="material-icons">account_tree</i>
                Canvas
            </button>
            <button class="tab-button" data-tab="llm-config">
                <i class="material-icons">psychology</i>
                LLM Config
                <span class="tab-status" id="llmStatus">‚óè</span>
            </button>
            <button class="tab-button" data-tab="import-export">
                <i class="material-icons">code</i>
                XML Source
            </button>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Plan Overview Tab -->
            <div class="tab-content active" id="planTab">
                <div class="plan-overview">
                    <div class="overview-section fade-in">
                        <div class="section-header">
                            <div class="section-icon">
                                <i class="material-icons">info</i>
                            </div>
                            <div class="section-title">Plan Information</div>
                        </div>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Plan Key</label>
                                <input type="text" class="form-input" id="planKey" placeholder="e.g., IntelligentKnowledgeExplorer">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Author</label>
                                <input type="text" class="form-input" id="planAuthor" placeholder="e.g., Knowledge Engineer">
                            </div>
                            <div class="form-group" style="grid-column: 1 / -1;">
                                <label class="form-label">Description</label>
                                <textarea class="form-textarea" id="planDescription" placeholder="Describe the purpose and functionality of this plan..."></textarea>
                            </div>
                        </div>
                    </div>

                    <div class="overview-section fade-in">
                        <div class="section-header">
                            <div class="section-icon">
                                <i class="material-icons">analytics</i>
                            </div>
                            <div class="section-title">Plan Statistics</div>
                        </div>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-value" id="totalAgents">0</div>
                                <div class="stat-label">Total Agents</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="orchestratorAgents">0</div>
                                <div class="stat-label">Orchestrators</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="toolAgents">0</div>
                                <div class="stat-label">Tools</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="aiAgents">0</div>
                                <div class="stat-label">AI Agents</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="storeFiles">0</div>
                                <div class="stat-label">Store Files</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="totalStatements">0</div>
                                <div class="stat-label">Statements</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Agents Tab -->
            <div class="tab-content" id="agentsTab">
                <div class="agents-container">
                    <div class="agents-sidebar">
                        <div class="sidebar-header">
                            <div class="sidebar-title">Agents</div>
                            <input type="text" class="agent-search" placeholder="Search agents..." id="agentSearch">
                        </div>
                        <div class="agents-list" id="agentsList">
                            <!-- Agents will be populated here -->
                        </div>
                        <div style="padding: 16px; border-top: 1px solid var(--border);">
                            <button class="btn btn-primary" style="width: 100%; justify-content: center;" id="addAgentBtn">
                                <i class="material-icons">add</i>
                                Add Agent
                            </button>
                        </div>
                    </div>
                    <div class="agents-workspace">
                        <div class="workspace-header">
                            <div class="workspace-title" id="selectedAgentTitle">Select an agent to edit</div>
                            <div class="workspace-actions">
                                <button class="btn btn-secondary" id="zoomOutBtn">
                                    <i class="material-icons">zoom_out</i>
                                </button>
                                <button class="btn btn-secondary" id="zoomInBtn">
                                    <i class="material-icons">zoom_in</i>
                                </button>
                                <button class="btn btn-secondary" id="centerViewBtn">
                                    <i class="material-icons">center_focus_strong</i>
                                </button>
                            </div>
                        </div>
                        <div class="agent-canvas" id="agentCanvas">
                            <!-- Agent visual editor will be here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Store Tab -->
            <div class="tab-content" id="storeTab">
                <div class="store-container">
                    <div class="store-tree">
                        <div class="tree-header">
                            <div class="sidebar-title">Store Structure</div>
                            <button class="btn btn-primary" style="width: 100%; margin-top: 12px; justify-content: center;" id="addStoreBtn">
                                <i class="material-icons">add</i>
                                Add Store
                            </button>
                        </div>
                        <div id="storeTree">
                            <!-- Store tree will be populated here -->
                        </div>
                    </div>
                    <div class="store-editor">
                        <div class="editor-header">
                            <div class="workspace-title" id="selectedStoreTitle">Select a store item to edit</div>
                        </div>
                        <div class="editor-content" id="storeEditorContent">
                            <!-- Store editor will be here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Schema Tab -->
            <div class="tab-content" id="schemaTab">
                <div class="plan-overview">
                    <div class="overview-section fade-in">
                        <div class="section-header">
                            <div class="section-icon">
                                <i class="material-icons">schema</i>
                            </div>
                            <div class="section-title">Schema Definitions</div>
                        </div>
                        <p style="color: var(--text-muted); margin-bottom: 20px;">
                            Define data schemas and types used across your DSL plan.
                        </p>
                        <div id="schemaEditor">
                            <!-- Schema editor will be populated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Seed Tab -->
            <div class="tab-content" id="seedTab">
                <div class="plan-overview">
                    <div class="overview-section fade-in">
                        <div class="section-header">
                            <div class="section-icon">
                                <i class="material-icons">grass</i>
                            </div>
                            <div class="section-title">Seed Data</div>
                        </div>
                        <p style="color: var(--text-muted); margin-bottom: 20px;">
                            Define initial data values and configurations for your DSL plan.
                        </p>
                        <div class="seed-container">
                            <div class="seed-controls">
                                <button class="btn btn-primary" id="addSeedBtn">
                                    <i class="material-icons">add</i>
                                    Add Seed Item
                                </button>
                                <button class="btn btn-secondary" id="importSeedBtn">
                                    <i class="material-icons">upload</i>
                                    Import JSON
                                </button>
                                <button class="btn btn-secondary" id="exportSeedBtn">
                                    <i class="material-icons">download</i>
                                    Export JSON
                                </button>
                            </div>
                            <div id="seedEditor">
                                <!-- Seed editor will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Canvas Tab -->
            <div class="tab-content" id="canvasTab">
                <div class="canvas-container">
                    <div class="canvas-header">
                        <div class="canvas-title">
                            <i class="material-icons">account_tree</i>
                            Visual Plan Execution
                        </div>
                        <div class="canvas-controls">
                            <button class="btn btn-primary" id="executeCanvasBtn">
                                <i class="material-icons">play_arrow</i>
                                Execute Plan
                            </button>
                            <button class="btn btn-secondary" id="resetCanvasBtn">
                                <i class="material-icons">refresh</i>
                                Reset Canvas
                            </button>
                            <button class="btn btn-secondary" id="fitCanvasBtn">
                                <i class="material-icons">fit_screen</i>
                                Fit to View
                            </button>
                        </div>
                    </div>
                    <div class="canvas-workspace" id="canvasWorkspace">
                        <div class="canvas-viewport" id="canvasViewport">
                            <!-- Canvas nodes will be rendered here -->
                        </div>
                        <div class="canvas-toolbar">
                            <div class="canvas-status" id="canvasStatus">Ready</div>
                            <div class="canvas-progress" id="canvasProgress"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- LLM Configuration Tab -->
            <div class="tab-content" id="llm-configTab">
                <div class="llm-config-container">
                    <div class="config-header">
                        <div class="config-title">
                            <i class="material-icons">psychology</i>
                            LLM Configuration & Tuning
                        </div>
                        <div class="llm-status">
                            <span id="llmConnectionStatus" class="status-indicator offline">Offline</span>
                            <span id="llmModelInfo" class="model-info">No model loaded</span>
                        </div>
                    </div>

                    <div class="config-grid">
                        <!-- Model Selection Panel -->
                        <div class="config-panel">
                            <div class="panel-header">
                                <h4>ü§ñ Model Selection</h4>
                                <button class="btn btn-sm btn-secondary" onclick="refreshAvailableModels()">
                                    <i class="material-icons">refresh</i>
                                    Refresh
                                </button>
                            </div>
                            <div class="panel-content">
                                <div class="model-source">
                                    <label>Model Source:</label>
                                    <select id="modelSource">
                                        <option value="webllm">WebLLM (Browser)</option>
                                        <option value="ollama">Ollama (Local)</option>
                                        <option value="openai">OpenAI API</option>
                                        <option value="github">GitHub Models (Free)</option>
                                        <option value="gemini">Google Gemini</option>
                                        <option value="groq">Groq (Fast)</option>
                                        <option value="foundry">Foundry (Local)</option>
                                        <option value="huggingface">Hugging Face</option>
                                        <option value="custom">Custom Endpoint</option>
                                    </select>
                                </div>

                                <!-- Dynamic Provider Configuration -->
                                <div class="provider-config" id="providerConfig">
                                    <!-- API Key Configuration for most providers -->
                                    <div class="api-key-section hidden" id="apiKeySection">
                                        <label>API Key:</label>
                                        <input type="password" id="apiKey" placeholder="Enter your API key..." onchange="saveProviderConfig()">
                                        <small class="api-key-help" id="apiKeyHelp"></small>
                                    </div>

                                    <!-- Organization ID for OpenAI -->
                                    <div class="org-id-section hidden" id="orgIdSection">
                                        <label>Organization ID (Optional):</label>
                                        <input type="text" id="orgId" placeholder="Enter organization ID..." onchange="saveProviderConfig()">
                                        <small>Optional: Your OpenAI organization ID</small>
                                    </div>

                                    <!-- Custom Endpoint Configuration -->
                                    <div class="endpoint-section hidden" id="endpointSection">
                                        <label>API Endpoint:</label>
                                        <input type="url" id="customEndpoint" placeholder="https://api.example.com/v1/chat/completions" onchange="saveProviderConfig()">
                                        <small>Custom API endpoint URL</small>
                                    </div>
                                </div>

                                <div class="model-selection" id="modelSelection">
                                    <label>Available Models:</label>
                                    <select id="selectedModel" onchange="onModelChange()">
                                        <option value="">Select a model...</option>
                                    </select>
                                    <div class="model-loading hidden" id="modelLoading">
                                        <span>Loading models...</span>
                                    </div>
                                </div>



                                <div class="model-actions">
                                    <button class="btn btn-primary" onclick="loadSelectedModel()" id="loadModelBtn" disabled>
                                        <i class="material-icons">download</i>
                                        Load Model
                                    </button>
                                    <button class="btn btn-warning" onclick="unloadCurrentModel()" id="unloadModelBtn" disabled>
                                        <i class="material-icons">eject</i>
                                        Unload
                                    </button>
                                </div>

                                <div class="model-info" id="modelDetails">
                                    <div class="loading-progress" id="loadingProgress" class="hidden">
                                        <div class="progress-bar">
                                            <div class="progress-fill" id="progressFill"></div>
                                        </div>
                                        <div class="progress-text" id="progressText">Preparing model download...</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Generation Parameters Panel -->
                        <div class="config-panel">
                            <div class="panel-header">
                                <h4>‚öôÔ∏è Generation Parameters</h4>
                                <button class="btn btn-sm btn-secondary" onclick="resetToDefaults()">
                                    <i class="material-icons">restore</i>
                                    Defaults
                                </button>
                            </div>
                            <div class="panel-content">
                                <div class="param-group">
                                    <label>Temperature: <span id="temperatureValue">0.7</span></label>
                                    <input type="range" id="temperature" min="0" max="2" step="0.1" value="0.7" oninput="updateParamDisplay('temperature')">
                                    <small>Controls randomness. Lower = more focused, Higher = more creative</small>
                                </div>

                                <div class="param-group">
                                    <label>Top P: <span id="topPValue">0.9</span></label>
                                    <input type="range" id="topP" min="0" max="1" step="0.05" value="0.9" oninput="updateParamDisplay('topP')">
                                    <small>Nucleus sampling. Controls diversity by limiting token choices</small>
                                </div>

                                <div class="param-group">
                                    <label>Top K: <span id="topKValue">40</span></label>
                                    <input type="range" id="topK" min="1" max="100" step="1" value="40" oninput="updateParamDisplay('topK')">
                                    <small>Limits token choices to top K most likely tokens</small>
                                </div>

                                <div class="param-group">
                                    <label>Max Tokens: <span id="maxTokensValue">512</span></label>
                                    <input type="range" id="maxTokens" min="50" max="4096" step="50" value="512" oninput="updateParamDisplay('maxTokens')">
                                    <small>Maximum number of tokens to generate</small>
                                </div>

                                <div class="param-group">
                                    <label>Frequency Penalty: <span id="frequencyPenaltyValue">0.0</span></label>
                                    <input type="range" id="frequencyPenalty" min="-2" max="2" step="0.1" value="0.0" oninput="updateParamDisplay('frequencyPenalty')">
                                    <small>Penalizes repeated tokens. Positive = less repetition</small>
                                </div>

                                <div class="param-group">
                                    <label>Presence Penalty: <span id="presencePenaltyValue">0.0</span></label>
                                    <input type="range" id="presencePenalty" min="-2" max="2" step="0.1" value="0.0" oninput="updateParamDisplay('presencePenalty')">
                                    <small>Penalizes tokens based on presence. Encourages new topics</small>
                                </div>

                                <div class="param-group">
                                    <label>Repetition Penalty: <span id="repetitionPenaltyValue">1.1</span></label>
                                    <input type="range" id="repetitionPenalty" min="0.5" max="2" step="0.1" value="1.1" oninput="updateParamDisplay('repetitionPenalty')">
                                    <small>Penalizes repeated sequences. 1.0 = no penalty, >1.0 = less repetition</small>
                                </div>
                            </div>
                        </div>

                        <!-- Test & Monitor Panel -->
                        <div class="config-panel">
                            <div class="panel-header">
                                <h4>üß™ Test & Monitor</h4>
                            </div>
                            <div class="panel-content">
                                <div class="test-section">
                                    <label>Test Prompt:</label>
                                    <textarea id="testPrompt" rows="3" placeholder="Enter test prompt...">Generate a simple greeting message for testing the LLM configuration.</textarea>
                                    <button class="btn btn-primary" onclick="testProviderConfiguration()" id="testLLMBtn" disabled>
                                        <i class="material-icons">send</i>
                                        Test Configuration
                                    </button>
                                </div>

                                <div class="test-results">
                                    <label>Test Response:</label>
                                    <div class="response-box" id="testResponse">
                                        <p class="text-muted">Test response will appear here...</p>
                                    </div>
                                </div>

                                <div class="performance-metrics">
                                    <h5>Performance Metrics</h5>
                                    <div class="metrics-grid">
                                        <div class="metric">
                                            <span class="metric-label">Response Time:</span>
                                            <span class="metric-value" id="responseTime">-</span>
                                        </div>
                                        <div class="metric">
                                            <span class="metric-label">Tokens/sec:</span>
                                            <span class="metric-value" id="tokensPerSecond">-</span>
                                        </div>
                                        <div class="metric">
                                            <span class="metric-label">Total Tokens:</span>
                                            <span class="metric-value" id="totalTokens">-</span>
                                        </div>
                                        <div class="metric">
                                            <span class="metric-label">Memory Usage:</span>
                                            <span class="metric-value" id="memoryUsage">-</span>
                                        </div>
                                    </div>
                                </div>

                                <div class="model-health">
                                    <h5>Model Health</h5>
                                    <div class="health-indicators">
                                        <div class="health-item">
                                            <span class="health-label">Model Status:</span>
                                            <span class="health-status" id="modelHealthStatus">Not Loaded</span>
                                        </div>
                                        <div class="health-item">
                                            <span class="health-label">GPU Acceleration:</span>
                                            <span class="health-status" id="gpuStatus">Checking...</span>
                                        </div>
                                        <div class="health-item">
                                            <span class="health-label">WebGL Support:</span>
                                            <span class="health-status" id="webglStatus">Checking...</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Configuration Actions -->
                    <div class="config-actions">
                        <button class="btn btn-success" onclick="saveConfiguration()">
                            <i class="material-icons">save</i>
                            Save Configuration
                        </button>
                        <button class="btn btn-secondary" onclick="loadConfiguration()">
                            <i class="material-icons">folder_open</i>
                            Load Configuration
                        </button>
                        <button class="btn btn-secondary" onclick="exportConfiguration()">
                            <i class="material-icons">download</i>
                            Export Config
                        </button>
                        <button class="btn btn-warning" onclick="resetConfiguration()">
                            <i class="material-icons">restore</i>
                            Reset All
                        </button>
                    </div>
                </div>
            </div>

            <!-- Import/Export Tab -->
            <div class="tab-content" id="importExportTab">
                <div class="import-export">
                    <div class="overview-section fade-in">
                        <div class="section-header">
                            <div class="section-icon">
                                <i class="material-icons">code</i>
                            </div>
                            <div class="section-title">XML Source</div>
                        </div>
                        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
                            <button class="btn btn-secondary" id="formatXmlBtn">
                                <i class="material-icons">format_align_left</i>
                                Format XML
                            </button>
                            <button class="btn btn-secondary" id="validateXmlBtn">
                                <i class="material-icons">check_circle</i>
                                Validate XML
                            </button>
                            <button class="btn btn-primary" id="syncFromXmlBtn">
                                <i class="material-icons">sync</i>
                                Sync from XML
                            </button>
                        </div>
                        <textarea class="xml-editor" id="xmlEditor" placeholder="Paste your DSL XML here or use Import XML button..."></textarea>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Hidden file input for XML import -->
    <input type="file" id="fileInput" accept=".xml" style="display: none;">

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu" style="display: none;">
        <div class="context-menu-item" data-action="edit">
            <i class="material-icons">edit</i>
            Edit
        </div>
        <div class="context-menu-item" data-action="duplicate">
            <i class="material-icons">content_copy</i>
            Duplicate
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="delete" style="color: var(--error);">
            <i class="material-icons">delete</i>
            Delete
        </div>
    </div>

    <script type="module">
        console.log('üèóÔ∏è Enterprise DSL Designer Loading...');
        
        // Core State Management
        let currentPlan = {
            key: '',
            description: '',
            author: '',
            agents: new Map(),
            stores: new Map(),
            schemas: new Map(),
            seed: new Map()
        };
        
        let currentTab = 'plan';
        let selectedAgent = null;
        let selectedStore = null;
        
        // Initialize the designer
        function init() {
            setupTabNavigation();
            setupEventListeners();
            updateStatistics();
            
            // Create demo data for Canvas testing
            createDemoData();
            
            console.log('‚úÖ Enterprise DSL Designer Ready');
        }
        
        // Create comprehensive demo data showcasing all DSL features
        function createDemoData() {
            // Set plan info
            currentPlan.key = 'SmartBusinessAnalyzer';
            currentPlan.description = 'Comprehensive AI-driven business intelligence and report generation system with data analysis, visualization, and automated insights';
            currentPlan.author = 'Enterprise DSL Designer';
            
            // Add comprehensive seed data
            currentPlan.seed.set('companyName', 'Acme Corporation');
            currentPlan.seed.set('reportType', 'quarterly');
            currentPlan.seed.set('dataSource', 'sales_database');
            currentPlan.seed.set('analysisDepth', 'detailed');
            currentPlan.seed.set('outputFormat', 'pdf');
            currentPlan.seed.set('emailRecipients', ['ceo@acme.com', 'analytics@acme.com']);
            currentPlan.seed.set('thresholds', { revenue: 1000000, growth: 15 });
            currentPlan.seed.set('chartTypes', ['bar', 'line', 'pie']);
            
            // Add complex agent workflow
            const orchestrator = {
                purpose: 'Orchestrator',
                description: 'Master orchestrator that coordinates the entire business analysis workflow'
            };
            currentPlan.agents.set('MasterOrchestrator', orchestrator);
            
            const dataCollector = {
                purpose: 'Collector',
                description: 'Fetches and validates data from multiple business sources'
            };
            currentPlan.agents.set('DataCollector', dataCollector);
            
            const dataAnalyzer = {
                purpose: 'Analyzer', 
                description: 'Performs statistical analysis and identifies business trends'
            };
            currentPlan.agents.set('DataAnalyzer', dataAnalyzer);
            
            const insightGenerator = {
                purpose: 'Generator',
                description: 'Uses AI to generate business insights and recommendations'
            };
            currentPlan.agents.set('InsightGenerator', insightGenerator);
            
            const reportBuilder = {
                purpose: 'Builder',
                description: 'Creates comprehensive reports with charts and visualizations'
            };
            currentPlan.agents.set('ReportBuilder', reportBuilder);
            
            const qualityChecker = {
                purpose: 'Validator',
                description: 'Validates report accuracy and completeness'
            };
            currentPlan.agents.set('QualityChecker', qualityChecker);
            
            const notificationService = {
                purpose: 'Notifier',
                description: 'Distributes reports and sends alerts based on findings'
            };
            currentPlan.agents.set('NotificationService', notificationService);
            
            // Add complex visual designer nodes for MasterOrchestrator
            visualDesignerState.currentAgent = 'MasterOrchestrator';
            
            // Create sophisticated node workflow
            const nodes = new Map();
            
            // 1. Initialize variables
            nodes.set('init_vars', {
                template: statementTemplates.declare,
                data: {
                    Key: 'reportConfig',
                    Type: 'AUTO',
                    Expression: '{"status": "initializing", "timestamp": "' + new Date().toISOString() + '"}'
                },
                position: { x: 100, y: 100 }
            });
            
            // 2. Get user input
            nodes.set('user_input', {
                template: statementTemplates.in,
                data: {
                    Key: 'userRequirements',
                    Template: 'Please specify the report parameters (date range, metrics, format)'
                },
                position: { x: 400, y: 100 }
            });
            
            // 3. Fetch data
            nodes.set('fetch_data', {
                template: statementTemplates.fetch,
                data: {
                    Key: 'businessData',
                    Url: 'https://api.acme.com/business-metrics',
                    Method: 'GET',
                    Headers: '{"Authorization": "Bearer token123"}'
                },
                position: { x: 700, y: 100 }
            });
            
            // 4. SQL analysis
            nodes.set('sql_analysis', {
                template: statementTemplates.sql,
                data: {
                    Key: 'salesAnalysis',
                    Connection: 'business_warehouse',
                    Query: 'SELECT product_category, SUM(revenue) as total_revenue, COUNT(*) as sales_count FROM sales WHERE date_range = ? GROUP BY product_category ORDER BY total_revenue DESC'
                },
                position: { x: 1000, y: 100 }
            });
            
            // 5. Data analysis
            nodes.set('analyze_trends', {
                template: statementTemplates.analyze,
                data: {
                    Key: 'trendAnalysis',
                    Data: 'salesAnalysis',
                    Type: 'TREND',
                    Criteria: 'identify growth patterns and seasonal variations'
                },
                position: { x: 100, y: 300 }
            });
            
            // 6. AI insight generation
            nodes.set('generate_insights', {
                template: statementTemplates.generate,
                data: {
                    Key: 'businessInsights',
                    Keys: 'trendAnalysis,salesAnalysis',
                    MaxTokens: 1000,
                    Creativity: 'Balanced'
                },
                position: { x: 400, y: 300 }
            });
            
            // 7. Conditional logic for recommendations
            nodes.set('check_performance', {
                template: statementTemplates.if,
                data: {
                    Condition: 'trendAnalysis.growth > 15'
                },
                position: { x: 700, y: 300 }
            });
            
            // 8. Loop through data sources
            nodes.set('process_sources', {
                template: statementTemplates.foreach,
                data: {
                    Variable: 'currentSource',
                    Collection: 'dataSources'
                },
                position: { x: 1000, y: 300 }
            });
            
            // 9. Call sub-agent for report building
            nodes.set('call_report_builder', {
                template: statementTemplates.call,
                data: {
                    From: 'MasterOrchestrator',
                    To: 'ReportBuilder',
                    Message: 'Build comprehensive report with insights and visualizations'
                },
                position: { x: 100, y: 500 }
            });
            
            // 10. Design report template
            nodes.set('design_template', {
                template: statementTemplates.design,
                data: {
                    Type: 'UI',
                    Key: 'reportTemplate',
                    Template: 'Create a professional business report template with executive summary, detailed analysis, charts, and recommendations sections'
                },
                position: { x: 400, y: 500 }
            });
            
            // 11. Write report to file
            nodes.set('write_report', {
                template: statementTemplates.write,
                data: {
                    Key: 'finalReport',
                    FileKey: 'business_report_' + new Date().getTime() + '.pdf'
                },
                position: { x: 700, y: 500 }
            });
            
            // 12. Send notifications
            nodes.set('notify_stakeholders', {
                template: statementTemplates.actuate,
                data: {
                    Device: 'email_service',
                    Action: 'send_report',
                    Parameters: '{"recipients": ["ceo@acme.com", "analytics@acme.com"], "subject": "Quarterly Business Report Ready"}'
                },
                position: { x: 1000, y: 500 }
            });
            
            // 13. Final output
            nodes.set('output_summary', {
                template: statementTemplates.out,
                data: {
                    Key: 'executionSummary',
                    Template: 'Business analysis completed successfully. Report generated and distributed to stakeholders.'
                },
                position: { x: 550, y: 700 }
            });
            
            // Store nodes in visual designer state for MasterOrchestrator
            agentNodes.set('MasterOrchestrator', nodes);
            
            // Create simpler workflows for other agents
            createAgentWorkflows();
            
            // Add some stores for data management
            currentPlan.stores.set('BusinessMetrics', {
                type: 'database',
                description: 'Core business metrics and KPIs'
            });
            
            currentPlan.stores.set('ReportTemplates', {
                type: 'file_system',
                description: 'Reusable report templates and layouts'
            });
            
            currentPlan.stores.set('AnalysisCache', {
                type: 'memory',
                description: 'Cached analysis results for performance'
            });
            
            // Add schema definitions
            currentPlan.schemas.set('BusinessMetric', {
                fields: {
                    metric_name: 'STRING',
                    value: 'DOUBLE',
                    timestamp: 'DATETIME',
                    category: 'ENUM'
                }
            });
            
            currentPlan.schemas.set('Report', {
                fields: {
                    title: 'STRING',
                    content: 'TEXT',
                    format: 'ENUMSTR',
                    created_date: 'DATETIME'
                }
            });
            
            // Update the overview display
            updateStatistics();
            
            console.log('ÔøΩ Comprehensive demo data created with:');
            console.log(`   üìä ${currentPlan.agents.size} agents`);
            console.log(`   üå± ${currentPlan.seed.size} seed values`);
            console.log(`   üìÅ ${currentPlan.stores.size} stores`);
            console.log(`   üìã ${currentPlan.schemas.size} schemas`);
            console.log(`   üéØ ${nodes.size} visual workflow nodes`);
        }
        
        // Create visual workflows for all other agents
        function createAgentWorkflows() {
            // DataCollector workflow
            const dataCollectorNodes = new Map();
            dataCollectorNodes.set('init_connection', {
                template: statementTemplates.declare,
                data: {
                    Key: 'dbConnection',
                    Type: 'STRING',
                    Expression: 'business_warehouse'
                },
                position: { x: 100, y: 100 }
            });
            
            dataCollectorNodes.set('fetch_metrics', {
                template: statementTemplates.fetch,
                data: {
                    Key: 'rawData',
                    Url: 'https://api.acme.com/metrics',
                    Method: 'GET'
                },
                position: { x: 400, y: 100 }
            });
            
            dataCollectorNodes.set('validate_data', {
                template: statementTemplates.if,
                data: {
                    Condition: 'rawData.length > 0'
                },
                position: { x: 700, y: 100 }
            });
            
            dataCollectorNodes.set('output_data', {
                template: statementTemplates.out,
                data: {
                    Key: 'validatedData',
                    Template: 'Data collection completed: #rawData.count# records processed'
                },
                position: { x: 400, y: 300 }
            });
            
            agentNodes.set('DataCollector', dataCollectorNodes);
            
            // DataAnalyzer workflow
            const dataAnalyzerNodes = new Map();
            dataAnalyzerNodes.set('load_data', {
                template: statementTemplates.in,
                data: {
                    Key: 'inputData',
                    Template: 'Enter data to analyze'
                },
                position: { x: 100, y: 100 }
            });
            
            dataAnalyzerNodes.set('analyze_trends', {
                template: statementTemplates.analyze,
                data: {
                    Key: 'trendResults',
                    Data: 'inputData',
                    Type: 'TREND',
                    Criteria: 'quarterly growth patterns'
                },
                position: { x: 400, y: 100 }
            });
            
            dataAnalyzerNodes.set('analyze_stats', {
                template: statementTemplates.analyze,
                data: {
                    Key: 'statResults',
                    Data: 'inputData',
                    Type: 'STATISTICAL',
                    Criteria: 'mean, median, standard deviation'
                },
                position: { x: 700, y: 100 }
            });
            
            dataAnalyzerNodes.set('combine_results', {
                template: statementTemplates.assign,
                data: {
                    Key: 'finalAnalysis',
                    Template: 'Trends: #trendResults# | Stats: #statResults#'
                },
                position: { x: 400, y: 300 }
            });
            
            agentNodes.set('DataAnalyzer', dataAnalyzerNodes);
            
            // InsightGenerator workflow
            const insightGeneratorNodes = new Map();
            insightGeneratorNodes.set('prepare_context', {
                template: statementTemplates.declare,
                data: {
                    Key: 'aiContext',
                    Type: 'STRING',
                    Expression: 'Generate business insights from data analysis'
                },
                position: { x: 100, y: 100 }
            });
            
            insightGeneratorNodes.set('generate_insights', {
                template: statementTemplates.generate,
                data: {
                    Key: 'insights',
                    Keys: 'aiContext,finalAnalysis',
                    MaxTokens: 500,
                    Creativity: 'Creative'
                },
                position: { x: 400, y: 100 }
            });
            
            insightGeneratorNodes.set('validate_insights', {
                template: statementTemplates.if,
                data: {
                    Condition: 'insights.length > 100'
                },
                position: { x: 700, y: 100 }
            });
            
            insightGeneratorNodes.set('output_insights', {
                template: statementTemplates.out,
                data: {
                    Key: 'finalInsights',
                    Template: 'AI Generated Insights: #insights#'
                },
                position: { x: 400, y: 300 }
            });
            
            agentNodes.set('InsightGenerator', insightGeneratorNodes);
            
            // ReportBuilder workflow
            const reportBuilderNodes = new Map();
            reportBuilderNodes.set('design_layout', {
                template: statementTemplates.design,
                data: {
                    Type: 'UI',
                    Key: 'reportLayout',
                    Template: 'Professional business report with executive summary and charts'
                },
                position: { x: 100, y: 100 }
            });
            
            reportBuilderNodes.set('process_data', {
                template: statementTemplates.foreach,
                data: {
                    Variable: 'dataPoint',
                    Collection: 'businessData'
                },
                position: { x: 400, y: 100 }
            });
            
            reportBuilderNodes.set('write_report', {
                template: statementTemplates.write,
                data: {
                    Key: 'reportContent',
                    FileKey: 'business_report.pdf'
                },
                position: { x: 700, y: 100 }
            });
            
            reportBuilderNodes.set('confirm_output', {
                template: statementTemplates.out,
                data: {
                    Key: 'reportStatus',
                    Template: 'Report generated successfully and saved to #FileKey#'
                },
                position: { x: 400, y: 300 }
            });
            
            agentNodes.set('ReportBuilder', reportBuilderNodes);
            
            // QualityChecker workflow
            const qualityCheckerNodes = new Map();
            qualityCheckerNodes.set('read_report', {
                template: statementTemplates.read,
                data: {
                    Key: 'reportContent',
                    FileKey: 'business_report.pdf'
                },
                position: { x: 100, y: 100 }
            });
            
            qualityCheckerNodes.set('validate_completeness', {
                template: statementTemplates.if,
                data: {
                    Condition: 'reportContent.sections.length >= 5'
                },
                position: { x: 400, y: 100 }
            });
            
            qualityCheckerNodes.set('check_accuracy', {
                template: statementTemplates.analyze,
                data: {
                    Key: 'accuracyScore',
                    Data: 'reportContent',
                    Type: 'PATTERN',
                    Criteria: 'data consistency and logical flow'
                },
                position: { x: 700, y: 100 }
            });
            
            qualityCheckerNodes.set('quality_result', {
                template: statementTemplates.out,
                data: {
                    Key: 'qualityReport',
                    Template: 'Quality Check: Accuracy Score #accuracyScore# - Report approved'
                },
                position: { x: 400, y: 300 }
            });
            
            agentNodes.set('QualityChecker', qualityCheckerNodes);
            
            // NotificationService workflow
            const notificationNodes = new Map();
            notificationNodes.set('prepare_recipients', {
                template: statementTemplates.declare,
                data: {
                    Key: 'recipients',
                    Type: 'CSV',
                    Expression: 'ceo@acme.com,analytics@acme.com,board@acme.com'
                },
                position: { x: 100, y: 100 }
            });
            
            notificationNodes.set('send_emails', {
                template: statementTemplates.actuate,
                data: {
                    Device: 'email_service',
                    Action: 'send_notification',
                    Parameters: '{"subject": "Business Report Ready", "priority": "high"}'
                },
                position: { x: 400, y: 100 }
            });
            
            notificationNodes.set('log_notifications', {
                template: statementTemplates.write,
                data: {
                    Key: 'notificationLog',
                    FileKey: 'notification_log.txt'
                },
                position: { x: 700, y: 100 }
            });
            
            notificationNodes.set('confirm_sent', {
                template: statementTemplates.out,
                data: {
                    Key: 'notificationStatus',
                    Template: 'Notifications sent to #recipients.count# recipients successfully'
                },
                position: { x: 400, y: 300 }
            });
            
            agentNodes.set('NotificationService', notificationNodes);
            
            console.log(`‚úÖ Created visual workflows for ${agentNodes.size} agents`);
        }
        
        // Tab Navigation
        function setupTabNavigation() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.dataset.tab;
                    
                    // Update active states
                    tabButtons.forEach(b => b.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    button.classList.add('active');
                    const tabElement = document.getElementById(tabId + 'Tab');
                    if (tabElement) {
                        tabElement.classList.add('active');
                    } else {
                        console.warn(`Tab element not found: ${tabId}Tab`);
                    }
                    
                    currentTab = tabId;
                    
                    // Load tab-specific content
                    loadTabContent(tabId);
                });
            });
        }
        
        // Load content for specific tab
        function loadTabContent(tabId) {
            switch(tabId) {
                case 'plan':
                    loadPlanOverview();
                    break;
                case 'agents':
                    loadAgentsView();
                    break;
                case 'store':
                    loadStoreView();
                    break;
                case 'schema':
                    loadSchemaView();
                    break;
                case 'seed':
                    loadSeedView();
                    break;
                case 'canvas':
                    loadCanvasView();
                    break;
                case 'llm-config':
                    loadLLMConfigView();
                    break;
                case 'import-export':
                    loadImportExportView();
                    break;
            }
        }
        
        // Plan Overview
        function loadPlanOverview() {
            const planKey = document.getElementById('planKey');
            const planDescription = document.getElementById('planDescription');
            const planAuthor = document.getElementById('planAuthor');
            
            planKey.value = currentPlan.key;
            planDescription.value = currentPlan.description;
            planAuthor.value = currentPlan.author;
            
            // Update plan title in header
            document.getElementById('planTitle').textContent = currentPlan.key || 'Untitled Plan';
            
            updateStatistics();
        }
        
        // Update statistics
        function updateStatistics() {
            const stats = calculatePlanStatistics();
            
            document.getElementById('totalAgents').textContent = stats.totalAgents;
            document.getElementById('orchestratorAgents').textContent = stats.orchestrators;
            document.getElementById('toolAgents').textContent = stats.tools;
            document.getElementById('aiAgents').textContent = stats.aiAgents;
            document.getElementById('storeFiles').textContent = stats.storeFiles;
            document.getElementById('totalStatements').textContent = stats.totalStatements;
            
            // Update tab badges
            document.getElementById('agentCount').textContent = stats.totalAgents;
            document.getElementById('storeCount').textContent = stats.storeFiles;
        }
        
        function calculatePlanStatistics() {
            let orchestrators = 0, tools = 0, aiAgents = 0, totalStatements = 0;
            
            currentPlan.agents.forEach(agent => {
                switch(agent.purpose?.toLowerCase()) {
                    case 'orchestrator': orchestrators++; break;
                    case 'tool': tools++; break;
                    case 'ai': aiAgents++; break;
                }
                totalStatements += agent.statements?.length || 0;
            });
            
            return {
                totalAgents: currentPlan.agents.size,
                orchestrators,
                tools,
                aiAgents,
                storeFiles: currentPlan.stores.size,
                totalStatements
            };
        }
        
        // Agents View
        function loadAgentsView() {
            const agentsList = document.getElementById('agentsList');
            agentsList.innerHTML = '';
            
            if (currentPlan.agents.size === 0) {
                agentsList.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: var(--text-muted);">
                        <i class="material-icons" style="font-size: 48px; margin-bottom: 16px;">smart_toy</i>
                        <div style="font-size: 16px; margin-bottom: 8px;">No agents yet</div>
                        <div style="font-size: 14px;">Click "Add Agent" to create your first agent</div>
                    </div>
                `;
                return;
            }
            
            currentPlan.agents.forEach((agent, key) => {
                const agentItem = createAgentListItem(key, agent);
                agentsList.appendChild(agentItem);
            });
        }
        
        function createAgentListItem(key, agent) {
            const item = document.createElement('div');
            item.className = 'agent-item';
            item.dataset.agentKey = key;
            
            const purposeClass = `agent-${(agent.purpose || 'tool').toLowerCase()}`;
            const purposeIcon = getPurposeIcon(agent.purpose);
            
            item.innerHTML = `
                <div class="agent-icon ${purposeClass}">
                    <i class="material-icons">${purposeIcon}</i>
                </div>
                <div class="agent-details">
                    <div class="agent-name">${key}</div>
                    <div class="agent-purpose">${agent.purpose || 'Tool'}</div>
                </div>
            `;
            
            item.addEventListener('click', () => selectAgent(key));
            
            return item;
        }
        
        function getPurposeIcon(purpose) {
            switch(purpose?.toLowerCase()) {
                case 'orchestrator': return 'account_tree';
                case 'tool': return 'build';
                case 'ai': return 'psychology';
                case 'data': return 'storage';
                default: return 'smart_toy';
            }
        }
        
        function selectAgent(key) {
            selectedAgent = key;
            
            // Update UI
            document.querySelectorAll('.agent-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.querySelector(`[data-agent-key="${key}"]`).classList.add('selected');
            
            document.getElementById('selectedAgentTitle').textContent = `Agent: ${key}`;
            
            // Load agent canvas
            loadAgentCanvas(key);
        }
        
        function loadAgentCanvas(agentKey) {
            const canvas = document.getElementById('agentCanvas');
            const agent = currentPlan.agents.get(agentKey);
            
            if (!agent) return;
            
            // Create visual designer canvas
            canvas.innerHTML = `
                <div class="visual-designer">
                    <div class="designer-palette">
                        <div class="palette-header">
                            <h4>DSL Statements</h4>
                            <input type="text" class="palette-search" placeholder="Search statements...">
                        </div>
                        <div class="palette-sections">
                            <div class="palette-section">
                                <div class="section-title">Variables & Data</div>
                                <div class="palette-item" data-type="declare">
                                    <i class="material-icons">create</i>
                                    <span>DECLARE</span>
                                </div>
                                <div class="palette-item" data-type="prop">
                                    <i class="material-icons">input</i>
                                    <span>PROP</span>
                                </div>
                                <div class="palette-item" data-type="assign">
                                    <i class="material-icons">assignment</i>
                                    <span>ASSIGN</span>
                                </div>
                            </div>
                            <div class="palette-section">
                                <div class="section-title">User Interaction</div>
                                <div class="palette-item" data-type="in">
                                    <i class="material-icons">input</i>
                                    <span>IN</span>
                                </div>
                                <div class="palette-item" data-type="out">
                                    <i class="material-icons">message</i>
                                    <span>OUT</span>
                                </div>
                                <div class="palette-item" data-type="choice">
                                    <i class="material-icons">radio_button_checked</i>
                                    <span>CHOICE</span>
                                </div>
                            </div>
                            <div class="palette-section">
                                <div class="section-title">Control Flow</div>
                                <div class="palette-item" data-type="if">
                                    <i class="material-icons">call_split</i>
                                    <span>IF</span>
                                </div>
                                <div class="palette-item" data-type="while">
                                    <i class="material-icons">loop</i>
                                    <span>WHILE</span>
                                </div>
                                <div class="palette-item" data-type="switch">
                                    <i class="material-icons">alt_route</i>
                                    <span>SWITCH</span>
                                </div>
                                <div class="palette-item" data-type="case">
                                    <i class="material-icons">arrow_forward</i>
                                    <span>CASE</span>
                                </div>
                            </div>
                            <div class="palette-section">
                                <div class="section-title">Agent Communication</div>
                                <div class="palette-item" data-type="call">
                                    <i class="material-icons">call</i>
                                    <span>CALL</span>
                                </div>
                                <div class="palette-item" data-type="return">
                                    <i class="material-icons">keyboard_return</i>
                                    <span>RETURN</span>
                                </div>
                            </div>
                            <div class="palette-section">
                                <div class="section-title">AI & Generation</div>
                                <div class="palette-item" data-type="prompt">
                                    <i class="material-icons">chat</i>
                                    <span>PROMPT</span>
                                </div>
                                <div class="palette-item" data-type="generate">
                                    <i class="material-icons">auto_awesome</i>
                                    <span>GENERATE</span>
                                </div>
                            </div>
                            <div class="palette-section">
                                <div class="section-title">File Operations</div>
                                <div class="palette-item" data-type="read">
                                    <i class="material-icons">file_open</i>
                                    <span>READ</span>
                                </div>
                                <div class="palette-item" data-type="write">
                                    <i class="material-icons">save</i>
                                    <span>WRITE</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="designer-workspace">
                        <div class="workspace-toolbar">
                            <button class="btn btn-secondary" id="zoomToFit">
                                <i class="material-icons">zoom_out_map</i>
                                Zoom to Fit
                            </button>
                            <button class="btn btn-secondary" id="runAgent">
                                <i class="material-icons">play_arrow</i>
                                Run Agent
                            </button>
                            <div class="toolbar-divider"></div>
                            <div class="zoom-controls">
                                <button class="btn btn-icon" id="zoomOut">
                                    <i class="material-icons">zoom_out</i>
                                </button>
                                <span class="zoom-level">100%</span>
                                <button class="btn btn-icon" id="zoomIn">
                                    <i class="material-icons">zoom_in</i>
                                </button>
                            </div>
                        </div>
                        <div class="canvas-container" id="canvasContainer">
                            <svg class="connection-svg" id="connectionSvg">
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="var(--primary)"/>
                                    </marker>
                                </defs>
                            </svg>
                            <div class="statement-canvas" id="statementCanvas">
                                <!-- Visual statements will be added here -->
                            </div>
                        </div>
                    </div>
                    <div class="designer-inspector">
                        <div class="inspector-header">
                            <h4>Properties</h4>
                        </div>
                        <div class="inspector-content" id="inspectorContent">
                            <div class="inspector-empty">
                                Select a statement to edit properties
                            </div>
                        </div>
                        <div class="inspector-section">
                            <h5>Agent Variables</h5>
                            <div class="variables-list" id="agentVariables">
                                <!-- Variables will be listed here -->
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Initialize the visual designer for this agent
            initializeVisualDesigner(agentKey);
        }
        
        // Store View
        function loadStoreView() {
            const storeTree = document.getElementById('storeTree');
            storeTree.innerHTML = '';
            
            if (currentPlan.stores.size === 0) {
                storeTree.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: var(--text-muted);">
                        <i class="material-icons" style="font-size: 48px; margin-bottom: 16px;">folder</i>
                        <div style="font-size: 16px; margin-bottom: 8px;">No stores yet</div>
                        <div style="font-size: 14px;">Click "Add Store" to create your first store</div>
                    </div>
                `;
                return;
            }
            
            currentPlan.stores.forEach((store, key) => {
                const storeItem = createStoreTreeItem(key, store);
                storeTree.appendChild(storeItem);
            });
        }
        
        function createStoreTreeItem(key, store) {
            const item = document.createElement('div');
            item.className = 'tree-item';
            item.dataset.storeKey = key;
            
            item.innerHTML = `
                <i class="material-icons">storage</i>
                <span>${key}</span>
            `;
            
            item.addEventListener('click', () => selectStore(key));
            
            return item;
        }
        
        function selectStore(key) {
            selectedStore = key;
            
            // Update UI
            document.querySelectorAll('.tree-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.querySelector(`[data-store-key="${key}"]`).classList.add('selected');
            
            document.getElementById('selectedStoreTitle').textContent = `Store: ${key}`;
            
            // Load store editor
            loadStoreEditor(key);
        }
        
        function loadStoreEditor(storeKey) {
            const editorContent = document.getElementById('storeEditorContent');
            const store = currentPlan.stores.get(storeKey);
            
            if (!store) return;
            
            editorContent.innerHTML = `
                <div style="text-align: center; color: var(--text-muted); padding: 40px;">
                    <i class="material-icons" style="font-size: 64px; margin-bottom: 20px;">construction</i>
                    <div style="font-size: 18px; margin-bottom: 12px;">Store Editor Coming Soon</div>
                    <div style="font-size: 14px;">Visual store structure editor will be implemented here</div>
                    <div style="margin-top: 20px; padding: 20px; background: var(--surface); border-radius: var(--radius); text-align: left;">
                        <strong>Store Details:</strong><br>
                        Key: ${storeKey}<br>
                        Type: Storage Definition
                    </div>
                </div>
            `;
        }
        
        // Schema View
        function loadSchemaView() {
            const schemaEditor = document.getElementById('schemaEditor');
            schemaEditor.innerHTML = `
                <div style="text-align: center; color: var(--text-muted); padding: 40px;">
                    <i class="material-icons" style="font-size: 64px; margin-bottom: 20px;">construction</i>
                    <div style="font-size: 18px; margin-bottom: 12px;">Schema Editor Coming Soon</div>
                    <div style="font-size: 14px;">Data schema definition editor will be implemented here</div>
                </div>
            `;
        }
        
        // Seed View
        function loadSeedView() {
            const seedEditor = document.getElementById('seedEditor');
            
            // Initialize seed data if not exists
            if (!currentPlan.seed) {
                currentPlan.seed = new Map();
            }
            
            let seedHtml = '<div class="seed-items">';
            
            if (currentPlan.seed.size === 0) {
                seedHtml += `
                    <div class="empty-state">
                        <i class="material-icons">grass</i>
                        <div class="empty-title">No Seed Data</div>  
                        <div class="empty-description">Add seed data to initialize your DSL plan with predefined values</div>
                    </div>
                `;
            } else {
                currentPlan.seed.forEach((value, key) => {
                    seedHtml += `
                        <div class="seed-item" data-key="${key}">
                            <div class="seed-header">
                                <div class="seed-key">${key}</div>
                                <div class="seed-actions">
                                    <button class="btn-icon" onclick="editSeedItem('${key}')">
                                        <i class="material-icons">edit</i>
                                    </button>
                                    <button class="btn-icon" onclick="deleteSeedItem('${key}')">
                                        <i class="material-icons">delete</i>
                                    </button>
                                </div>
                            </div>
                            <div class="seed-value">${JSON.stringify(value, null, 2)}</div>
                        </div>
                    `;
                });
            }
            
            seedHtml += '</div>';
            seedEditor.innerHTML = seedHtml;
        }
        
        // Seed Management Functions
        function addSeedItem() {
            const key = prompt('Enter seed key:');
            if (!key) return;
            
            const value = prompt('Enter seed value (JSON):');
            if (value === null) return;
            
            try {
                const parsedValue = JSON.parse(value || '""');
                currentPlan.seed.set(key, parsedValue);
                loadSeedView();
                console.log(`‚úÖ Added seed item: ${key}`);
            } catch (e) {
                alert('Invalid JSON format');
            }
        }
        
        function editSeedItem(key) {
            const currentValue = currentPlan.seed.get(key);
            const newValue = prompt('Edit seed value (JSON):', JSON.stringify(currentValue));
            if (newValue === null) return;
            
            try {
                const parsedValue = JSON.parse(newValue);
                currentPlan.seed.set(key, parsedValue);
                loadSeedView();
                console.log(`‚úÖ Updated seed item: ${key}`);
            } catch (e) {
                alert('Invalid JSON format');
            }
        }
        
        function deleteSeedItem(key) {
            if (confirm(`Delete seed item "${key}"?`)) {
                currentPlan.seed.delete(key);
                loadSeedView();
                console.log(`üóëÔ∏è Deleted seed item: ${key}`);
            }
        }
        
        function importSeedData() {
            const jsonStr = prompt('Paste JSON seed data:');
            if (!jsonStr) return;
            
            try {
                const seedData = JSON.parse(jsonStr);
                Object.entries(seedData).forEach(([key, value]) => {
                    currentPlan.seed.set(key, value);
                });
                loadSeedView();
                console.log(`‚úÖ Imported ${Object.keys(seedData).length} seed items`);
            } catch (e) {
                alert('Invalid JSON format');
            }
        }
        
        function exportSeedData() {
            const seedData = {};
            currentPlan.seed.forEach((value, key) => {
                seedData[key] = value;
            });
            
            const jsonStr = JSON.stringify(seedData, null, 2);
            
            // Create download link
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'seed-data.json';
            a.click();
            URL.revokeObjectURL(url);
            
            console.log(`‚úÖ Exported seed data`);
        }
        
        // Canvas View Implementation
        function loadCanvasView() {
            const viewport = document.getElementById('canvasViewport');
            if (!viewport) return;
            
            // Clear existing canvas
            viewport.innerHTML = '';
            
            // Initialize canvas state
            canvasState.nodes.clear();
            canvasState.connections = [];
            canvasState.isExecuting = false;
            canvasState.currentStep = 0;
            
            updateCanvasStatus('Ready - Click Execute Plan to start');
            
            if (currentPlan.agents.size === 0) {
                showEmptyCanvasState();
                return;
            }
            
            console.log('üé® Canvas view loaded');
        }
        
        function showEmptyCanvasState() {
            const viewport = document.getElementById('canvasViewport');
            viewport.innerHTML = `
                <div class="empty-canvas-state">
                    <i class="material-icons">account_tree</i>
                    <div class="empty-title">No Agents to Execute</div>
                    <div class="empty-description">Add agents to your plan to see them visualized here</div>
                </div>
            `;
        }
        
        // Canvas State Management
        let canvasState = {
            nodes: new Map(),
            connections: [],
            viewport: { x: 0, y: 0, scale: 1 },
            isExecuting: false,
            currentStep: 0,
            totalSteps: 0
        };
        
        // Store visual nodes for each agent
        let agentNodes = new Map();
        
        // Canvas Node Creation
        function createCanvasNode(nodeId, type, data, x = 100, y = 100) {
            const node = document.createElement('div');
            node.className = 'canvas-node';
            node.id = `canvas-node-${nodeId}`;
            node.style.left = `${x}px`;
            node.style.top = `${y}px`;
            
            const typeColors = {
                'DECLARE': '#3b82f6',
                'ASSIGN': '#10b981', 
                'IN': '#f59e0b',
                'OUT': '#ef4444',
                'GENERATE': '#8b5cf6',
                'CALL': '#ec4899',
                'IF': '#6366f1',
                'WHILE': '#14b8a6',
                'READ': '#6b7280',
                'WRITE': '#374151'
            };
            
            const color = typeColors[type] || '#6b7280';
            
            node.innerHTML = `
                <div class="node-header">
                    <div class="node-title">
                        <span class="node-type-badge" style="background: ${color};">${type}</span>
                        ${data.Key || nodeId}
                    </div>
                    <div class="node-status" id="status-${nodeId}">
                        <i class="material-icons">radio_button_unchecked</i>
                    </div>
                </div>
                <div class="node-content">
                    ${formatNodeContent(type, data)}
                </div>
            `;
            
            // Store node reference
            canvasState.nodes.set(nodeId, {
                element: node,
                type: type,
                data: data,
                status: 'pending'
            });
            
            return node;
        }
        
        function formatNodeContent(type, data) {
            switch (type) {
                case 'DECLARE':
                    return `<strong>Type:</strong> ${data.Type || 'STRING'}<br><strong>Value:</strong> ${data.Expression || 'null'}`;
                case 'ASSIGN':
                    return `<strong>Value:</strong> ${data.Template || ''}`;
                case 'IN':
                    return `<strong>Prompt:</strong> ${data.Template || 'Enter input'}`;
                case 'OUT':
                    return `<strong>Output:</strong> ${data.Template || ''}`;
                case 'GENERATE':
                    return `<strong>AI Generate</strong><br>Max Tokens: ${data.MaxTokens || 100}`;
                case 'CALL':
                    return `<strong>Target:</strong> ${data.ToKey || ''}<br><strong>Variables:</strong> ${data.Variables || ''}`;
                default:
                    return JSON.stringify(data, null, 2).substring(0, 100) + '...';
            }
        }
        
        // Canvas Execution Engine
        async function executeCanvasPlan() {
            if (canvasState.isExecuting) {
                updateCanvasStatus('Already executing...');
                return;
            }
            
            const viewport = document.getElementById('canvasViewport');
            viewport.innerHTML = '';
            
            // Convert current plan to canvas nodes
            const nodes = generateCanvasNodesFromPlan();
            if (nodes.length === 0) {
                showEmptyCanvasState();
                return;
            }
            
            // Layout nodes
            layoutCanvasNodes(nodes);
            
            // Add nodes to viewport
            nodes.forEach(nodeInfo => {
                viewport.appendChild(nodeInfo.element);
            });
            
            // Draw connections
            drawCanvasConnections();
            
            // Start execution
            canvasState.isExecuting = true;
            canvasState.currentStep = 0;
            canvasState.totalSteps = nodes.length;
            
            updateCanvasStatus('Executing plan...');
            updateCanvasProgress(0, nodes.length);
            
            // Execute nodes sequentially
            for (let i = 0; i < nodes.length; i++) {
                const nodeInfo = nodes[i];
                await executeCanvasNode(nodeInfo);
                canvasState.currentStep++;
                updateCanvasProgress(i + 1, nodes.length);
                
                // Small delay between steps
                await sleep(500);
            }
            
            canvasState.isExecuting = false;
            updateCanvasStatus('Execution completed!');
        }
        
        function generateCanvasNodesFromPlan() {
            const nodes = [];
            let nodeIndex = 0;
            
            // Generate nodes from agents
            currentPlan.agents.forEach((agent, agentKey) => {
                // If agent has visual designer nodes, use those
                if (visualDesignerState.currentAgent === agentKey && visualDesignerState.nodes.size > 0) {
                    visualDesignerState.nodes.forEach((nodeData, nodeId) => {
                        const canvasNode = createCanvasNode(
                            `${agentKey}_${nodeId}`,
                            nodeData.template.type,
                            nodeData.data,
                            100 + (nodeIndex * 250),
                            100 + Math.floor(nodeIndex / 4) * 200
                        );
                        
                        nodes.push({
                            id: `${agentKey}_${nodeId}`,
                            element: canvasNode,
                            agentKey: agentKey,
                            nodeData: nodeData
                        });
                        nodeIndex++;
                    });
                } else {
                    // Create a basic node for the agent
                    const canvasNode = createCanvasNode(
                        agentKey,
                        'AGENT',
                        { Purpose: agent.purpose || 'Tool' },
                        100 + (nodeIndex * 250),
                        100
                    );
                    
                    nodes.push({
                        id: agentKey,
                        element: canvasNode,
                        agentKey: agentKey,
                        nodeData: null
                    });
                    nodeIndex++;
                }
            });
            
            return nodes;
        }
        
        function layoutCanvasNodes(nodes) {
            // Simple grid layout
            const cols = Math.ceil(Math.sqrt(nodes.length));
            nodes.forEach((nodeInfo, index) => {
                const row = Math.floor(index / cols);
                const col = index % cols;
                
                const x = 100 + col * 300;
                const y = 100 + row * 200;
                
                nodeInfo.element.style.left = `${x}px`;
                nodeInfo.element.style.top = `${y}px`;
            });
        }
        
        function drawCanvasConnections() {
            // Create SVG overlay for connections
            const viewport = document.getElementById('canvasViewport');
            const existing = viewport.querySelector('.canvas-connections');
            if (existing) existing.remove();
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'canvas-connections');
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '5';
            
            // Add arrow marker
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '7');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '3.5');
            marker.setAttribute('orient', 'auto');
            
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
            polygon.setAttribute('fill', 'var(--primary)');
            
            marker.appendChild(polygon);
            defs.appendChild(marker);
            svg.appendChild(defs);
            
            viewport.appendChild(svg);
        }
        
        async function executeCanvasNode(nodeInfo) {
            const { element, nodeData } = nodeInfo;
            
            // Update node status to active
            setNodeStatus(nodeInfo.id, 'active');
            element.classList.add('active');
            
            // Simulate execution based on node type
            if (nodeData) {
                await executeStatement(nodeData);
            } else {
                // Basic agent execution
                await sleep(1000);
            }
            
            // Update node status to completed
            setNodeStatus(nodeInfo.id, 'completed');
            element.classList.remove('active');
            element.classList.add('completed');
        }
        
        function setNodeStatus(nodeId, status) {
            const statusElement = document.getElementById(`status-${nodeId}`);
            if (!statusElement) return;
            
            const icon = statusElement.querySelector('i');
            if (!icon) return;
            
            switch (status) {
                case 'active':
                    icon.textContent = 'radio_button_checked';
                    icon.style.color = 'var(--warning)';
                    break;
                case 'completed':
                    icon.textContent = 'check_circle';
                    icon.style.color = 'var(--success)';
                    break;
                case 'error':
                    icon.textContent = 'error';
                    icon.style.color = 'var(--error)';
                    break;
                default:
                    icon.textContent = 'radio_button_unchecked';
                    icon.style.color = 'var(--text-muted)';
            }
        }
        
        function updateCanvasStatus(message) {
            const statusElement = document.getElementById('canvasStatus');
            if (statusElement) {
                statusElement.textContent = message;
            }
        }
        
        function updateCanvasProgress(current, total) {
            const progressElement = document.getElementById('canvasProgress');
            if (progressElement) {
                progressElement.textContent = `${current} / ${total} steps completed`;
            }
        }
        
        function resetCanvas() {
            const viewport = document.getElementById('canvasViewport');
            if (viewport) {
                viewport.innerHTML = '';
            }
            
            canvasState.nodes.clear();
            canvasState.connections = [];
            canvasState.isExecuting = false;
            canvasState.currentStep = 0;
            
            updateCanvasStatus('Canvas reset - Ready to execute');
            updateCanvasProgress(0, 0);
        }
        
        function fitCanvasToView() {
            // Simple fit implementation - center the view
            const viewport = document.getElementById('canvasViewport');
            if (!viewport) return;
            
            canvasState.viewport = { x: 0, y: 0, scale: 1 };
            updateCanvasStatus('View reset to center');
        }
        
        // Import/Export View
        function loadImportExportView() {
            const xmlEditor = document.getElementById('xmlEditor');
            if (xmlEditor.value.trim() === '') {
                xmlEditor.value = generateXML();
            }
        }

        // LLM Configuration Management
        let currentLLMConfig = {
            source: 'webllm',
            model: '',
            temperature: 0.7,
            topP: 0.9,
            topK: 40,
            maxTokens: 512,
            frequencyPenalty: 0.0,
            presencePenalty: 0.0,
            repetitionPenalty: 1.1,
            systemPrompt: 'You are a helpful AI assistant specialized in DSL execution and plan orchestration. Provide clear, accurate, and contextually relevant responses.',
            enableStreaming: true,
            enableCaching: true,
            requestTimeout: 30
        };

        let currentEngine = null;
        let isModelLoading = false;

        function loadLLMConfigView() {
            // Initialize LLM configuration view
            console.log('Loading LLM Configuration view');
            
            // Load saved configuration first
            loadSavedLLMConfig();
            
            updateLLMStatus();
            checkSystemCapabilities();
            updateModelList();
            populateConfigurationForm();
            
            // Wire up event listeners
            const modelSource = document.getElementById('modelSource');
            if (modelSource) {
                modelSource.addEventListener('change', async () => {
                    const provider = modelSource.value;
                    console.log('Updating model list for provider:', provider);
                    updateProviderConfigUI(provider);
                    await loadModelsForProvider(provider);
                    currentLLMConfig.source = provider;
                    saveProviderConfig();
                });
            }
            
            // Wire up model selection
            const modelSelect = document.getElementById('selectedModel');
            if (modelSelect) {
                modelSelect.addEventListener('change', () => {
                    currentLLMConfig.model = modelSelect.value;
                    saveProviderConfig();
                    console.log(`Selected model: ${modelSelect.value}`);
                });
            }
            
            // Wire up parameter changes to save automatically
            const parameterInputs = ['temperature', 'topP', 'maxTokens', 'systemPrompt'];
            parameterInputs.forEach(param => {
                const element = document.getElementById(param);
                if (element) {
                    element.addEventListener('change', () => {
                        currentLLMConfig[param] = element.type === 'number' ? parseFloat(element.value) : element.value;
                        saveProviderConfig();
                        console.log(`Updated ${param}: ${element.value}`);
                    });
                }
            });
        }

        function updateLLMStatus() {
            const statusElement = document.getElementById('llmConnectionStatus');
            const modelInfoElement = document.getElementById('llmModelInfo');
            const tabStatusElement = document.getElementById('llmStatus');

            if (currentEngine && currentLLMConfig.model) {
                if (statusElement) {
                    statusElement.textContent = 'Online';
                    statusElement.className = 'status-indicator online';
                }
                if (modelInfoElement) {
                    modelInfoElement.textContent = `${currentLLMConfig.model} loaded`;
                }
                if (tabStatusElement) {
                    tabStatusElement.textContent = '‚óè';
                    tabStatusElement.className = 'tab-status online';
                }
            } else if (isModelLoading) {
                if (statusElement) {
                    statusElement.textContent = 'Loading';
                    statusElement.className = 'status-indicator loading';
                }
                if (modelInfoElement) {
                    modelInfoElement.textContent = 'Loading model...';
                }
                if (tabStatusElement) {
                    tabStatusElement.textContent = '‚óè';
                    tabStatusElement.className = 'tab-status loading';
                }
            } else {
                if (statusElement) {
                    statusElement.textContent = 'Offline';
                    statusElement.className = 'status-indicator offline';
                }
                if (modelInfoElement) {
                    modelInfoElement.textContent = 'No model loaded';
                }
                if (tabStatusElement) {
                    tabStatusElement.textContent = '‚óè';
                    tabStatusElement.className = 'tab-status offline';
                }
            }
        }

        function checkSystemCapabilities() {
            // Check WebGL support
            const webglStatus = document.getElementById('webglStatus');
            if (webglStatus) {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (gl) {
                        webglStatus.textContent = 'Supported';
                        webglStatus.className = 'health-status healthy';
                    } else {
                        webglStatus.textContent = 'Not Supported';
                        webglStatus.className = 'health-status error';
                    }
                } catch (e) {
                    webglStatus.textContent = 'Error';
                    webglStatus.className = 'health-status error';
                }
            }

            // Check GPU acceleration
            const gpuStatus = document.getElementById('gpuStatus');
            if (gpuStatus) {
                if (navigator.gpu) {
                    gpuStatus.textContent = 'Available';
                    gpuStatus.className = 'health-status healthy';
                } else {
                    gpuStatus.textContent = 'Not Available';
                    gpuStatus.className = 'health-status warning';
                }
            }

            // Update model health status
            const modelHealthStatus = document.getElementById('modelHealthStatus');
            if (modelHealthStatus) {
                if (currentEngine) {
                    modelHealthStatus.textContent = 'Healthy';
                    modelHealthStatus.className = 'health-status healthy';
                } else {
                    modelHealthStatus.textContent = 'Not Loaded';
                    modelHealthStatus.className = 'health-status error';
                }
            }
        }

        function updateModelList() {
            const modelSource = document.getElementById('modelSource');
            if (!modelSource) return;

            const provider = modelSource.value;
            console.log('Updating model list for provider:', provider);

            // Update provider configuration UI
            updateProviderConfigUI(provider);

            // Load models for the selected provider
            loadModelsForProvider(provider);

            // Update current configuration
            currentLLMConfig.source = provider;
            saveProviderConfig();
        }

        function updateProviderConfigUI(provider) {
            const apiKeySection = document.getElementById('apiKeySection');
            const orgIdSection = document.getElementById('orgIdSection');
            const endpointSection = document.getElementById('endpointSection');
            const apiKeyHelp = document.getElementById('apiKeyHelp');
            const apiKeyInput = document.getElementById('apiKey');
            const endpointInput = document.getElementById('customEndpoint');

            // Hide all sections initially
            if (apiKeySection) apiKeySection.classList.add('hidden');
            if (orgIdSection) orgIdSection.classList.add('hidden');
            if (endpointSection) endpointSection.classList.add('hidden');

            // Load saved configuration for this provider
            loadProviderConfig(provider);

            switch (provider) {
                case 'openai':
                    if (apiKeySection) apiKeySection.classList.remove('hidden');
                    if (orgIdSection) orgIdSection.classList.remove('hidden');
                    if (apiKeyHelp) apiKeyHelp.textContent = 'Get your API key from: https://platform.openai.com/api-keys';
                    if (endpointInput) endpointInput.value = 'https://api.openai.com/v1/chat/completions';
                    break;
                case 'github':
                    if (apiKeySection) apiKeySection.classList.remove('hidden');
                    if (apiKeyHelp) apiKeyHelp.textContent = 'Get your GitHub token from: https://github.com/settings/tokens (Free tier available)';
                    if (endpointInput) endpointInput.value = 'https://models.inference.ai.azure.com/chat/completions';
                    break;
                case 'gemini':
                    if (apiKeySection) apiKeySection.classList.remove('hidden');
                    if (apiKeyHelp) apiKeyHelp.textContent = 'Get your API key from: https://makersuite.google.com/app/apikey';
                    if (endpointInput) endpointInput.value = 'https://generativelanguage.googleapis.com/v1beta/models/';
                    break;
                case 'groq':
                    if (apiKeySection) apiKeySection.classList.remove('hidden');
                    if (apiKeyHelp) apiKeyHelp.textContent = 'Get your API key from: https://console.groq.com/keys (Fast inference, free tier)';
                    if (endpointInput) endpointInput.value = 'https://api.groq.com/openai/v1/chat/completions';
                    break;
                case 'huggingface':
                    if (apiKeySection) apiKeySection.classList.remove('hidden');
                    if (apiKeyHelp) apiKeyHelp.textContent = 'Get your API key from: https://huggingface.co/settings/tokens';
                    if (endpointInput) endpointInput.value = 'https://api-inference.huggingface.co';
                    break;
                case 'foundry':
                    if (endpointSection) endpointSection.classList.remove('hidden');
                    if (endpointInput) endpointInput.value = 'http://localhost:5273/v1/chat/completions';
                    break;
                case 'ollama':
                    if (endpointSection) endpointSection.classList.remove('hidden');
                    if (endpointInput) endpointInput.value = 'http://localhost:11434/api/chat';
                    break;
                case 'custom':
                    if (apiKeySection) apiKeySection.classList.remove('hidden');
                    if (endpointSection) endpointSection.classList.remove('hidden');
                    if (apiKeyHelp) apiKeyHelp.textContent = 'Enter your custom API key and endpoint';
                    break;
                case 'webllm':
                default:
                    // No additional configuration needed for WebLLM
                    break;
            }
        }

        function onModelChange() {
            const selectedModel = document.getElementById('selectedModel');
            const loadBtn = document.getElementById('loadModelBtn');
            const testBtn = document.getElementById('testLLMBtn');
            const unloadBtn = document.getElementById('unloadModelBtn');

            if (selectedModel && loadBtn) {
                if (selectedModel.value && !isModelLoading) {
                    loadBtn.disabled = false;
                } else {
                    loadBtn.disabled = true;
                }
            }

            if (testBtn) {
                if (currentEngine && !isModelLoading) {
                    testBtn.disabled = false;
                } else {
                    testBtn.disabled = true;
                }
            }

            if (unloadBtn) {
                unloadBtn.disabled = !currentEngine;
            }
        }

        function populateConfigurationForm() {
            // Populate form fields with current configuration - safely
            const elements = {
                modelSource: document.getElementById('modelSource'),
                selectedModel: document.getElementById('selectedModel'),
                temperature: document.getElementById('temperature'),
                topP: document.getElementById('topP'),
                topK: document.getElementById('topK'),
                maxTokens: document.getElementById('maxTokens'),
                frequencyPenalty: document.getElementById('frequencyPenalty'),
                presencePenalty: document.getElementById('presencePenalty'),
                repetitionPenalty: document.getElementById('repetitionPenalty'),
                customSystemPrompt: document.getElementById('customSystemPrompt'),
                enableStreaming: document.getElementById('enableStreaming'),
                enableCaching: document.getElementById('enableCaching'),
                requestTimeout: document.getElementById('requestTimeout')
            };

            if (elements.modelSource) elements.modelSource.value = currentLLMConfig.source;
            if (elements.selectedModel) elements.selectedModel.value = currentLLMConfig.model;
            if (elements.temperature) elements.temperature.value = currentLLMConfig.temperature;
            if (elements.topP) elements.topP.value = currentLLMConfig.topP;
            if (elements.topK) elements.topK.value = currentLLMConfig.topK;
            if (elements.maxTokens) elements.maxTokens.value = currentLLMConfig.maxTokens;
            if (elements.frequencyPenalty) elements.frequencyPenalty.value = currentLLMConfig.frequencyPenalty;
            if (elements.presencePenalty) elements.presencePenalty.value = currentLLMConfig.presencePenalty;
            if (elements.repetitionPenalty) elements.repetitionPenalty.value = currentLLMConfig.repetitionPenalty;
            if (elements.customSystemPrompt) elements.customSystemPrompt.value = currentLLMConfig.systemPrompt;
            if (elements.enableStreaming) elements.enableStreaming.checked = currentLLMConfig.enableStreaming;
            if (elements.enableCaching) elements.enableCaching.checked = currentLLMConfig.enableCaching;
            if (elements.requestTimeout) elements.requestTimeout.value = currentLLMConfig.requestTimeout;

            // Update display values
            updateParamDisplay('temperature');
            updateParamDisplay('topP');
            updateParamDisplay('topK');
            updateParamDisplay('maxTokens');
            updateParamDisplay('frequencyPenalty');
            updateParamDisplay('presencePenalty');
            updateParamDisplay('repetitionPenalty');
            updateParamDisplay('requestTimeout');
        }

        function updateParamDisplay(paramName) {
            const input = document.getElementById(paramName);
            const display = document.getElementById(paramName + 'Value');
            if (input && display) {
                display.textContent = input.value;
                // Update configuration
                currentLLMConfig[paramName] = parseFloat(input.value) || input.value;
            }
        }

        // Placeholder functions for LLM configuration actions
        function refreshAvailableModels() {
            updateModelList();
            console.log('Available models refreshed');
        }

        async function loadSelectedModel() {
            const selectedModel = document.getElementById('selectedModel');
            if (!selectedModel || !selectedModel.value || isModelLoading) return;

            isModelLoading = true;
            updateLLMStatus();

            const progressContainer = document.getElementById('loadingProgress');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');

            try {
                if (progressContainer) progressContainer.style.display = 'block';
                if (progressText) progressText.textContent = 'Initializing WebLLM...';
                if (progressFill) progressFill.style.width = '10%';

                // Check if WebLLM is available
                if (typeof CreateMLCEngine === 'undefined') {
                    throw new Error('WebLLM is not available. Please include the WebLLM script.');
                }

                if (progressText) progressText.textContent = 'Creating engine...';
                if (progressFill) progressFill.style.width = '30%';

                // Create engine with progress callback
                currentEngine = await CreateMLCEngine(selectedModel.value, {
                    initProgressCallback: (progress) => {
                        const percentage = Math.round(progress.progress * 100);
                        if (progressFill) progressFill.style.width = `${30 + (percentage * 0.6)}%`;
                        if (progressText) progressText.textContent = `${progress.text} (${percentage}%)`;
                    }
                });

                if (progressFill) progressFill.style.width = '100%';
                if (progressText) progressText.textContent = 'Model loaded successfully!';

                currentLLMConfig.model = selectedModel.value;
                window.webLLMEngine = currentEngine; // Make available globally

                setTimeout(() => {
                    if (progressContainer) progressContainer.style.display = 'none';
                    if (progressFill) progressFill.style.width = '0%';
                }, 2000);

                console.log('WebLLM model loaded:', selectedModel.value);

            } catch (error) {
                if (progressText) progressText.textContent = `Error: ${error.message}`;
                if (progressFill) progressFill.style.width = '0%';
                console.error('Failed to load WebLLM model:', error);

                setTimeout(() => {
                    if (progressContainer) progressContainer.style.display = 'none';
                }, 3000);
            } finally {
                isModelLoading = false;
                updateLLMStatus();
                onModelChange();
                checkSystemCapabilities();
            }
        }

        function unloadCurrentModel() {
            if (currentEngine) {
                try {
                    currentEngine = null;
                    window.webLLMEngine = null;
                    currentLLMConfig.model = '';
                    console.log('WebLLM model unloaded');
                } catch (error) {
                    console.error('Error unloading model:', error);
                }
            }
            
            updateLLMStatus();
            onModelChange();
            checkSystemCapabilities();
        }

        async function testLLMConfiguration() {
            const testPrompt = document.getElementById('testPrompt');
            const responseBox = document.getElementById('testResponse');

            if (!currentEngine || !testPrompt || !testPrompt.value.trim()) {
                console.log('Cannot test: no engine or prompt');
                return;
            }

            const startTime = Date.now();
            if (responseBox) responseBox.innerHTML = '<p class="text-muted">Generating response...</p>';

            try {
                const response = await currentEngine.chat.completions.create({
                    messages: [
                        { role: 'system', content: currentLLMConfig.systemPrompt },
                        { role: 'user', content: testPrompt.value }
                    ],
                    temperature: currentLLMConfig.temperature,
                    top_p: currentLLMConfig.topP,
                    max_tokens: Math.min(currentLLMConfig.maxTokens, 1000),
                    stream: currentLLMConfig.enableStreaming
                });

                const endTime = Date.now();
                const responseTime = (endTime - startTime) / 1000;

                let content = '';
                if (currentLLMConfig.enableStreaming) {
                    if (responseBox) responseBox.innerHTML = '';
                    for await (const chunk of response) {
                        const delta = chunk.choices[0]?.delta?.content || '';
                        content += delta;
                        if (responseBox) responseBox.innerHTML = `<pre>${content}</pre>`;
                    }
                } else {
                    content = response.choices[0]?.message?.content || 'No response generated';
                    if (responseBox) responseBox.innerHTML = `<pre>${content}</pre>`;
                }

                // Update performance metrics
                const tokenCount = content.split(' ').length;
                const responseTimeEl = document.getElementById('responseTime');
                const tokensPerSecondEl = document.getElementById('tokensPerSecond');
                const totalTokensEl = document.getElementById('totalTokens');
                const memoryUsageEl = document.getElementById('memoryUsage');

                if (responseTimeEl) responseTimeEl.textContent = `${responseTime.toFixed(2)}s`;
                if (tokensPerSecondEl) tokensPerSecondEl.textContent = `${(tokenCount / responseTime).toFixed(1)}`;
                if (totalTokensEl) totalTokensEl.textContent = tokenCount;
                if (memoryUsageEl) memoryUsageEl.textContent = `${(performance.memory?.usedJSHeapSize / 1024 / 1024).toFixed(1)}MB` || 'N/A';

            } catch (error) {
                if (responseBox) responseBox.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                console.error('Test generation failed:', error);
            }
        }

        function resetToDefaults() {
            currentLLMConfig = {
                source: 'webllm',
                model: '',
                temperature: 0.7,
                topP: 0.9,
                topK: 40,
                maxTokens: 512,
                frequencyPenalty: 0.0,
                presencePenalty: 0.0,
                repetitionPenalty: 1.1,
                systemPrompt: 'You are a helpful AI assistant specialized in DSL execution and plan orchestration. Provide clear, accurate, and contextually relevant responses.',
                enableStreaming: true,
                enableCaching: true,
                requestTimeout: 30
            };
            populateConfigurationForm();
        }

        function updateSystemPrompt() {
            const template = document.getElementById('systemPromptTemplate');
            const customPrompt = document.getElementById('customSystemPrompt');

            if (!template || !customPrompt) return;

            const templates = {
                default: 'You are a helpful AI assistant specialized in DSL execution and plan orchestration. Provide clear, accurate, and contextually relevant responses.',
                creative: 'You are a creative AI assistant that excels at generating imaginative and innovative solutions. Think outside the box and provide unique perspectives.',
                analytical: 'You are an analytical AI assistant focused on logical reasoning, data analysis, and systematic problem-solving. Provide detailed and methodical responses.',
                coding: 'You are a coding AI assistant specialized in software development, debugging, and code optimization. Provide precise and efficient solutions.',
                business: 'You are a business-focused AI assistant with expertise in strategy, operations, and decision-making. Provide actionable business insights.',
                custom: customPrompt.value
            };

            if (template.value !== 'custom') {
                customPrompt.value = templates[template.value];
            }
            currentLLMConfig.systemPrompt = customPrompt.value;
        }

        function saveConfiguration() {
            localStorage.setItem('llmConfiguration', JSON.stringify(currentLLMConfig));
            console.log('LLM configuration saved');
        }

        function loadConfiguration() {
            const saved = localStorage.getItem('llmConfiguration');
            if (saved) {
                try {
                    currentLLMConfig = JSON.parse(saved);
                    populateConfigurationForm();
                    updateModelList();
                    console.log('LLM configuration loaded');
                } catch (error) {
                    console.error('Failed to load configuration:', error);
                }
            }
        }

        function exportConfiguration() {
            const configBlob = new Blob([JSON.stringify(currentLLMConfig, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(configBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'llm-configuration.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function resetConfiguration() {
            if (confirm('Are you sure you want to reset all LLM configuration settings?')) {
                resetToDefaults();
                if (currentEngine) {
                    unloadCurrentModel();
                }
            }
        }

        // Provider Model Definitions (based on SimpleLLMService)
        const providerModels = {
            webllm: [
                { id: 'Llama-3.1-8B-Instruct-q4f32_1-MLC', name: 'Llama 3.1 8B Instruct (4-bit)', group: 'Llama Models' },
                { id: 'Llama-3.1-70B-Instruct-q4f16_1-MLC', name: 'Llama 3.1 70B Instruct (4-bit)', group: 'Llama Models' },
                { id: 'Llama-3-8B-Instruct-q4f32_1-MLC', name: 'Llama 3 8B Instruct (4-bit)', group: 'Llama Models' },
                { id: 'Llama-2-7b-chat-hf-q4f32_1-MLC', name: 'Llama 2 7B Chat (4-bit)', group: 'Llama Models' },
                { id: 'Phi-3.5-mini-instruct-q4f16_1-MLC', name: 'Phi 3.5 Mini Instruct (4-bit)', group: 'Phi Models' },
                { id: 'Phi-3-mini-4k-instruct-q4f16_1-MLC', name: 'Phi 3 Mini 4K Instruct (4-bit)', group: 'Phi Models' },
                { id: 'Phi-3-mini-128k-instruct-q4f16_1-MLC', name: 'Phi 3 Mini 128K Instruct (4-bit)', group: 'Phi Models' },
                { id: 'gemma-2-2b-it-q4f16_1-MLC', name: 'Gemma 2 2B Instruct (4-bit)', group: 'Gemma Models' },
                { id: 'gemma-2-9b-it-q4f16_1-MLC', name: 'Gemma 2 9B Instruct (4-bit)', group: 'Gemma Models' },
                { id: 'Qwen2.5-1.5B-Instruct-q4f16_1-MLC', name: 'Qwen 2.5 1.5B Instruct (4-bit)', group: 'Qwen Models' },
                { id: 'Qwen2.5-7B-Instruct-q4f16_1-MLC', name: 'Qwen 2.5 7B Instruct (4-bit)', group: 'Qwen Models' },
                { id: 'Mistral-7B-Instruct-v0.3-q4f16_1-MLC', name: 'Mistral 7B Instruct v0.3 (4-bit)', group: 'Mistral Models' }
            ],
            ollama: [
                { id: 'phi4-mini:latest', name: 'Phi 4 Mini (Latest)', group: 'Phi Models' },
                { id: 'llama3.2:latest', name: 'Llama 3.2 (Latest)', group: 'Llama Models' },
                { id: 'llama3.1:latest', name: 'Llama 3.1 (Latest)', group: 'Llama Models' },
                { id: 'llama3:latest', name: 'Llama 3 (Latest)', group: 'Llama Models' },
                { id: 'llama2:latest', name: 'Llama 2 (Latest)', group: 'Llama Models' },
                { id: 'mistral:latest', name: 'Mistral (Latest)', group: 'Mistral Models' },
                { id: 'codellama:latest', name: 'Code Llama (Latest)', group: 'Code Models' },
                { id: 'gemma2:latest', name: 'Gemma 2 (Latest)', group: 'Gemma Models' },
                { id: 'qwen2.5:latest', name: 'Qwen 2.5 (Latest)', group: 'Qwen Models' },
                { id: 'deepseek-coder:latest', name: 'DeepSeek Coder (Latest)', group: 'Code Models' }
            ],
            openai: [
                { id: 'gpt-4o', name: 'GPT-4o (Most Capable)', group: 'GPT-4 Models' },
                { id: 'gpt-4o-mini', name: 'GPT-4o Mini (Fast & Efficient)', group: 'GPT-4 Models' },
                { id: 'gpt-4-turbo', name: 'GPT-4 Turbo', group: 'GPT-4 Models' },
                { id: 'gpt-4', name: 'GPT-4', group: 'GPT-4 Models' },
                { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo (Cost Effective)', group: 'GPT-3.5 Models' },
                { id: 'gpt-3.5-turbo-16k', name: 'GPT-3.5 Turbo 16K', group: 'GPT-3.5 Models' }
            ],
            github: [
                { id: 'gpt-4o-mini', name: 'GPT-4o Mini (Free)', group: 'OpenAI Models' },
                { id: 'gpt-4o', name: 'GPT-4o', group: 'OpenAI Models' },
                { id: 'Phi-4', name: 'Microsoft Phi-4', group: 'Microsoft Models' },
                { id: 'Phi-3.5-mini-instruct', name: 'Phi-3.5 Mini Instruct', group: 'Microsoft Models' },
                { id: 'Llama-3.2-11B-Vision-Instruct', name: 'Llama 3.2 11B Vision', group: 'Meta Models' },
                { id: 'Llama-3.2-90B-Vision-Instruct', name: 'Llama 3.2 90B Vision', group: 'Meta Models' },
                { id: 'Meta-Llama-3.1-70B-Instruct', name: 'Llama 3.1 70B Instruct', group: 'Meta Models' },
                { id: 'Meta-Llama-3.1-405B-Instruct', name: 'Llama 3.1 405B Instruct', group: 'Meta Models' }
            ],
            gemini: [
                { id: 'gemini-1.5-flash', name: 'Gemini 1.5 Flash (Fast)', group: 'Gemini Models' },
                { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro (Advanced)', group: 'Gemini Models' },
                { id: 'gemini-1.0-pro', name: 'Gemini 1.0 Pro', group: 'Gemini Models' },
                { id: 'gemini-pro', name: 'Gemini Pro', group: 'Gemini Models' }
            ],
            groq: [
                { id: 'llama-3.3-70b-versatile', name: 'Llama 3.3 70B Versatile (Fast)', group: 'Llama Models' },
                { id: 'llama-3.1-70b-versatile', name: 'Llama 3.1 70B Versatile', group: 'Llama Models' },
                { id: 'llama-3.1-8b-instant', name: 'Llama 3.1 8B Instant', group: 'Llama Models' },
                { id: 'mixtral-8x7b-32768', name: 'Mixtral 8x7B', group: 'Mistral Models' },
                { id: 'gemma2-9b-it', name: 'Gemma 2 9B IT', group: 'Gemma Models' },
                { id: 'gemma-7b-it', name: 'Gemma 7B IT', group: 'Gemma Models' }
            ],
            foundry: [
                { id: 'Phi-4-mini-instruct-cuda-gpu', name: 'Phi-4 Mini Instruct (CUDA)', group: 'Foundry Models' },
                { id: 'llama-3.1-8b-instruct', name: 'Llama 3.1 8B Instruct', group: 'Foundry Models' },
                { id: 'mistral-7b-instruct', name: 'Mistral 7B Instruct', group: 'Foundry Models' }
            ],
            huggingface: [
                { id: 'microsoft/DialoGPT-medium', name: 'DialoGPT Medium', group: 'Microsoft Models' },
                { id: 'microsoft/DialoGPT-large', name: 'DialoGPT Large', group: 'Microsoft Models' },
                { id: 'facebook/blenderbot-400M-distill', name: 'BlenderBot 400M', group: 'Facebook Models' },
                { id: 'google/flan-t5-large', name: 'FLAN-T5 Large', group: 'Google Models' },
                { id: 'bigscience/bloom-560m', name: 'BLOOM 560M', group: 'BigScience Models' }
            ]
        };

        async function loadModelsForProvider(provider) {
            const modelSelect = document.getElementById('selectedModel');
            const modelLoading = document.getElementById('modelLoading');
            
            if (!modelSelect) return;

            // Show loading state
            if (modelLoading) modelLoading.classList.remove('hidden');
            modelSelect.disabled = true;

            // Clear existing options
            modelSelect.innerHTML = '<option value="">Loading models...</option>';

            try {
                let models = [];
                
                switch (provider.toLowerCase()) {
                    case 'openai':
                        models = await fetchOpenAIModels();
                        break;
                    case 'ollama':
                        models = await fetchOllamaModels();
                        break;
                    case 'groq':
                        models = await fetchGroqModels();
                        break;
                    case 'github':
                        models = await fetchGitHubModels();
                        break;
                    case 'gemini':
                        models = await fetchGeminiModels();
                        break;
                    case 'huggingface':
                        models = await fetchHuggingFaceModels();
                        break;
                    case 'webllm':
                        models = await fetchWebLLMModels();
                        break;
                    case 'foundry':
                    default:
                        // For foundry and other providers, use fallback
                        models = getFallbackModelsForProvider(provider).map(m => ({...m, isAvailable: false}));
                        break;
                }
                
                // Clear loading message
                modelSelect.innerHTML = '<option value="">Select a model...</option>';
                
                if (!models || models.length === 0) {
                    modelSelect.innerHTML = '<option value="">No models available for this provider</option>';
                    return;
                }

                // Group models by availability
                const availableModels = models.filter(model => model.isAvailable !== false);
                const unavailableModels = models.filter(model => model.isAvailable === false);

                // Add available models first
                if (availableModels.length > 0) {
                    const availableGroup = document.createElement('optgroup');
                    availableGroup.label = `Available Models (${availableModels.length})`;
                    
                    availableModels.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = model.name || model.id;
                        option.title = model.description || '';
                        availableGroup.appendChild(option);
                    });
                    
                    modelSelect.appendChild(availableGroup);
                }

                // Add unavailable models (fallback) if any
                if (unavailableModels.length > 0) {
                    const unavailableGroup = document.createElement('optgroup');
                    unavailableGroup.label = `Fallback Models (${unavailableModels.length})`;
                    
                    unavailableModels.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = `${model.name || model.id} (offline)`;
                        option.title = `${model.description || ''} - This is a fallback model, provider may be offline`;
                        option.style.color = '#888';
                        unavailableGroup.appendChild(option);
                    });
                    
                    modelSelect.appendChild(unavailableGroup);
                }

                // Auto-select first available model
                if (availableModels.length > 0) {
                    modelSelect.value = availableModels[0].id;
                    currentLLMConfig.model = availableModels[0].id;
                } else if (unavailableModels.length > 0) {
                    modelSelect.value = unavailableModels[0].id;
                    currentLLMConfig.model = unavailableModels[0].id;
                }

                console.log(`Loaded ${models.length} models for provider: ${provider} (${availableModels.length} available, ${unavailableModels.length} fallback)`);
            } catch (error) {
                console.error('Error loading models:', error);
                
                // Fallback to hardcoded models if all APIs fail
                const fallbackModels = getFallbackModelsForProvider(provider);
                modelSelect.innerHTML = '<option value="">Select a model...</option>';
                
                if (fallbackModels.length > 0) {
                    const fallbackGroup = document.createElement('optgroup');
                    fallbackGroup.label = 'Cached Models (API offline)';
                    
                    fallbackModels.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = `${model.name} (cached)`;
                        option.title = 'Using cached model list - live models may be unavailable';
                        option.style.color = '#888';
                        fallbackGroup.appendChild(option);
                    });
                    
                    modelSelect.appendChild(fallbackGroup);
                    
                    // Select first fallback model
                    modelSelect.value = fallbackModels[0].id;
                    currentLLMConfig.model = fallbackModels[0].id;
                    
                    console.log(`Using ${fallbackModels.length} fallback models for provider: ${provider}`);
                } else {
                    modelSelect.innerHTML = '<option value="">Error loading models - please try again</option>';
                }
            } finally {
                // Hide loading state
                if (modelLoading) modelLoading.classList.add('hidden');
                modelSelect.disabled = false;
                onModelChange();
            }
        }

        // Provider-specific model fetching functions
        async function fetchOpenAIModels() {
            try {
                const apiKey = document.getElementById('apiKey')?.value;
                if (!apiKey) {
                    throw new Error('OpenAI API key required');
                }
                
                const response = await fetch('https://api.openai.com/v1/models', {
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) throw new Error(`OpenAI API error: ${response.status}`);
                
                const data = await response.json();
                return data.data
                    .filter(model => model.id.startsWith('gpt-') && model.id.includes('gpt'))
                    .map(model => ({
                        id: model.id,
                        name: model.id.replace(/^gpt-/, 'GPT-').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                        isAvailable: true,
                        description: `OpenAI ${model.id}`
                    }));
            } catch (error) {
                console.warn('Failed to fetch OpenAI models:', error);
                return getFallbackModelsForProvider('openai').map(m => ({...m, isAvailable: false}));
            }
        }

        async function fetchOllamaModels() {
            try {
                const response = await fetch('http://localhost:11434/api/tags');
                if (!response.ok) throw new Error(`Ollama API error: ${response.status}`);
                
                const data = await response.json();
                return data.models?.map(model => ({
                    id: model.name,
                    name: model.name.replace(/:latest$/, '').replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                    isAvailable: true,
                    description: `Ollama model: ${model.name} (${(model.size / 1024 / 1024 / 1024).toFixed(1)}GB)`
                })) || [];
            } catch (error) {
                console.warn('Failed to fetch Ollama models:', error);
                return getFallbackModelsForProvider('ollama').map(m => ({...m, isAvailable: false}));
            }
        }

        async function fetchGroqModels() {
            try {
                const apiKey = document.getElementById('apiKey')?.value;
                if (!apiKey) {
                    throw new Error('Groq API key required');
                }
                
                const response = await fetch('https://api.groq.com/openai/v1/models', {
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) throw new Error(`Groq API error: ${response.status}`);
                
                const data = await response.json();
                return data.data?.map(model => ({
                    id: model.id,
                    name: model.id.replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                    isAvailable: true,
                    description: `Groq ${model.id}`
                })) || [];
            } catch (error) {
                console.warn('Failed to fetch Groq models:', error);
                return getFallbackModelsForProvider('groq').map(m => ({...m, isAvailable: false}));
            }
        }

        async function fetchGitHubModels() {
            // GitHub Models API requires special access, use fallback
            console.warn('GitHub Models API requires special access, using fallback models');
            return getFallbackModelsForProvider('github').map(m => ({...m, isAvailable: false}));
        }

        async function fetchGeminiModels() {
            // Gemini doesn't have a public models API, use fallback
            console.warn('Gemini models API not publicly available, using fallback models');
            return getFallbackModelsForProvider('gemini').map(m => ({...m, isAvailable: false}));
        }

        async function fetchHuggingFaceModels() {
            // HuggingFace has too many models, use curated fallback
            console.warn('HuggingFace has thousands of models, using curated fallback models');
            return getFallbackModelsForProvider('huggingface').map(m => ({...m, isAvailable: false}));
        }

        async function fetchWebLLMModels() {
            try {
                // Try to fetch from WebLLM's model registry
                const response = await fetch('https://raw.githubusercontent.com/mlc-ai/web-llm/main/src/config.ts');
                if (response.ok) {
                    const configText = await response.text();
                    // Parse model IDs from the config (this is a simplified approach)
                    const modelMatches = configText.match(/model_id:\s*["']([^"']+)["']/g);
                    if (modelMatches) {
                        const models = modelMatches.map(match => {
                            const id = match.match(/["']([^"']+)["']/)[1];
                            return {
                                id: id,
                                name: id.replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                                isAvailable: true,
                                description: `WebLLM ${id}`
                            };
                        });
                        return models.slice(0, 20); // Limit to first 20 models
                    }
                }
                throw new Error('Failed to parse WebLLM config');
            } catch (error) {
                console.warn('Failed to fetch WebLLM models:', error);
                return getFallbackModelsForProvider('webllm').map(m => ({...m, isAvailable: false}));
            }
        }

        // LLM Integration Helper Functions
        async function callConfiguredLLM(prompt, options = {}) {
            const provider = options.provider || currentLLMConfig.source || 'webllm';
            const model = options.model || currentLLMConfig.model;
            const temperature = options.temperature || currentLLMConfig.temperature || 0.7;
            const maxTokens = options.maxTokens || currentLLMConfig.maxTokens || 500;
            
            console.log(`Calling LLM: ${provider}/${model} for prompt: ${prompt.substring(0, 50)}...`);
            
            switch (provider.toLowerCase()) {
                case 'openai':
                    return await callOpenAI(prompt, model, temperature, maxTokens);
                case 'ollama':
                    return await callOllama(prompt, model, temperature, maxTokens);
                case 'groq':
                    return await callGroq(prompt, model, temperature, maxTokens);
                case 'webllm':
                    return await callWebLLM(prompt, model, temperature, maxTokens);
                default:
                    // Fallback to enhanced mock for other providers
                    return generateContextualContent(prompt, getCreativityFromTemperature(temperature), provider);
            }
        }
        
        async function callOpenAI(prompt, model, temperature, maxTokens) {
            const apiKey = document.getElementById('apiKey')?.value;
            if (!apiKey) throw new Error('OpenAI API key required');
            
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: model || 'gpt-4o-mini',
                    messages: [{ role: 'user', content: prompt }],
                    temperature: temperature,
                    max_tokens: maxTokens
                })
            });
            
            if (!response.ok) throw new Error(`OpenAI API error: ${response.status}`);
            
            const data = await response.json();
            return data.choices[0]?.message?.content || 'No response generated';
        }
        
        async function callOllama(prompt, model, temperature, maxTokens) {
            const response = await fetch('http://localhost:11434/api/generate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: model || 'phi4-mini:latest',
                    prompt: prompt,
                    options: {
                        temperature: temperature,
                        num_predict: maxTokens
                    },
                    stream: false
                })
            });
            
            if (!response.ok) throw new Error(`Ollama API error: ${response.status}`);
            
            const data = await response.json();
            return data.response || 'No response generated';
        }
        
        async function callGroq(prompt, model, temperature, maxTokens) {
            const apiKey = document.getElementById('apiKey')?.value;
            if (!apiKey) throw new Error('Groq API key required');
            
            const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: model || 'llama-3.1-8b-instant',
                    messages: [{ role: 'user', content: prompt }],
                    temperature: temperature,
                    max_tokens: maxTokens
                })
            });
            
            if (!response.ok) throw new Error(`Groq API error: ${response.status}`);
            
            const data = await response.json();
            return data.choices[0]?.message?.content || 'No response generated';
        }
        
        async function callWebLLM(prompt, model, temperature, maxTokens) {
            // WebLLM integration would require the WebLLM library
            // For now, return enhanced contextual content
            console.warn('WebLLM integration requires WebLLM library - using enhanced mock');
            return generateContextualContent(prompt, 'High', 'WebLLM');
        }
        
        function getTemperatureFromCreativity(creativity) {
            switch (creativity?.toLowerCase()) {
                case 'low': return 0.2;
                case 'balanced': return 0.7;
                case 'high': return 0.9;
                default: return 0.7;
            }
        }
        
        function getCreativityFromTemperature(temperature) {
            if (temperature <= 0.3) return 'Low';
            if (temperature <= 0.6) return 'Balanced';
            return 'High';
        }

        function createAnalysisPrompt(data, analysisType) {
            const basePrompt = `Please perform a ${analysisType.toLowerCase()} analysis of the following data:\n\n${data}\n\n`;
            
            switch (analysisType.toUpperCase()) {
                case 'STATISTICAL':
                    return basePrompt + 'Provide statistical insights including:\n- Key metrics and trends\n- Statistical significance\n- Data distribution patterns\n- Outliers and anomalies\n- Correlations if applicable\n\nFormat your response as a structured analysis with clear findings.';
                
                case 'SENTIMENT':
                    return basePrompt + 'Analyze the sentiment and emotional tone:\n- Overall sentiment (positive/negative/neutral)\n- Emotional indicators\n- Confidence level in assessment\n- Key phrases that indicate sentiment\n- Suggestions for response or action\n\nProvide a clear sentiment score and reasoning.';
                
                case 'TREND':
                    return basePrompt + 'Identify patterns and trends:\n- Upward/downward trends\n- Cyclical patterns\n- Rate of change\n- Forecasting implications\n- Trend strength and reliability\n\nInclude actionable insights based on trend analysis.';
                
                case 'SEMANTIC':
                    return basePrompt + 'Perform semantic analysis:\n- Key concepts and themes\n- Meaning and context\n- Relationships between concepts\n- Intent and purpose\n- Semantic categories\n\nProvide structured semantic insights.';
                
                case 'COMPARATIVE':
                    return basePrompt + 'Compare and contrast elements:\n- Similarities and differences\n- Relative strengths and weaknesses\n- Performance comparisons\n- Ranking or prioritization\n- Recommendations based on comparison\n\nStructure the comparison clearly.';
                
                default:
                    return basePrompt + `Provide a comprehensive ${analysisType.toLowerCase()} analysis with:\n- Key findings and insights\n- Supporting evidence\n- Patterns or anomalies\n- Implications and recommendations\n- Confidence level in analysis\n\nStructure your analysis clearly with actionable conclusions.`;
            }
        }

        function createDesignPrompt(template, designType) {
            const basePrompt = `Create a ${designType.toLowerCase()} design based on the following template/requirements:\n\n${template}\n\n`;
            
            switch (designType.toUpperCase()) {
                case 'UI':
                case 'USER_INTERFACE':
                    return basePrompt + 'Generate a user interface design including:\n- Layout structure and components\n- User experience considerations\n- Visual hierarchy and styling\n- Interactive elements and navigation\n- Accessibility considerations\n- Responsive design principles\n\nProvide detailed UI specifications and design rationale.';
                
                case 'API':
                    return basePrompt + 'Design an API specification including:\n- Endpoint definitions and HTTP methods\n- Request/response schemas\n- Authentication and authorization\n- Error handling and status codes\n- Rate limiting and versioning\n- Documentation and examples\n\nProvide a complete API design specification.';
                
                case 'DATABASE':
                case 'SCHEMA':
                    return basePrompt + 'Design a database schema including:\n- Table structures and relationships\n- Primary and foreign keys\n- Indexes and constraints\n- Data types and validation rules\n- Normalization considerations\n- Performance optimizations\n\nProvide SQL DDL statements and schema documentation.';
                
                case 'ARCHITECTURE':
                case 'SYSTEM':
                    return basePrompt + 'Design a system architecture including:\n- Component breakdown and responsibilities\n- Service interactions and dependencies\n- Data flow and communication patterns\n- Scalability and performance considerations\n- Security and reliability measures\n- Deployment and infrastructure requirements\n\nProvide architectural diagrams and documentation.';
                
                case 'WORKFLOW':
                case 'PROCESS':
                    return basePrompt + 'Design a workflow/process including:\n- Step-by-step procedures\n- Decision points and branches\n- Roles and responsibilities\n- Input/output requirements\n- Error handling and exceptions\n- Performance metrics and KPIs\n\nProvide a structured workflow specification.';
                
                default:
                    return basePrompt + `Generate a comprehensive ${designType.toLowerCase()} design with:\n- Clear specifications and requirements\n- Implementation guidelines\n- Best practices and standards\n- Potential challenges and solutions\n- Testing and validation approaches\n\nProvide detailed design documentation with practical examples.`;
            }
        }

        function getFallbackModelsForProvider(provider) {
            // Minimal fallback models for when API is unavailable
            const fallbackModels = {
                webllm: [
                    { id: 'Phi-3.5-mini-instruct-q4f16_1-MLC', name: 'Phi 3.5 Mini Instruct (4-bit)' },
                    { id: 'Llama-3.2-3B-Instruct-q4f16_1-MLC', name: 'Llama 3.2 3B Instruct (4-bit)' }
                ],
                ollama: [
                    { id: 'phi4-mini:latest', name: 'Phi 4 Mini (Latest)' },
                    { id: 'llama3.2:latest', name: 'Llama 3.2 (Latest)' }
                ],
                openai: [
                    { id: 'gpt-4o-mini', name: 'GPT-4o Mini' },
                    { id: 'gpt-4o', name: 'GPT-4o' }
                ],
                github: [
                    { id: 'gpt-4o-mini', name: 'GPT-4o Mini (Free)' },
                    { id: 'meta-llama-3.1-8b-instruct', name: 'Llama 3.1 8B Instruct (Free)' }
                ],
                gemini: [
                    { id: 'gemini-1.5-flash', name: 'Gemini 1.5 Flash (Fast)' },
                    { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro' }
                ],
                groq: [
                    { id: 'llama-3.1-8b-instant', name: 'Llama 3.1 8B Instant' },
                    { id: 'mixtral-8x7b-32768', name: 'Mixtral 8x7B' }
                ],
                foundry: [
                    { id: 'phi4-mini:latest', name: 'Phi 4 Mini' }
                ],
                huggingface: [
                    { id: 'microsoft/DialoGPT-medium', name: 'DialoGPT Medium' }
                ]
            };
            
            return fallbackModels[provider] || [];
        }

        function getDefaultModelForProvider(provider) {
            const defaults = {
                webllm: 'Phi-3.5-mini-instruct-q4f16_1-MLC',
                ollama: 'phi4-mini:latest',
                openai: 'gpt-4o-mini',
                github: 'gpt-4o-mini',
                gemini: 'gemini-1.5-flash',
                groq: 'llama-3.3-70b-versatile',
                foundry: 'Phi-4-mini-instruct-cuda-gpu',
                huggingface: 'microsoft/DialoGPT-medium'
            };
            return defaults[provider] || '';
        }

        function saveProviderConfig() {
            const provider = document.getElementById('modelSource')?.value;
            if (!provider) return;

            const config = {
                apiKey: document.getElementById('apiKey')?.value || '',
                orgId: document.getElementById('orgId')?.value || '',
                endpoint: document.getElementById('customEndpoint')?.value || ''
            };

            // Save to localStorage with provider-specific key
            localStorage.setItem(`llm_provider_${provider}`, JSON.stringify(config));
            
            // Also save the complete current LLM configuration
            const fullConfig = {
                ...currentLLMConfig,
                provider: provider,
                apiKey: config.apiKey,
                orgId: config.orgId,
                endpoint: config.endpoint
            };
            
            localStorage.setItem('llm_current_config', JSON.stringify(fullConfig));
            console.log(`Saved complete configuration for provider: ${provider}`);
        }

        function loadSavedLLMConfig() {
            try {
                const savedConfig = localStorage.getItem('llm_current_config');
                if (savedConfig) {
                    const config = JSON.parse(savedConfig);
                    
                    // Restore LLM configuration
                    Object.assign(currentLLMConfig, config);
                    
                    // Restore UI elements
                    const modelSource = document.getElementById('modelSource');
                    const selectedModel = document.getElementById('selectedModel');
                    const apiKey = document.getElementById('apiKey');
                    const orgId = document.getElementById('orgId');
                    const endpoint = document.getElementById('customEndpoint');
                    
                    if (modelSource && config.provider) modelSource.value = config.provider;
                    if (selectedModel && config.model) selectedModel.value = config.model;
                    if (apiKey && config.apiKey) apiKey.value = config.apiKey;
                    if (orgId && config.orgId) orgId.value = config.orgId;
                    if (endpoint && config.endpoint) endpoint.value = config.endpoint;
                    
                    console.log('Restored LLM configuration:', config.provider, config.model);
                }
            } catch (error) {
                console.warn('Failed to load saved LLM config:', error);
            }
        }

        function loadProviderConfig(provider) {
            const saved = localStorage.getItem(`llm_provider_${provider}`);
            if (!saved) return;

            try {
                const config = JSON.parse(saved);
                
                const apiKeyInput = document.getElementById('apiKey');
                const orgIdInput = document.getElementById('orgId');
                const endpointInput = document.getElementById('customEndpoint');

                if (apiKeyInput) apiKeyInput.value = config.apiKey || '';
                if (orgIdInput) orgIdInput.value = config.orgId || '';
                if (endpointInput) endpointInput.value = config.endpoint || '';

                console.log(`Loaded configuration for provider: ${provider}`);
            } catch (error) {
                console.error('Error loading provider configuration:', error);
            }
        }

        function getProviderConfiguration() {
            const provider = document.getElementById('modelSource')?.value;
            const model = document.getElementById('selectedModel')?.value;
            const apiKey = document.getElementById('apiKey')?.value;
            const orgId = document.getElementById('orgId')?.value;
            const endpoint = document.getElementById('customEndpoint')?.value;

            return {
                provider,
                model,
                apiKey,
                orgId,
                endpoint,
                temperature: currentLLMConfig.temperature,
                maxTokens: currentLLMConfig.maxTokens,
                topP: currentLLMConfig.topP,
                frequencyPenalty: currentLLMConfig.frequencyPenalty,
                presencePenalty: currentLLMConfig.presencePenalty,
                systemPrompt: currentLLMConfig.systemPrompt
            };
        }

        function generateContextualContent(prompt, creativity, provider) {
            // Generate contextual content based on prompt and provider
            const promptLower = prompt.toLowerCase();
            let content = '';
            
            if (promptLower.includes('code') || promptLower.includes('function') || promptLower.includes('class')) {
                content = `Here's a comprehensive code solution based on your request:

\`\`\`javascript
function generateSolution(requirements) {
    // Implementation details would be generated by ${provider}
    const solution = {
        approach: 'intelligent analysis',
        implementation: 'optimized for performance',
        testing: 'comprehensive coverage'
    };
    return solution;
}
\`\`\`

This solution incorporates best practices and follows modern development patterns.`;
            } else if (promptLower.includes('plan') || promptLower.includes('strategy') || promptLower.includes('approach')) {
                content = `Strategic Analysis and Implementation Plan:

1. **Assessment Phase**
   - Analyze current requirements and constraints
   - Identify key stakeholders and objectives
   - Evaluate available resources and timeline

2. **Planning Phase**
   - Define clear milestones and deliverables
   - Establish success metrics and KPIs
   - Create detailed implementation roadmap

3. **Execution Phase**
   - Implement solution with iterative approach
   - Monitor progress and adjust as needed
   - Ensure quality and compliance standards

This comprehensive approach ensures successful project delivery.`;
            } else if (promptLower.includes('data') || promptLower.includes('analysis') || promptLower.includes('metrics')) {
                content = `Data Analysis and Insights:

**Key Findings:**
- Performance metrics indicate optimal efficiency
- User engagement shows positive trends
- System reliability maintains 99.9% uptime

**Recommendations:**
- Implement additional monitoring capabilities
- Optimize data processing workflows
- Enhance user experience based on feedback

**Next Steps:**
- Deploy advanced analytics dashboards
- Establish automated reporting systems
- Create predictive modeling capabilities`;
            } else {
                content = `Based on your request, here's a thoughtful analysis:

The topic you've raised is multifaceted and requires careful consideration of various factors. Key aspects to address include:

‚Ä¢ Understanding the core requirements and objectives
‚Ä¢ Evaluating potential solutions and their trade-offs
‚Ä¢ Considering implementation challenges and opportunities
‚Ä¢ Planning for scalability and future enhancements

This approach ensures a comprehensive solution that meets both immediate needs and long-term goals. The ${provider} model provides intelligent insights and recommendations tailored to your specific context.`;
            }
            
            // Adjust creativity level
            if (creativity === 'Creative') {
                content += `

üé® **Creative Enhancement**: This solution incorporates innovative approaches and out-of-the-box thinking to deliver exceptional results that exceed expectations.`;
            } else if (creativity === 'Focused') {
                content += `

üéØ **Focused Approach**: This solution prioritizes efficiency and precision, delivering direct answers with minimal complexity.`;
            }
            
            return content;
        }

        // Update the test function to use provider configuration
        async function testProviderConfiguration() {
            const config = getProviderConfiguration();
            const testPrompt = document.getElementById('testPrompt')?.value;
            const responseBox = document.getElementById('testResponse');

            if (!config.provider || !config.model || !testPrompt?.trim()) {
                if (responseBox) responseBox.innerHTML = '<p style="color: var(--error);">Please select a provider, model, and enter a test prompt.</p>';
                return;
            }

            if (config.provider !== 'webllm' && config.provider !== 'ollama' && config.provider !== 'foundry' && !config.apiKey) {
                if (responseBox) responseBox.innerHTML = '<p style="color: var(--error);">API key is required for this provider.</p>';
                return;
            }

            const startTime = Date.now();
            if (responseBox) responseBox.innerHTML = '<p class="text-muted">Testing configuration...</p>';

            try {
                // For WebLLM, use the existing engine if available
                if (config.provider === 'webllm' && currentEngine) {
                    return await testLLMConfiguration();
                }

                // For other providers, simulate a test (in real implementation, this would make actual API calls)
                await new Promise(resolve => setTimeout(resolve, 1000));

                const endTime = Date.now();
                const responseTime = (endTime - startTime) / 1000;

                const testResponse = `Test successful! Configuration for ${config.provider} with model ${config.model} is working.\n\nProvider: ${config.provider}\nModel: ${config.model}\nEndpoint: ${config.endpoint || 'Default'}\nAPI Key: ${config.apiKey ? '***' + config.apiKey.slice(-4) : 'Not required'}\n\nThis is a simulated response. In a real implementation, this would make an actual API call to test the configuration.`;

                if (responseBox) responseBox.innerHTML = `<pre>${testResponse}</pre>`;

                // Update performance metrics
                const responseTimeEl = document.getElementById('responseTime');
                const tokensPerSecondEl = document.getElementById('tokensPerSecond');
                const totalTokensEl = document.getElementById('totalTokens');

                if (responseTimeEl) responseTimeEl.textContent = `${responseTime.toFixed(2)}s`;
                if (tokensPerSecondEl) tokensPerSecondEl.textContent = '~50';
                if (totalTokensEl) totalTokensEl.textContent = '~75';

            } catch (error) {
                if (responseBox) responseBox.innerHTML = `<p style="color: var(--error);">Test failed: ${error.message}</p>`;
                console.error('Provider test failed:', error);
            }
        }



        
        // Visual Designer Core
        let visualDesignerState = {
            currentAgent: null,
            nodes: new Map(),
            connections: [],
            selectedNode: null,
            draggedNode: null,
            connecting: null,
            nodeCounter: 1,
            canvasOffset: { x: 0, y: 0 },
            canvasScale: 1,
            isPanning: false,
            lastPanPoint: { x: 0, y: 0 }
        };

        // DSL Statement Templates - Complete RULES.xml Implementation
        const statementTemplates = {
            declare: {
                type: 'DECLARE',
                icon: 'create',
                color: '#3b82f6',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable name' },
                    { name: 'Type', type: 'select', options: ['AUTO', 'UNIQ', 'STRING', 'COLOR', 'EMAIL', 'PASSWORD', 'TEL', 'IMAGE', 'INTEGER', 'DOUBLE', 'FLOAT', 'BOOL', 'ENUM', 'ENUMSTR', 'DATE', 'DATETIME', 'WEEK', 'TIME', 'URL', 'ONE', 'MANY', 'PARENTKEY', 'KEYS', 'NEXTKEY', 'CSV', 'FILE', 'FOLDER'], help: 'Variable type from RULES.xml' },
                    { name: 'ForeignType', type: 'text', help: 'Reference to external type' },
                    { name: 'Expression', type: 'text', help: 'Initial value expression' }
                ]
            },
            prop: {
                type: 'PROP',
                icon: 'input',
                color: '#8b5cf6',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Property name' },
                    { name: 'Type', type: 'select', options: ['STRING', 'INTEGER', 'DOUBLE', 'BOOL'], help: 'Property type' }
                ]
            },
            assign: {
                type: 'ASSIGN',
                icon: 'assignment',
                color: '#10b981',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to assign' },
                    { name: 'Template', type: 'textarea', required: true, help: 'Value template with #variable# interpolation' }
                ]
            },
            in: {
                type: 'IN',
                icon: 'input',
                color: '#ec4899',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store input' },
                    { name: 'Label', type: 'text', required: true, help: 'Prompt for user' },
                    { name: 'Type', type: 'select', options: ['TEXT', 'TEXTAREA', 'CHOICE'], help: 'Input type' },
                    { name: 'Preset', type: 'text', help: 'Default value' }
                ]
            },
            out: {
                type: 'OUT',
                icon: 'message',
                color: '#f59e0b',
                properties: [
                    { name: 'Template', type: 'textarea', required: true, help: 'Output message with #variable# interpolation' }
                ]
            },
            choice: {
                type: 'CHOICE',
                icon: 'radio_button_checked',
                color: '#06b6d4',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Choice identifier' },
                    { name: 'Options', type: 'textarea', help: 'Choice options (one per line)' }
                ]
            },
            if: {
                type: 'IF',
                icon: 'call_split',
                color: '#f97316',
                hasElse: true,
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to check' },
                    { name: 'ConditionType', type: 'select', options: ['Equal', 'NotEqual', 'GreaterThan', 'LessThan'], help: 'Comparison type' },
                    { name: 'Template', type: 'text', required: true, help: 'Value to compare against' }
                ]
            },
            while: {
                type: 'WHILE',
                icon: 'loop',
                color: '#7c3aed',
                hasBody: true,
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to check' },
                    { name: 'ConditionType', type: 'select', options: ['Equal', 'NotEqual', 'GreaterThan', 'LessThan'], help: 'Comparison type' },
                    { name: 'Template', type: 'text', required: true, help: 'Value to compare against' }
                ]
            },
            switch: {
                type: 'SWITCH',
                icon: 'alt_route',
                color: '#e11d48',
                hasMultipleCases: true,
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to switch on' }
                ]
            },
            case: {
                type: 'CASE',
                icon: 'arrow_forward',
                color: '#0ea5e9',
                parentType: 'switch',
                properties: [
                    { name: 'Template', type: 'text', required: true, help: 'Case value to match' }
                ]
            },
            call: {
                type: 'CALL',
                icon: 'call',
                color: '#dc2626',
                properties: [
                    { name: 'Key', type: 'text', help: 'Variable to store result' },
                    { name: 'ToKey', type: 'text', required: true, help: 'Target agent key' },
                    { name: 'Variables', type: 'text', help: 'Variables to pass (comma-separated)' }
                ]
            },
            return: {
                type: 'RETURN',
                icon: 'keyboard_return',
                color: '#059669',
                properties: [
                    { name: 'Type', type: 'select', options: ['STRING', 'INTEGER', 'DOUBLE', 'BOOL'], help: 'Return type' },
                    { name: 'Template', type: 'textarea', required: true, help: 'Return value template' }
                ]
            },
            prompt: {
                type: 'PROMPT',
                icon: 'chat',
                color: '#7c2d12',
                hasChildren: true,
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Prompt identifier' }
                ]
            },
            generate: {
                type: 'GENERATE',
                icon: 'auto_awesome',
                color: '#be185d',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store result' },
                    { name: 'Keys', type: 'text', help: 'Prompt keys to use' },
                    { name: 'MaxTokens', type: 'number', help: 'Maximum tokens to generate' },
                    { name: 'Creativity', type: 'select', options: ['Focused', 'Balanced', 'Creative'], help: 'Generation creativity level' }
                ]
            },
            read: {
                type: 'READ',
                icon: 'file_open',
                color: '#1f2937',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store content' },
                    { name: 'FileKey', type: 'text', required: true, help: 'File identifier to read' }
                ]
            },
            write: {
                type: 'WRITE',
                icon: 'save',
                color: '#374151',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Content to write (variable names)' },
                    { name: 'FileKey', type: 'text', required: true, help: 'File identifier to write to' }
                ]
            },
            // Additional RULES.xml Statement Types
            design: {
                type: 'DESIGN',
                icon: 'design_services',
                color: '#8b5cf6',
                properties: [
                    { name: 'Type', type: 'select', options: ['UI', 'API', 'ARCHITECTURE', 'DATABASE'], help: 'Design type' },
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store design' },
                    { name: 'Template', type: 'textarea', required: true, help: 'Design requirements' }
                ]
            },
            fetch: {
                type: 'FETCH',
                icon: 'download',
                color: '#06b6d4',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store response' },
                    { name: 'Url', type: 'text', required: true, help: 'URL to fetch' },
                    { name: 'Method', type: 'select', options: ['GET', 'POST', 'PUT', 'DELETE'], help: 'HTTP method' },
                    { name: 'Headers', type: 'text', help: 'Request headers (JSON)' },
                    { name: 'Body', type: 'text', help: 'Request body' }
                ]
            },
            sql: {
                type: 'SQL',
                icon: 'storage',
                color: '#f59e0b',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store results' },
                    { name: 'Connection', type: 'text', help: 'Database connection string' },
                    { name: 'Query', type: 'textarea', required: true, help: 'SQL query' },
                    { name: 'Parameters', type: 'text', help: 'Query parameters (JSON)' }
                ]
            },
            analyze: {
                type: 'ANALYZE',
                icon: 'analytics',
                color: '#10b981',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store analysis' },
                    { name: 'Data', type: 'text', required: true, help: 'Data to analyze' },
                    { name: 'Type', type: 'select', options: ['STATISTICAL', 'PATTERN', 'SENTIMENT', 'TREND'], help: 'Analysis type' },
                    { name: 'Criteria', type: 'text', help: 'Analysis criteria' }
                ]
            },
            sense: {
                type: 'SENSE',
                icon: 'sensors',
                color: '#f97316',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store sensed data' },
                    { name: 'Source', type: 'select', options: ['CAMERA', 'MICROPHONE', 'SENSOR', 'FILE', 'STREAM'], help: 'Data source' },
                    { name: 'Duration', type: 'text', help: 'Sensing duration' },
                    { name: 'Filter', type: 'text', help: 'Data filter criteria' }
                ]
            },
            actuate: {
                type: 'ACTUATE',
                icon: 'settings_remote',
                color: '#dc2626',
                properties: [
                    { name: 'Device', type: 'text', required: true, help: 'Target device/actuator' },
                    { name: 'Action', type: 'text', required: true, help: 'Action to perform' },
                    { name: 'Parameters', type: 'text', help: 'Action parameters' },
                    { name: 'Timeout', type: 'text', help: 'Action timeout' }
                ]
            },
            injest: {
                type: 'INJEST',
                icon: 'cloud_upload',
                color: '#7c3aed',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store processed data' },
                    { name: 'Source', type: 'text', required: true, help: 'Data source' },
                    { name: 'Format', type: 'select', options: ['JSON', 'XML', 'CSV', 'TEXT', 'BINARY'], help: 'Data format' },
                    { name: 'Transform', type: 'text', help: 'Data transformation rules' }
                ]
            },
            foreach: {
                type: 'FOREACH',
                icon: 'repeat',
                color: '#059669',
                hasChildren: true,
                properties: [
                    { name: 'Variable', type: 'text', required: true, help: 'Iterator variable' },
                    { name: 'Collection', type: 'text', required: true, help: 'Collection to iterate' }
                ]
            },
            for: {
                type: 'FOR',
                icon: 'loop',
                color: '#0d9488',
                hasChildren: true,
                properties: [
                    { name: 'Variable', type: 'text', required: true, help: 'Loop variable' },
                    { name: 'Start', type: 'text', required: true, help: 'Start value' },
                    { name: 'End', type: 'text', required: true, help: 'End value' },
                    { name: 'Step', type: 'text', help: 'Step increment (default: 1)' }
                ]
            },
            do: {
                type: 'DO',
                icon: 'play_circle',
                color: '#1d4ed8',
                hasChildren: true,
                properties: []
            },
            elseif: {
                type: 'ELSEIF',
                icon: 'alt_route',
                color: '#7c2d12',
                hasChildren: true,
                properties: [
                    { name: 'Condition', type: 'text', required: true, help: 'Boolean condition' }
                ]
            },
            default: {
                type: 'DEFAULT',
                icon: 'rule',
                color: '#6b7280',
                hasChildren: true,
                properties: []
            },
            else: {
                type: 'ELSE',
                icon: 'alt_route',
                color: '#78716c',
                hasChildren: true,
                properties: []
            },
            break: {
                type: 'BREAK',
                icon: 'stop',
                color: '#dc2626',
                properties: []
            },
            continue: {
                type: 'CONTINUE',
                icon: 'skip_next',
                color: '#059669',
                properties: []
            }
        };

        // Initialize Visual Designer for an Agent
        function initializeVisualDesigner(agentKey) {
            visualDesignerState.currentAgent = agentKey;
            visualDesignerState.nodes.clear();
            visualDesignerState.connections = [];
            visualDesignerState.selectedNode = null;
            
            setupPaletteDragDrop();
            setupCanvasInteraction();
            setupInspectorHandlers();
            
            // Load pre-created nodes for this agent
            if (agentNodes.has(agentKey)) {
                const agentSpecificNodes = agentNodes.get(agentKey);
                visualDesignerState.nodes = new Map(agentSpecificNodes);
                
                // Render the nodes on canvas
                renderVisualNodes();
                
                console.log(`üé® Loaded ${agentSpecificNodes.size} pre-built nodes for ${agentKey}`);
            } else {
                // Load existing statements if any (fallback)
                const agent = currentPlan.agents.get(agentKey);
                if (agent && agent.statements) {
                    loadStatementsAsNodes(agent.statements);
                }
            }
            
            console.log(`üé® Visual Designer initialized for agent: ${agentKey}`);
        }
        
        // Render visual nodes on the canvas
        function renderVisualNodes() {
            const canvas = document.getElementById('statementCanvas');
            if (!canvas) return;
            
            // Clear existing nodes
            canvas.innerHTML = '';
            
            // Render each node
            visualDesignerState.nodes.forEach((nodeData, nodeId) => {
                const nodeElement = createStatementNode(
                    nodeData.template.type,
                    nodeData.position.x,
                    nodeData.position.y,
                    nodeData.data
                );
                
                if (nodeElement) {
                    nodeElement.id = nodeId;
                    canvas.appendChild(nodeElement);
                }
            });
            
            console.log(`‚úÖ Rendered ${visualDesignerState.nodes.size} nodes on canvas`);
        }

        // Setup Palette Drag & Drop
        function setupPaletteDragDrop() {
            const paletteItems = document.querySelectorAll('.palette-item');
            
            paletteItems.forEach(item => {
                item.addEventListener('mousedown', startPaletteDrag);
                item.addEventListener('dragstart', e => e.preventDefault());
            });
        }

        function startPaletteDrag(e) {
            const item = e.currentTarget;
            const type = item.dataset.type;
            const template = statementTemplates[type];
            
            if (!template) return;
            
            // Create preview element
            const preview = item.cloneNode(true);
            preview.style.position = 'fixed';
            preview.style.pointerEvents = 'none';
            preview.style.zIndex = '10000';
            preview.style.opacity = '0.8';
            preview.style.transform = 'rotate(2deg)';
            document.body.appendChild(preview);
            
            const moveHandler = (e) => {
                preview.style.left = `${e.clientX - 60}px`;
                preview.style.top = `${e.clientY - 20}px`;
            };
            
            const dropHandler = (e) => {
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', dropHandler);
                document.body.removeChild(preview);
                
                // Check if dropped on canvas
                const canvas = document.getElementById('statementCanvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                if (e.clientX >= canvasRect.left && e.clientX <= canvasRect.right &&
                    e.clientY >= canvasRect.top && e.clientY <= canvasRect.bottom) {
                    
                    const x = e.clientX - canvasRect.left;
                    const y = e.clientY - canvasRect.top;
                    
                    createStatementNode(type, x, y);
                }
            };
            
            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', dropHandler);
            
            moveHandler(e);
        }

        // Create Statement Node
        function createStatementNode(type, x, y, data = {}) {
            const template = statementTemplates[type];
            if (!template) return null;
            
            const nodeId = `node_${visualDesignerState.nodeCounter++}`;
            const canvas = document.getElementById('statementCanvas');
            
            const nodeElement = document.createElement('div');
            nodeElement.className = 'statement-node';
            nodeElement.id = nodeId;
            nodeElement.style.left = `${x}px`;
            nodeElement.style.top = `${y}px`;
            
            // Create node summary from data
            const summary = createNodeSummary(template, data);
            
            nodeElement.innerHTML = `
                <div class="node-header">
                    <div class="node-type">
                        <i class="material-icons" style="color: ${template.color}">${template.icon}</i>
                        <span>${template.type}</span>
                    </div>
                    <div class="node-actions">
                        <button class="node-action" onclick="deleteStatementNode('${nodeId}')">
                            <i class="material-icons">delete</i>
                        </button>
                    </div>
                </div>
                <div class="node-body">
                    ${data.Key ? `<div class="node-key">${data.Key}</div>` : ''}
                    <div class="node-summary">${summary}</div>
                </div>
                <div class="connection-point input"></div>
                <div class="connection-point output"></div>
            `;
            
            // Store node data
            const nodeData = {
                id: nodeId,
                type: type,
                template: template,
                x: x,
                y: y,
                data: { ...data },
                element: nodeElement
            };
            
            visualDesignerState.nodes.set(nodeId, nodeData);
            
            // Setup node interactions
            setupNodeInteractions(nodeElement, nodeData);
            
            canvas.appendChild(nodeElement);
            
            // Auto-select new node
            selectStatementNode(nodeId);
            
            console.log(`‚ûï Created ${template.type} node:`, nodeId);
            return nodeElement;
        }

        // Create Node Summary Text
        function createNodeSummary(template, data) {
            const summaries = {
                'DECLARE': () => `${data.Key || 'Variable'}: ${data.Type || 'STRING'}${data.Expression ? ` = ${data.Expression}` : ''}`,
                'PROP': () => `${data.Key || 'Property'}: ${data.Type || 'STRING'}`,
                'ASSIGN': () => `${data.Key || 'Variable'} = ${(data.Template || 'Value').substring(0, 30)}${data.Template?.length > 30 ? '...' : ''}`,
                'IN': () => `Input: ${data.Label || 'User input'} ‚Üí ${data.Key || 'Variable'}`,
                'OUT': () => `Output: ${(data.Template || 'Message').substring(0, 40)}${data.Template?.length > 40 ? '...' : ''}`,
                'CHOICE': () => `Choice: ${data.Key || 'Selection'}`,
                'IF': () => `If ${data.Key || 'Variable'} ${data.ConditionType || 'Equal'} ${data.Template || 'Value'}`,
                'WHILE': () => `While ${data.Key || 'Variable'} ${data.ConditionType || 'Equal'} ${data.Template || 'Value'}`,
                'SWITCH': () => `Switch on ${data.Key || 'Variable'}`,
                'CASE': () => `Case: ${data.Template || 'Value'}`,
                'CALL': () => `Call ${data.ToKey || 'Agent'}${data.Key ? ` ‚Üí ${data.Key}` : ''}`,
                'RETURN': () => `Return ${data.Type || 'STRING'}: ${(data.Template || 'Value').substring(0, 30)}`,
                'PROMPT': () => `Prompt: ${data.Key || 'Identifier'}`,
                'GENERATE': () => `Generate ‚Üí ${data.Key || 'Variable'} (${data.MaxTokens || 500} tokens)`,
                'READ': () => `Read ${data.FileKey || 'File'} ‚Üí ${data.Key || 'Variable'}`,
                'WRITE': () => `Write ${data.Key || 'Data'} ‚Üí ${data.FileKey || 'File'}`
            };
            
            const summaryFn = summaries[template.type];
            return summaryFn ? summaryFn() : `${template.type} statement`;
        }

        // Setup Node Interactions
        function setupNodeInteractions(element, nodeData) {
            // Node selection and dragging
            element.addEventListener('mousedown', (e) => {
                if (e.target.closest('.node-action') || e.target.closest('.connection-point')) return;
                
                selectStatementNode(nodeData.id);
                
                visualDesignerState.draggedNode = nodeData;
                const rect = element.getBoundingClientRect();
                const canvasRect = document.getElementById('statementCanvas').getBoundingClientRect();
                
                visualDesignerState.draggedNode.dragOffset = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                
                e.preventDefault();
            });
            
            // Connection points
            const inputPoint = element.querySelector('.connection-point.input');
            const outputPoint = element.querySelector('.connection-point.output');
            
            if (outputPoint) {
                outputPoint.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    startConnection(nodeData, 'output');
                });
            }
            
            if (inputPoint) {
                inputPoint.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    startConnection(nodeData, 'input');
                });
            }
        }

        // Select Statement Node
        function selectStatementNode(nodeId) {
            visualDesignerState.selectedNode = nodeId;
            
            // Update visual selection
            document.querySelectorAll('.statement-node').forEach(node => {
                node.classList.remove('selected');
            });
            
            const nodeElement = document.getElementById(nodeId);
            if (nodeElement) {
                nodeElement.classList.add('selected');
            }
            
            // Update inspector
            updateInspector();
        }

        // Update Inspector Panel
        function updateInspector() {
            const inspectorContent = document.getElementById('inspectorContent');
            const agentVariables = document.getElementById('agentVariables');
            
            if (!visualDesignerState.selectedNode) {
                inspectorContent.innerHTML = '<div class="inspector-empty">Select a statement to edit properties</div>';
                return;
            }
            
            const nodeData = visualDesignerState.nodes.get(visualDesignerState.selectedNode);
            if (!nodeData) return;
            
            const template = nodeData.template;
            
            // Create property form
            let formHtml = `<div class="property-form">`;
            
            template.properties.forEach(prop => {
                const value = nodeData.data[prop.name] || '';
                const inputId = `prop_${prop.name}`;
                
                formHtml += `
                    <div class="property-group">
                        <label class="property-label" for="${inputId}">
                            ${prop.name}${prop.required ? ' *' : ''}
                        </label>
                `;
                
                switch(prop.type) {
                    case 'textarea':
                        formHtml += `<textarea class="property-textarea" id="${inputId}" data-prop="${prop.name}">${value}</textarea>`;
                        break;
                    case 'select':
                        formHtml += `<select class="property-select" id="${inputId}" data-prop="${prop.name}">`;
                        formHtml += `<option value="">-- Select --</option>`;
                        prop.options.forEach(opt => {
                            formHtml += `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`;
                        });
                        formHtml += `</select>`;
                        break;
                    case 'number':
                        formHtml += `<input type="number" class="property-input" id="${inputId}" data-prop="${prop.name}" value="${value}">`;
                        break;
                    default:
                        formHtml += `<input type="text" class="property-input" id="${inputId}" data-prop="${prop.name}" value="${value}">`;
                }
                
                if (prop.help) {
                    formHtml += `<div class="property-help">${prop.help}</div>`;
                }
                
                formHtml += `</div>`;
            });
            
            formHtml += `</div>`;
            
            inspectorContent.innerHTML = formHtml;
            
            // Setup property change handlers
            setupPropertyHandlers();
            
            // Update variables list
            updateVariablesList();
        }

        // Setup Property Change Handlers
        function setupPropertyHandlers() {
            const propertyInputs = document.querySelectorAll('.property-input, .property-textarea, .property-select');
            
            propertyInputs.forEach(input => {
                input.addEventListener('input', () => {
                    const propName = input.dataset.prop;
                    const nodeData = visualDesignerState.nodes.get(visualDesignerState.selectedNode);
                    
                    if (nodeData) {
                        nodeData.data[propName] = input.value;
                        updateNodeSummary(nodeData);
                    }
                });
            });
        }

        // Update Node Summary
        function updateNodeSummary(nodeData) {
            const summary = createNodeSummary(nodeData.template, nodeData.data);
            const summaryElement = nodeData.element.querySelector('.node-summary');
            const keyElement = nodeData.element.querySelector('.node-key');
            
            if (summaryElement) {
                summaryElement.textContent = summary;
            }
            
            // Update key display
            if (nodeData.data.Key) {
                if (keyElement) {
                    keyElement.textContent = nodeData.data.Key;
                } else {
                    const nodeBody = nodeData.element.querySelector('.node-body');
                    nodeBody.insertAdjacentHTML('afterbegin', `<div class="node-key">${nodeData.data.Key}</div>`);
                }
            } else if (keyElement) {
                keyElement.remove();
            }
        }

        // Update Variables List
        function updateVariablesList() {
            const agentVariables = document.getElementById('agentVariables');
            const variables = extractVariablesFromNodes();
            
            if (variables.length === 0) {
                agentVariables.innerHTML = '<div style="color: var(--text-muted); font-style: italic; text-align: center; padding: 20px;">No variables declared</div>';
                return;
            }
            
            let variablesHtml = '';
            variables.forEach(variable => {
                variablesHtml += `
                    <div class="variable-item">
                        <div class="variable-name">${variable.name}</div>
                        <div class="variable-type">${variable.type}</div>
                    </div>
                `;
            });
            
            agentVariables.innerHTML = variablesHtml;
        }

        // Extract Variables from Nodes
        function extractVariablesFromNodes() {
            const variables = [];
            
            visualDesignerState.nodes.forEach(nodeData => {
                if (nodeData.type === 'declare' && nodeData.data.Key) {
                    variables.push({
                        name: nodeData.data.Key,
                        type: nodeData.data.Type || 'STRING'
                    });
                } else if (nodeData.type === 'prop' && nodeData.data.Key) {
                    variables.push({
                        name: nodeData.data.Key,
                        type: (nodeData.data.Type || 'STRING') + ' (PROP)'
                    });
                }
            });
            
            return variables;
        }

        // Setup Canvas Interaction
        function setupCanvasInteraction() {
            const canvasContainer = document.getElementById('canvasContainer');
            
            // Mouse move for dragging and connections
            document.addEventListener('mousemove', (e) => {
                if (visualDesignerState.draggedNode) {
                    const canvasRect = document.getElementById('statementCanvas').getBoundingClientRect();
                    const x = e.clientX - canvasRect.left - visualDesignerState.draggedNode.dragOffset.x;
                    const y = e.clientY - canvasRect.top - visualDesignerState.draggedNode.dragOffset.y;
                    
                    visualDesignerState.draggedNode.x = Math.max(0, x);
                    visualDesignerState.draggedNode.y = Math.max(0, y);
                    
                    visualDesignerState.draggedNode.element.style.left = `${visualDesignerState.draggedNode.x}px`;
                    visualDesignerState.draggedNode.element.style.top = `${visualDesignerState.draggedNode.y}px`;
                    
                    updateConnections();
                }
            });
            
            // Mouse up to stop dragging
            document.addEventListener('mouseup', () => {
                visualDesignerState.draggedNode = null;
                visualDesignerState.connecting = null;
            });
            
            // Canvas click to deselect
            canvasContainer.addEventListener('click', (e) => {
                if (e.target === canvasContainer || e.target.id === 'statementCanvas') {
                    visualDesignerState.selectedNode = null;
                    document.querySelectorAll('.statement-node').forEach(node => {
                        node.classList.remove('selected');
                    });
                    updateInspector();
                }
            });
        }

        // Global functions for node management
        window.deleteStatementNode = function(nodeId) {
            const nodeData = visualDesignerState.nodes.get(nodeId);
            if (nodeData) {
                nodeData.element.remove();
                visualDesignerState.nodes.delete(nodeId);
                
                if (visualDesignerState.selectedNode === nodeId) {
                    visualDesignerState.selectedNode = null;
                    updateInspector();
                }
                
                // Remove connections
                visualDesignerState.connections = visualDesignerState.connections.filter(
                    conn => conn.from !== nodeId && conn.to !== nodeId
                );
                updateConnections();
                
                console.log(`üóëÔ∏è Deleted node: ${nodeId}`);
            }
        };

        // Connection System
        function startConnection(nodeData, pointType) {
            visualDesignerState.connecting = {
                sourceNode: nodeData,
                sourceType: pointType,
                tempLine: null
            };
            
            // Create temporary connection line
            const svg = document.getElementById('connectionSvg');
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            line.setAttribute('stroke', 'var(--primary)');
            line.setAttribute('stroke-width', '2');
            line.setAttribute('fill', 'none');
            line.setAttribute('stroke-dasharray', '5,5');
            line.setAttribute('marker-end', 'url(#arrowhead)');
            
            visualDesignerState.connecting.tempLine = line;
            svg.appendChild(line);
            
            // Add mouse move handler for temporary line
            const mouseMoveHandler = (e) => {
                if (visualDesignerState.connecting) {
                    updateTempConnection(e);
                }
            };
            
            const mouseUpHandler = (e) => {
                document.removeEventListener('mousemove', mouseMoveHandler);
                document.removeEventListener('mouseup', mouseUpHandler);
                
                // Check if connecting to another node
                const targetElement = document.elementFromPoint(e.clientX, e.clientY);
                const targetNode = targetElement?.closest('.statement-node');
                
                if (targetNode && targetNode.id !== nodeData.id) {
                    const targetNodeData = visualDesignerState.nodes.get(targetNode.id);
                    if (targetNodeData) {
                        createConnection(visualDesignerState.connecting.sourceNode, targetNodeData);
                    }
                }
                
                // Clean up temporary line
                if (visualDesignerState.connecting?.tempLine) {
                    svg.removeChild(visualDesignerState.connecting.tempLine);
                }
                visualDesignerState.connecting = null;
            };
            
            document.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('mouseup', mouseUpHandler);
            
            console.log(`üîó Starting connection from ${nodeData.id} (${pointType})`);
        }

        function updateTempConnection(e) {
            if (!visualDesignerState.connecting?.tempLine) return;
            
            const sourceNode = visualDesignerState.connecting.sourceNode;
            const canvasRect = document.getElementById('statementCanvas').getBoundingClientRect();
            
            const sourceX = sourceNode.x + (sourceNode.element.offsetWidth / 2);
            const sourceY = sourceNode.y + (sourceNode.element.offsetHeight / 2);
            
            const targetX = e.clientX - canvasRect.left;
            const targetY = e.clientY - canvasRect.top;
            
            const path = createConnectionPath(sourceX, sourceY, targetX, targetY);
            visualDesignerState.connecting.tempLine.setAttribute('d', path);
        }

        function createConnection(sourceNode, targetNode) {
            // Check if connection already exists
            const existingConnection = visualDesignerState.connections.find(
                conn => conn.from === sourceNode.id && conn.to === targetNode.id
            );
            
            if (existingConnection) {
                console.log('Connection already exists');
                return;
            }
            
            // Create connection data
            const connection = {
                id: `conn_${Date.now()}`,
                from: sourceNode.id,
                to: targetNode.id,
                fromNode: sourceNode,
                toNode: targetNode
            };
            
            visualDesignerState.connections.push(connection);
            updateConnections();
            
            console.log(`‚úÖ Created connection: ${sourceNode.id} ‚Üí ${targetNode.id}`);
        }

        function updateConnections() {
            const svg = document.getElementById('connectionSvg');
            
            // Clear existing connection paths (keep defs)
            const existingPaths = svg.querySelectorAll('path:not([stroke-dasharray])');
            existingPaths.forEach(path => path.remove());
            
            // Render all connections
            visualDesignerState.connections.forEach(connection => {
                const fromNode = connection.fromNode;
                const toNode = connection.toNode;
                
                if (!fromNode.element.parentNode || !toNode.element.parentNode) {
                    // Node was deleted, remove connection
                    return;
                }
                
                const fromX = fromNode.x + fromNode.element.offsetWidth;
                const fromY = fromNode.y + (fromNode.element.offsetHeight / 2);
                
                const toX = toNode.x;
                const toY = toNode.y + (toNode.element.offsetHeight / 2);
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', createConnectionPath(fromX, fromY, toX, toY));
                path.setAttribute('stroke', 'var(--primary)');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                path.setAttribute('marker-end', 'url(#arrowhead)');
                path.setAttribute('data-connection-id', connection.id);
                path.style.cursor = 'pointer';
                
                // Add click handler to delete connection
                path.addEventListener('click', () => {
                    deleteConnection(connection.id);
                });
                
                svg.appendChild(path);
            });
        }

        function createConnectionPath(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            
            // Create curved path
            const controlPoint1X = x1 + dx * 0.5;
            const controlPoint1Y = y1;
            const controlPoint2X = x2 - dx * 0.5;
            const controlPoint2Y = y2;
            
            return `M ${x1} ${y1} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${x2} ${y2}`;
        }

        function deleteConnection(connectionId) {
            visualDesignerState.connections = visualDesignerState.connections.filter(
                conn => conn.id !== connectionId
            );
            updateConnections();
            console.log(`üóëÔ∏è Deleted connection: ${connectionId}`);
        }

        // DSL Parser & Generator
        function loadStatementsAsNodes(statements) {
            if (!statements || statements.length === 0) return;
            
            console.log('üì• Loading existing statements as visual nodes');
            
            let yOffset = 50;
            statements.forEach((statement, index) => {
                const x = 100 + (index % 3) * 250;
                const y = yOffset + Math.floor(index / 3) * 150;
                
                const nodeType = statement.type?.toLowerCase();
                if (statementTemplates[nodeType]) {
                    createStatementNode(nodeType, x, y, statement.properties || {});
                }
            });
        }

        function parseXMLToAgentStatements(agentElement) {
            const statements = [];
            
            Array.from(agentElement.children).forEach(child => {
                const statement = parseXMLStatement(child);
                if (statement) {
                    statements.push(statement);
                }
            });
            
            return statements;
        }

        function parseXMLStatement(element) {
            const tagName = element.tagName;
            const statement = {
                type: tagName,
                properties: {}
            };
            
            // Parse attributes
            Array.from(element.attributes).forEach(attr => {
                statement.properties[attr.name] = attr.value;
            });
            
            // Parse text content for template-based statements
            if (element.textContent?.trim()) {
                statement.properties.Template = element.textContent.trim();
            }
            
            // Handle special cases
            switch(tagName) {
                case 'PROMPT':
                    statement.children = [];
                    Array.from(element.children).forEach(child => {
                        if (child.tagName === 'SECTION') {
                            const section = {
                                type: 'SECTION',
                                properties: { Type: child.getAttribute('Type') },
                                children: []
                            };
                            
                            Array.from(child.children).forEach(line => {
                                if (line.tagName === 'LINE') {
                                    section.children.push({
                                        type: 'LINE',
                                        properties: { Template: line.getAttribute('Template') || line.textContent }
                                    });
                                }
                            });
                            
                            statement.children.push(section);
                        }
                    });
                    break;
                    
                case 'CHOICE':
                    statement.children = [];
                    Array.from(element.children).forEach(child => {
                        if (child.tagName === 'PICK') {
                            statement.children.push({
                                type: 'PICK',
                                properties: {
                                    Key: child.getAttribute('Key'),
                                    Description: child.getAttribute('Description')
                                }
                            });
                        }
                    });
                    break;
            }
            
            return statement;
        }

        function generateAgentXML(agentKey) {
            const agent = currentPlan.agents.get(agentKey);
            if (!agent) return '';
            
            let xml = `    <AGENT Key="${agentKey}" Purpose="${agent.purpose || 'Tool'}">\n`;
            
            // Generate statements from visual nodes
            const sortedNodes = Array.from(visualDesignerState.nodes.values())
                .sort((a, b) => a.y - b.y); // Sort by vertical position
            
            sortedNodes.forEach(nodeData => {
                xml += generateStatementXML(nodeData, 2);
            });
            
            xml += `    </AGENT>\n`;
            return xml;
        }

        function generateStatementXML(nodeData, indentLevel = 0) {
            const indent = '    '.repeat(indentLevel);
            const template = nodeData.template;
            const data = nodeData.data;
            
            let xml = `${indent}<${template.type}`;
            
            // Add attributes
            Object.entries(data).forEach(([key, value]) => {
                if (value && key !== 'Template' && key !== 'Content') {
                    xml += ` ${key}="${escapeXML(value)}"`;
                }
            });
            
            // Handle content
            if (data.Template) {
                xml += ` Template="${escapeXML(data.Template)}"`;
            }
            
            // Close tag
            if (template.hasChildren || template.hasBody || data.Content) {
                xml += `>\n`;
                
                // Add content if any
                if (data.Content) {
                    xml += `${indent}    ${escapeXML(data.Content)}\n`;
                }
                
                xml += `${indent}</${template.type}>\n`;
            } else {
                xml += `/>\n`;
            }
            
            return xml;
        }

        function escapeXML(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#x27;');
        }

        // Enhanced XML Generation
        function generateXML() {
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += `<PLAN Key="${currentPlan.key || 'UntitledPlan'}" Description="${currentPlan.description || 'Generated by Enterprise DSL Designer'}" Author="${currentPlan.author || 'DSL Designer'}">\n\n`;
            
            // Generate SCHEMA section if schemas exist
            if (currentPlan.schemas.size > 0) {
                xml += '    <SCHEMA>\n';
                currentPlan.schemas.forEach((schema, key) => {
                    xml += `        <!-- Schema ${key} definition -->\n`;
                });
                xml += '    </SCHEMA>\n\n';
            }
            
            // Generate SEED section if seed data exists
            if (currentPlan.seed.size > 0) {
                xml += '    <SEED>\n';
                currentPlan.seed.forEach((value, key) => {
                    xml += `        <DECLARE Key="${key}" Type="AUTO" Expression="${escapeXml(JSON.stringify(value))}" />\n`;
                });
                xml += '    </SEED>\n\n';
            }
            
            // Generate agents with visual statements
            currentPlan.agents.forEach((agent, key) => {
                if (visualDesignerState.currentAgent === key && visualDesignerState.nodes.size > 0) {
                    // Generate from visual designer
                    xml += generateAgentXML(key);
                } else {
                    // Generate basic agent structure
                    xml += `    <AGENT Key="${key}" Purpose="${agent.purpose || 'Tool'}">\n`;
                    xml += '        <!-- Agent statements will be here -->\n';
                    xml += '    </AGENT>\n';
                }
                xml += '\n';
            });
            
            // Add stores
            currentPlan.stores.forEach((store, key) => {
                xml += `    <STORE Key="${key}">\n`;
                xml += '        <!-- Store structure will be here -->\n';
                xml += '    </STORE>\n\n';
            });
            
            xml += '</PLAN>';
            return xml;
        }

        // Setup Inspector Handlers
        function setupInspectorHandlers() {
            // Already handled in updateInspector and setupPropertyHandlers
        }

        // DSL Interpreter Engine
        let interpreterState = {
            isRunning: false,
            currentNode: null,
            variables: new Map(),
            executionLog: [],
            callStack: [],
            userInputResolve: null,
            userInputReject: null
        };

        // Execute Agent Flow
        async function executeAgentFlow() {
            if (interpreterState.isRunning) return;
            
            interpreterState.isRunning = true;
            interpreterState.variables.clear();
            interpreterState.executionLog = [];
            interpreterState.callStack = [];
            
            console.log('üöÄ Starting agent execution');
            addExecutionLog('üöÄ Starting agent execution');
            
            try {
                // Find entry point (first node or one without inputs)
                const entryNode = findEntryNode();
                if (!entryNode) {
                    throw new Error('No entry point found. Add some statements and connect them.');
                }
                
                await executeFromNode(entryNode);
                
                console.log('‚úÖ Agent execution completed');
                addExecutionLog('‚úÖ Agent execution completed successfully');
                
            } catch (error) {
                console.error('‚ùå Agent execution failed:', error);
                addExecutionLog(`‚ùå Execution failed: ${error.message}`);
            } finally {
                interpreterState.isRunning = false;
                clearNodeStates();
            }
        }

        function findEntryNode() {
            // Find node with no incoming connections
            const nodesWithIncoming = new Set();
            visualDesignerState.connections.forEach(conn => {
                nodesWithIncoming.add(conn.to);
            });
            
            for (const [nodeId, nodeData] of visualDesignerState.nodes) {
                if (!nodesWithIncoming.has(nodeId)) {
                    return nodeData;
                }
            }
            
            // If all nodes have connections, return the first one
            return visualDesignerState.nodes.values().next().value;
        }

        async function executeFromNode(nodeData) {
            if (!interpreterState.isRunning) return;
            
            interpreterState.currentNode = nodeData;
            
            // Visual feedback
            clearNodeStates();
            nodeData.element.classList.add('executing');
            
            addExecutionLog(`‚ñ∂Ô∏è Executing ${nodeData.template.type}: ${nodeData.data.Key || nodeData.id}`);
            
            try {
                await executeStatement(nodeData);
                
                // Mark as completed
                nodeData.element.classList.remove('executing');
                nodeData.element.classList.add('completed');
                
                // Brief pause for visual feedback
                await sleep(300);
                
                // Execute next connected nodes
                const nextNodes = getConnectedNodes(nodeData);
                for (const nextNode of nextNodes) {
                    await executeFromNode(nextNode);
                }
                
            } catch (error) {
                nodeData.element.classList.remove('executing');
                nodeData.element.classList.add('error');
                throw error;
            }
        }

        function getConnectedNodes(nodeData) {
            return visualDesignerState.connections
                .filter(conn => conn.from === nodeData.id)
                .map(conn => visualDesignerState.nodes.get(conn.to))
                .filter(node => node !== undefined);
        }

        async function executeStatement(nodeData) {
            const type = nodeData.template.type;
            const data = nodeData.data;
            
            switch (type) {
                case 'DECLARE':
                    await executeDeclare(data);
                    break;
                case 'ASSIGN':
                    await executeAssign(data);
                    break;
                case 'OUT':
                    await executeOut(data);
                    break;
                case 'IN':
                    await executeIn(data);
                    break;
                case 'IF':
                    return await executeIf(nodeData, data);
                case 'WHILE':
                    return await executeWhile(nodeData, data);
                case 'CALL':
                    await executeCall(data);
                    break;
                case 'GENERATE':
                    await executeGenerate(data);
                    break;
                case 'READ':
                    await executeRead(data);
                    break;
                case 'WRITE':
                    await executeWrite(data);
                    break;
                case 'DESIGN':
                    await executeDesign(data);
                    break;
                case 'FETCH':
                    await executeFetch(data);
                    break;
                case 'SQL':
                    await executeSql(data);
                    break;
                case 'ANALYZE':
                    await executeAnalyze(data);
                    break;
                case 'SENSE':
                    await executeSense(data);
                    break;
                case 'ACTUATE':
                    await executeActuate(data);
                    break;
                case 'INJEST':
                    await executeInjest(data);
                    break;
                case 'FOREACH':
                    return await executeForeach(nodeData, data);
                case 'FOR':
                    return await executeFor(nodeData, data);
                case 'DO':
                    return await executeDo(nodeData, data);
                case 'ELSEIF':
                    return await executeElseIf(nodeData, data);
                case 'DEFAULT':
                    return await executeDefault(nodeData, data);
                case 'ELSE':
                    return await executeElse(nodeData, data);
                case 'BREAK':
                    return 'break';
                case 'CONTINUE':
                    return 'continue';
                default:
                    addExecutionLog(`‚ö†Ô∏è Statement type '${type}' not implemented yet`);
            }
        }

        async function executeDeclare(data) {
            const key = data.Key;
            if (!key) throw new Error('DECLARE: Key is required');
            
            let value = null;
            if (data.Expression) {
                value = interpolateTemplate(data.Expression);
                // Try to convert to appropriate type
                switch (data.Type) {
                    case 'INTEGER':
                        value = parseInt(value, 10) || 0;
                        break;
                    case 'DOUBLE':
                        value = parseFloat(value) || 0.0;
                        break;
                    case 'BOOL':
                        value = value === 'true' || value === '1';
                        break;
                    default:
                        value = String(value);
                }
            }
            
            interpreterState.variables.set(key, value);
            addExecutionLog(`üìù Declared ${key} (${data.Type || 'STRING'}) = ${JSON.stringify(value)}`);
            updateVariablesList();
        }

        async function executeAssign(data) {
            const key = data.Key;
            if (!key) throw new Error('ASSIGN: Key is required');
            
            const value = interpolateTemplate(data.Template || '');
            interpreterState.variables.set(key, value);
            
            addExecutionLog(`‚úèÔ∏è Assigned ${key} = ${JSON.stringify(value)}`);
            updateVariablesList();
        }

        async function executeOut(data) {
            const message = interpolateTemplate(data.Template || '');
            addExecutionLog(`üí¨ Output: ${message}`);
            
            // Show output in a modal or console
            console.log('OUTPUT:', message);
            
            // Could show in a modal dialog
            if (message.length < 200) {
                showNotification(message, 'info');
            } else {
                showOutputModal(message);
            }
        }

        async function executeIn(data) {
            const key = data.Key;
            const label = data.Label || 'Please enter a value:';
            const type = data.Type || 'TEXT';
            const preset = data.Preset || '';
            
            if (!key) throw new Error('IN: Key is required');
            
            // Show visual feedback
            interpreterState.currentNode.element.classList.remove('executing');
            interpreterState.currentNode.element.classList.add('waiting');
            
            addExecutionLog(`‚è∏Ô∏è Waiting for user input: ${label}`);
            
            try {
                const userInput = await showUserInputModal(key, label, type, preset);
                interpreterState.variables.set(key, userInput);
                
                addExecutionLog(`üë§ User input: ${key} = ${JSON.stringify(userInput)}`);
                updateVariablesList();
                
            } finally {
                interpreterState.currentNode.element.classList.remove('waiting');
            }
        }

        async function executeIf(nodeData, data) {
            // Support both formats: Key/Template format and simple Condition format
            if (data.Condition) {
                // Simple condition format (e.g., "rawData.length > 0")
                const condition = data.Condition;
                const conditionResult = evaluateCondition(condition);
                
                addExecutionLog(`üîÄ IF: ${condition} = ${conditionResult}`);
                
                if (conditionResult) {
                    await executeChildStatements(nodeData);
                    return true;
                }
                return false;
            } else {
                // Key/Template format
                const key = data.Key;
                const conditionType = data.ConditionType || 'Equal';
                const compareValue = interpolateTemplate(data.Template || '');
                
                if (!key) throw new Error('IF: Key is required');
                
                const actualValue = String(interpreterState.variables.get(key) || '');
                let conditionMet = false;
                
                switch (conditionType) {
                    case 'Equal':
                        conditionMet = actualValue === compareValue;
                    break;
                case 'NotEqual':
                    conditionMet = actualValue !== compareValue;
                    break;
                case 'GreaterThan':
                    conditionMet = parseFloat(actualValue) > parseFloat(compareValue);
                    break;
                case 'LessThan':
                    conditionMet = parseFloat(actualValue) < parseFloat(compareValue);
                    break;
                }
                
                addExecutionLog(`üîÄ IF ${key} ${conditionType} "${compareValue}" ‚Üí ${conditionMet ? 'TRUE' : 'FALSE'}`);
                
                if (conditionMet) {
                    await executeChildStatements(nodeData);
                    return true;
                }
                return false;
            }
        }

        async function executeWhile(nodeData, data) {
            const key = data.Key;
            const conditionType = data.ConditionType || 'Equal';
            const compareValue = interpolateTemplate(data.Template || '');
            
            if (!key) throw new Error('WHILE: Key is required');
            
            let iterations = 0;
            const maxIterations = 100; // Safety limit
            
            while (iterations < maxIterations && interpreterState.isRunning) {
                const actualValue = String(interpreterState.variables.get(key) || '');
                let conditionMet = false;
                
                switch (conditionType) {
                    case 'Equal':
                        conditionMet = actualValue === compareValue;
                        break;
                    case 'NotEqual':
                        conditionMet = actualValue !== compareValue;
                        break;
                    case 'GreaterThan':
                        conditionMet = parseFloat(actualValue) > parseFloat(compareValue);
                        break;
                    case 'LessThan':
                        conditionMet = parseFloat(actualValue) < parseFloat(compareValue);
                        break;
                }
                
                if (!conditionMet) break;
                
                addExecutionLog(`üîÅ WHILE iteration ${iterations + 1}: ${key} ${conditionType} "${compareValue}"`);
                
                // Execute body (connected nodes)
                const bodyNodes = getConnectedNodes(nodeData);
                for (const bodyNode of bodyNodes) {
                    await executeFromNode(bodyNode);
                }
                
                iterations++;
                await sleep(100); // Brief pause
            }
            
            if (iterations >= maxIterations) {
                addExecutionLog(`‚ö†Ô∏è WHILE loop reached maximum iterations (${maxIterations})`);
            }
        }

        async function executeCall(data) {
            const toKey = data.ToKey;
            if (!toKey) throw new Error('CALL: ToKey is required');
            
            const resultKey = data.Key;
            const variables = data.Variables ? data.Variables.split(',').map(v => v.trim()) : [];
            
            addExecutionLog(`üìû CALL ${toKey} with variables: [${variables.join(', ')}]`);
            
            // For now, simulate the call
            if (resultKey) {
                interpreterState.variables.set(resultKey, `Result from ${toKey}`);
                addExecutionLog(`üì• CALL result stored in ${resultKey}`);
                updateVariablesList();
            }
        }

        async function executeGenerate(data) {
            const key = data.Key;
            if (!key) throw new Error('GENERATE: Key is required');
            
            const maxTokens = parseInt(data.MaxTokens) || 500;
            const creativity = data.Creativity || 'Balanced';
            const prompt = data.Expression || data.Prompt || 'Generate helpful content';
            
            addExecutionLog(`ü§ñ Generating content for ${key} (${maxTokens} tokens, ${creativity})`);
            addExecutionLog(`üìù Using LLM: ${currentLLMConfig.source}/${currentLLMConfig.model}`);
            
            try {
                // Use the configured LLM for actual generation
                const generatedContent = await callConfiguredLLM(prompt, {
                    maxTokens: maxTokens,
                    temperature: getTemperatureFromCreativity(creativity),
                    provider: currentLLMConfig.source,
                    model: currentLLMConfig.model
                });
                
                interpreterState.variables.set(key, generatedContent);
                addExecutionLog(`‚ú® Generated ${generatedContent.length} characters for ${key}`);
                updateVariablesList();
            } catch (error) {
                addExecutionLog(`‚ùå LLM generation failed: ${error.message}`);
                // Fallback to mock content
                const fallbackContent = `Generated content for ${key} using ${creativity} creativity level. (LLM unavailable: ${error.message})`;
                interpreterState.variables.set(key, fallbackContent);
                addExecutionLog(`‚ö†Ô∏è Using fallback content for ${key}`);
                updateVariablesList();
            }
        }

        async function executeRead(data) {
            const key = data.Key;
            const fileKey = data.FileKey;
            
            if (!key || !fileKey) throw new Error('READ: Key and FileKey are required');
            
            addExecutionLog(`üìñ Reading file ${fileKey} into ${key}`);
            
            // Simulate file read
            const content = `Content from file: ${fileKey}`;
            interpreterState.variables.set(key, content);
            
            addExecutionLog(`üìÑ Read ${content.length} characters from ${fileKey}`);
            updateVariablesList();
        }

        async function executeWrite(data) {
            const key = data.Key;
            const fileKey = data.FileKey;
            
            if (!key || !fileKey) throw new Error('WRITE: Key and FileKey are required');
            
            const content = interpreterState.variables.get(key) || '';
            addExecutionLog(`üíæ Writing ${key} to file ${fileKey} (${content.length} characters)`);
            
            // Simulate file write
            await sleep(200);
            addExecutionLog(`‚úÖ Successfully wrote to ${fileKey}`);
        }

        // New RULES.xml Statement Handlers
        async function executeDesign(data) {
            const key = data.Key;
            const type = data.Type || 'UI';
            const template = data.Template;
            
            if (!key || !template) throw new Error('DESIGN: Key and Template are required');
            
            addExecutionLog(`üé® Designing ${type}: ${template}`);
            addExecutionLog(`üéØ Using LLM: ${currentLLMConfig.source}/${currentLLMConfig.model}`);
            
            try {
                // Create design prompt based on type and template
                const designPrompt = createDesignPrompt(template, type);
                
                // Use the configured LLM for design generation
                const llmDesign = await callConfiguredLLM(designPrompt, {
                    maxTokens: 1000,
                    temperature: 0.8, // Higher temperature for creative design tasks
                    provider: currentLLMConfig.source,
                    model: currentLLMConfig.model
                });
                
                interpreterState.variables.set(key, llmDesign);
                addExecutionLog(`‚úÖ LLM design completed and stored in ${key}`);
                updateVariablesList();
            } catch (error) {
                addExecutionLog(`‚ùå LLM design failed: ${error.message}`);
                
                // Fallback to basic design
                const fallbackDesign = `${type} Design: ${template} (LLM unavailable: ${error.message})`;
                interpreterState.variables.set(key, fallbackDesign);
                addExecutionLog(`‚ö†Ô∏è Using fallback design for ${key}`);
                updateVariablesList();
            }
        }

        async function executeFetch(data) {
            const key = data.Key;
            const url = data.Url;
            const method = data.Method || 'GET';
            
            if (!key || !url) throw new Error('FETCH: Key and Url are required');
            
            addExecutionLog(`üåê Fetching ${method} ${url}`);
            await sleep(500); // Simulate network request
            
            const mockResponse = {
                status: 200,
                data: `Response from ${url}`,
                headers: { 'content-type': 'application/json' }
            };
            
            interpreterState.variables.set(key, JSON.stringify(mockResponse));
            addExecutionLog(`‚úÖ Fetch completed, response stored in ${key}`);
            updateVariablesList();
        }

        async function executeSql(data) {
            const key = data.Key;
            const query = data.Query;
            const connection = data.Connection || 'default';
            
            if (!key || !query) throw new Error('SQL: Key and Query are required');
            
            addExecutionLog(`üóÑÔ∏è Executing SQL query on ${connection}`);
            addExecutionLog(`   Query: ${query.substring(0, 100)}${query.length > 100 ? '...' : ''}`);
            await sleep(800); // Simulate database query
            
            const mockResults = [
                { id: 1, name: 'Sample Record 1' },
                { id: 2, name: 'Sample Record 2' }
            ];
            
            interpreterState.variables.set(key, JSON.stringify(mockResults));
            addExecutionLog(`‚úÖ SQL query completed, ${mockResults.length} records stored in ${key}`);
            updateVariablesList();
        }

        async function executeAnalyze(data) {
            const key = data.Key;
            const dataSource = data.Data;
            const type = data.Type || 'STATISTICAL';
            
            if (!key || !dataSource) throw new Error('ANALYZE: Key and Data are required');
            
            addExecutionLog(`üìä Analyzing data (${type}): ${dataSource}`);
            addExecutionLog(`üîç Using LLM: ${currentLLMConfig.source}/${currentLLMConfig.model}`);
            
            try {
                // Get the actual data to analyze
                const actualData = interpreterState.variables.get(dataSource) || dataSource;
                
                // Create analysis prompt based on type
                const analysisPrompt = createAnalysisPrompt(actualData, type);
                
                // Use the configured LLM for analysis
                const llmAnalysis = await callConfiguredLLM(analysisPrompt, {
                    maxTokens: 800,
                    temperature: 0.3, // Lower temperature for analytical tasks
                    provider: currentLLMConfig.source,
                    model: currentLLMConfig.model
                });
                
                const analysisResult = {
                    type: type,
                    source: dataSource,
                    results: llmAnalysis,
                    confidence: 0.85,
                    timestamp: new Date().toISOString(),
                    llm_provider: currentLLMConfig.source,
                    llm_model: currentLLMConfig.model
                };
                
                interpreterState.variables.set(key, JSON.stringify(analysisResult));
                addExecutionLog(`‚úÖ LLM analysis completed, results stored in ${key}`);
                updateVariablesList();
            } catch (error) {
                addExecutionLog(`‚ùå LLM analysis failed: ${error.message}`);
                
                // Fallback to mock analysis
                const fallbackResult = {
                    type: type,
                    source: dataSource,
                    results: `${type} analysis of ${dataSource} (LLM unavailable: ${error.message})`,
                    confidence: 0.65,
                    timestamp: new Date().toISOString(),
                    fallback: true
                };
                
                interpreterState.variables.set(key, JSON.stringify(fallbackResult));
                addExecutionLog(`‚ö†Ô∏è Using fallback analysis for ${key}`);
                updateVariablesList();
            }
        }

        async function executeSense(data) {
            const key = data.Key;
            const source = data.Source || 'SENSOR';
            const duration = data.Duration || '1s';
            
            if (!key) throw new Error('SENSE: Key is required');
            
            addExecutionLog(`üëÅÔ∏è Sensing from ${source} for ${duration}`);
            await sleep(1000); // Simulate sensing duration
            
            const sensorData = {
                source: source,
                timestamp: new Date().toISOString(),
                data: `Sensed data from ${source}`,
                quality: 'HIGH'
            };
            
            interpreterState.variables.set(key, JSON.stringify(sensorData));
            addExecutionLog(`‚úÖ Sensing completed, data stored in ${key}`);
            updateVariablesList();
        }

        async function executeActuate(data) {
            const device = data.Device;
            const action = data.Action;
            const timeout = data.Timeout || '5s';
            
            if (!device || !action) throw new Error('ACTUATE: Device and Action are required');
            
            addExecutionLog(`‚ö° Actuating device ${device}: ${action} (timeout: ${timeout})`);
            await sleep(600); // Simulate actuation delay
            
            addExecutionLog(`‚úÖ Device ${device} actuated successfully`);
        }

        async function executeInjest(data) {
            const key = data.Key;
            const source = data.Source;
            const format = data.Format || 'JSON';
            
            if (!key || !source) throw new Error('INJEST: Key and Source are required');
            
            addExecutionLog(`üì• Ingesting data from ${source} (format: ${format})`);
            await sleep(800); // Simulate data ingestion
            
            const ingestedData = {
                source: source,
                format: format,
                processed: true,
                recordCount: 142,
                timestamp: new Date().toISOString()
            };
            
            interpreterState.variables.set(key, JSON.stringify(ingestedData));
            addExecutionLog(`‚úÖ Data ingested successfully, ${ingestedData.recordCount} records stored in ${key}`);
            updateVariablesList();
        }

        async function executeForeach(nodeData, data) {
            const variable = data.Variable;
            const collection = data.Collection;
            
            if (!variable || !collection) throw new Error('FOREACH: Variable and Collection are required');
            
            // Get collection data
            const collectionData = interpreterState.variables.get(collection) || [];
            let items = [];
            
            try {
                items = JSON.parse(collectionData);
                if (!Array.isArray(items)) {
                    items = [items];
                }
            } catch {
                items = String(collectionData).split(',');
            }
            
            addExecutionLog(`üîÑ FOREACH ${variable} in ${collection} (${items.length} items)`);
            
            for (let i = 0; i < items.length; i++) {
                interpreterState.variables.set(variable, items[i]);
                addExecutionLog(`   Processing item ${i + 1}: ${JSON.stringify(items[i])}`);
                updateVariablesList();
                
                // Execute child statements
                const result = await executeChildStatements(nodeData);
                if (result === 'break') break;
                if (result === 'continue') continue;
                
                await sleep(200);
            }
            
            addExecutionLog(`‚úÖ FOREACH completed`);
        }

        async function executeFor(nodeData, data) {
            const variable = data.Variable;
            const start = parseInt(data.Start) || 0;
            const end = parseInt(data.End) || 0;
            const step = parseInt(data.Step) || 1;
            
            if (!variable) throw new Error('FOR: Variable is required');
            
            addExecutionLog(`üî¢ FOR ${variable} = ${start} to ${end} step ${step}`);
            
            for (let i = start; i <= end; i += step) {
                interpreterState.variables.set(variable, i);
                addExecutionLog(`   Iteration: ${variable} = ${i}`);
                updateVariablesList();
                
                // Execute child statements
                const result = await executeChildStatements(nodeData);
                if (result === 'break') break;
                if (result === 'continue') continue;
                
                await sleep(100);
            }
            
            addExecutionLog(`‚úÖ FOR loop completed`);
        }

        async function executeDo(nodeData, data) {
            addExecutionLog(`üîÑ DO block executing`);
            await executeChildStatements(nodeData);
            addExecutionLog(`‚úÖ DO block completed`);
        }

        async function executeElseIf(nodeData, data) {
            const condition = data.Condition;
            if (!condition) throw new Error('ELSEIF: Condition is required');
            
            const conditionResult = evaluateCondition(condition);
            addExecutionLog(`üîÄ ELSEIF: ${condition} = ${conditionResult}`);
            
            if (conditionResult) {
                await executeChildStatements(nodeData);
                return true; // Condition was true
            }
            return false; // Condition was false
        }

        async function executeDefault(nodeData, data) {
            addExecutionLog(`üîÑ DEFAULT case executing`);
            await executeChildStatements(nodeData);
            addExecutionLog(`‚úÖ DEFAULT case completed`);
        }

        async function executeElse(nodeData, data) {
            addExecutionLog(`üîÑ ELSE block executing`);
            await executeChildStatements(nodeData);
            addExecutionLog(`‚úÖ ELSE block completed`);
        }

        async function executeChildStatements(nodeData) {
            // Execute child statements if this node has them
            if (nodeData.children && nodeData.children.length > 0) {
                for (const child of nodeData.children) {
                    const result = await executeStatement(child);
                    if (result === 'break' || result === 'continue') {
                        return result;
                    }
                }
            }
            return null;
        }

        // Helper Functions
        function interpolateTemplate(template) {
            if (!template) return '';
            
            let result = template;
            interpreterState.variables.forEach((value, key) => {
                const regex = new RegExp(`#${key}#`, 'g');
                result = result.replace(regex, String(value));
            });
            
            return result;
        }
        
        function evaluateCondition(condition) {
            // Simple condition evaluator for demo purposes
            // In production, you'd want a more robust expression parser
            try {
                // Handle common patterns
                if (condition.includes('.length > 0')) {
                    return true; // Assume data exists for demo
                }
                if (condition.includes('> 15')) {
                    return Math.random() > 0.5; // Random for demo
                }
                if (condition.includes('>=') || condition.includes('<=')) {
                    return Math.random() > 0.3; // Random for demo
                }
                
                // Default to true for demo purposes
                return true;
            } catch (e) {
                console.warn('Condition evaluation error:', e);
                return false;
            }
        }

        function addExecutionLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            interpreterState.executionLog.push({ timestamp, message });
            console.log(`[${timestamp}] ${message}`);
        }

        function clearNodeStates() {
            document.querySelectorAll('.statement-node').forEach(node => {
                node.classList.remove('executing', 'completed', 'error', 'waiting');
            });
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // User Input Modal
        function showUserInputModal(key, label, type, preset) {
            return new Promise((resolve, reject) => {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-dialog">
                        <div class="modal-header">
                            <h3>${label}</h3>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>Input for variable: <strong>${key}</strong></label>
                                ${type === 'TEXTAREA' 
                                    ? `<textarea id="userInput" placeholder="${label}" style="width: 100%; min-height: 80px; padding: 8px; border: 1px solid var(--border); border-radius: 4px;">${preset}</textarea>`
                                    : `<input type="text" id="userInput" placeholder="${label}" value="${preset}" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px;">`
                                }
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').resolve(null)">Cancel</button>
                            <button class="btn btn-primary" onclick="this.closest('.modal-overlay').resolve(document.getElementById('userInput').value)">Submit</button>
                        </div>
                    </div>
                `;
                
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center;
                    z-index: 10000;
                `;
                
                modal.querySelector('.modal-dialog').style.cssText = `
                    background: var(--surface); border-radius: var(--radius-lg);
                    min-width: 400px; max-width: 600px; box-shadow: var(--shadow-lg);
                `;
                
                modal.querySelector('.modal-header').style.cssText = `
                    padding: 20px; border-bottom: 1px solid var(--border);
                `;
                
                modal.querySelector('.modal-body').style.cssText = `
                    padding: 20px;
                `;
                
                modal.querySelector('.modal-footer').style.cssText = `
                    padding: 20px; border-top: 1px solid var(--border);
                    display: flex; gap: 12px; justify-content: flex-end;
                `;
                
                modal.resolve = (value) => {
                    document.body.removeChild(modal);
                    if (value !== null) {
                        resolve(value);
                    } else {
                        reject(new Error('User cancelled input'));
                    }
                };
                
                document.body.appendChild(modal);
                
                // Focus input
                setTimeout(() => {
                    document.getElementById('userInput').focus();
                }, 100);
            });
        }

        function showOutputModal(message) {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-dialog">
                    <div class="modal-header">
                        <h3>Output</h3>
                        <button class="btn btn-icon" onclick="document.body.removeChild(this.closest('.modal-overlay'))">
                            <i class="material-icons">close</i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div style="white-space: pre-wrap; max-height: 400px; overflow-y: auto; padding: 12px; background: var(--surface-2); border-radius: 4px; font-family: monospace;">${message}</div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-primary" onclick="document.body.removeChild(this.closest('.modal-overlay'))">Close</button>
                    </div>
                </div>
            `;
            
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center;
                z-index: 10000;
            `;
            
            document.body.appendChild(modal);
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 10001;
                background: var(--surface); border: 1px solid var(--border);
                border-radius: var(--radius); padding: 12px 16px; box-shadow: var(--shadow-lg);
                max-width: 300px; animation: slideIn 0.3s ease-out;
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    document.body.removeChild(notification);
                }
            }, 3000);
        }

        // Action Handler Functions
        function importXML() {
            document.getElementById('fileInput').click();
        }
        
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const xmlContent = e.target.result;
                document.getElementById('xmlEditor').value = xmlContent;
                parseXMLToPlan(xmlContent);
            };
            reader.readAsText(file);
        }
        
        function exportXML() {
            const xml = generateXML();
            const blob = new Blob([xml], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentPlan.key || 'plan'}.xml`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function toggleTheme() {
            document.body.classList.toggle('dark');
            const themeBtn = document.getElementById('themeBtn');
            const icon = themeBtn.querySelector('i');
            icon.textContent = document.body.classList.contains('dark') ? 'light_mode' : 'dark_mode';
        }
        
        function addAgent() {
            const key = prompt('Enter agent key:');
            if (!key) return;
            
            const purpose = prompt('Enter agent purpose (Orchestrator/Tool/AI/Data):', 'Tool');
            
            currentPlan.agents.set(key, {
                purpose: purpose,
                statements: []
            });
            
            updateStatistics();
            if (currentTab === 'agents') {
                loadAgentsView();
            }
        }
        
        function addStore() {
            const key = prompt('Enter store key:');
            if (!key) return;
            
            currentPlan.stores.set(key, {
                folders: new Map(),
                files: new Map()
            });
            
            updateStatistics();
            if (currentTab === 'store') {
                loadStoreView();
            }
        }
        
        function formatXML() {
            const xmlEditor = document.getElementById('xmlEditor');
            try {
                const formatted = formatXMLString(xmlEditor.value);
                xmlEditor.value = formatted;
            } catch (error) {
                alert('Failed to format XML: ' + error.message);
            }
        }
        
        function validateXML() {
            const xmlEditor = document.getElementById('xmlEditor');
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(xmlEditor.value, 'application/xml');
                const errorNode = doc.querySelector('parsererror');
                
                if (errorNode) {
                    alert('XML Validation Failed: ' + errorNode.textContent);
                } else {
                    alert('XML is valid!');
                }
            } catch (error) {
                alert('XML Validation Failed: ' + error.message);
            }
        }
        
        function syncFromXML() {
            const xmlContent = document.getElementById('xmlEditor').value;
            parseXMLToPlan(xmlContent);
        }
        
        function parseXMLToPlan(xmlContent) {
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(xmlContent, 'application/xml');
                const planElement = doc.documentElement;
                
                if (planElement.tagName !== 'PLAN') {
                    throw new Error('Root element must be PLAN');
                }
                
                // Parse plan attributes
                currentPlan.key = planElement.getAttribute('Key') || '';
                currentPlan.description = planElement.getAttribute('Description') || '';
                currentPlan.author = planElement.getAttribute('Author') || '';
                
                // Parse agents
                currentPlan.agents.clear();
                const agents = planElement.querySelectorAll('AGENT');
                agents.forEach(agentEl => {
                    const key = agentEl.getAttribute('Key');
                    const purpose = agentEl.getAttribute('Purpose');
                    
                    if (key) {
                        const statements = parseXMLToAgentStatements(agentEl);
                        currentPlan.agents.set(key, {
                            purpose: purpose,
                            statements: statements
                        });
                    }
                });
                
                // Parse stores
                currentPlan.stores.clear();
                const stores = planElement.querySelectorAll('STORE');
                stores.forEach(storeEl => {
                    const key = storeEl.getAttribute('Key');
                    
                    if (key) {
                        currentPlan.stores.set(key, {
                            folders: new Map(),
                            files: new Map()
                        });
                    }
                });
                
                // Refresh UI
                loadTabContent(currentTab);
                updateStatistics();
                
                
                
            } catch (error) {
                alert('Failed to parse XML: ' + error.message);
                console.error('XML parsing error:', error);
            }
        }
        
        function formatXMLString(xml) {
            const PADDING = ' '.repeat(4);
            const reg = /(>)(<)(\/*)/g;
            let formatted = xml.replace(reg, '$1\r\n$2$3');
            let pad = 0;
            
            return formatted.split('\r\n').map(line => {
                let indent = 0;
                if (line.match(/.+<\/\w[^>]*>$/)) {
                    indent = 0;
                } else if (line.match(/^<\/\w/) && pad > 0) {
                    pad -= 1;
                } else if (line.match(/^<\w[^>]*[^\/]>.*$/)) {
                    indent = 1;
                } else {
                    indent = 0;
                }
                
                const padding = PADDING.repeat(pad);
                pad += indent;
                
                return padding + line;
            }).join('\r\n');
        }

        // Enhanced Event Listeners
        function setupEventListeners() {
            // Plan form changes
            document.getElementById('planKey').addEventListener('input', (e) => {
                currentPlan.key = e.target.value;
                document.getElementById('planTitle').textContent = e.target.value || 'Untitled Plan';
            });
            
            document.getElementById('planDescription').addEventListener('input', (e) => {
                currentPlan.description = e.target.value;
            });
            
            document.getElementById('planAuthor').addEventListener('input', (e) => {
                currentPlan.author = e.target.value;
            });
            
            // Header actions
            document.getElementById('importBtn').addEventListener('click', importXML);
            document.getElementById('exportBtn').addEventListener('click', exportXML);
            document.getElementById('executeBtn').addEventListener('click', executePlan);
            document.getElementById('themeBtn').addEventListener('click', toggleTheme);
            
            // Agent actions
            document.getElementById('addAgentBtn').addEventListener('click', addAgent);
            
            // Store actions
            document.getElementById('addStoreBtn').addEventListener('click', addStore);
            
            // Seed actions
            document.getElementById('addSeedBtn').addEventListener('click', addSeedItem);
            document.getElementById('importSeedBtn').addEventListener('click', importSeedData);
            document.getElementById('exportSeedBtn').addEventListener('click', exportSeedData);
            
            // Canvas actions
            document.getElementById('executeCanvasBtn').addEventListener('click', executeCanvasPlan);
            document.getElementById('resetCanvasBtn').addEventListener('click', resetCanvas);
            document.getElementById('fitCanvasBtn').addEventListener('click', fitCanvasToView);
            
            // XML actions
            document.getElementById('formatXmlBtn').addEventListener('click', formatXML);
            document.getElementById('validateXmlBtn').addEventListener('click', validateXML);
            document.getElementById('syncFromXmlBtn').addEventListener('click', syncFromXML);
            
            // File input
            document.getElementById('fileInput').addEventListener('change', handleFileImport);
        }

        // Complete DSL Plan Execution Engine with Performance Monitoring
        let planExecutionState = {
            isRunning: false,
            currentPlan: null,
            variables: new Map(),
            agentMap: new Map(),
            executionLog: [],
            callStack: [],
            storeIndex: new Map(),
            performance: {
                startTime: null,
                endTime: null,
                agentExecutionTimes: new Map(),
                statementExecutionTimes: new Map(),
                totalStatements: 0,
                successfulStatements: 0,
                failedStatements: 0,
                averageStatementTime: 0,
                peakMemoryUsage: 0,
                executionBreakdown: new Map()
            },
            debugging: {
                breakpoints: new Set(),
                isStepMode: false,
                isPaused: false,
                watchedVariables: new Set(),
                executionHistory: [],
                errorRecoveryAttempts: 0
            }
        };

        async function executePlan() {
            if (planExecutionState.isRunning) {
                alert('Plan is already running!');
                return;
            }

            if (currentPlan.agents.size === 0) {
                alert('No agents found in the plan. Please add some agents first.');
                return;
            }

            // Find orchestrator agent
            const orchestrator = findOrchestratorAgent();
            if (!orchestrator) {
                alert('No Orchestrator agent found. Please create an agent with Purpose="Orchestrator".');
                return;
            }

            planExecutionState.isRunning = true;
            planExecutionState.variables.clear();
            planExecutionState.executionLog = [];
            planExecutionState.callStack = [];
            
            // Build agent map
            planExecutionState.agentMap.clear();
            currentPlan.agents.forEach((agent, key) => {
                planExecutionState.agentMap.set(key, {
                    key: key,
                    purpose: agent.purpose,
                    statements: agent.statements || [],
                    nodes: getAgentVisualNodes(key)
                });
            });

            // Build store index
            planExecutionState.storeIndex.clear();
            currentPlan.stores.forEach((store, key) => {
                planExecutionState.storeIndex.set(key, {
                    key: key,
                    content: `Sample content for store: ${key}`
                });
            });

            try {
                // Initialize performance tracking
                planExecutionState.performance.startTime = performance.now();
                planExecutionState.performance.totalStatements = 0;
                planExecutionState.performance.successfulStatements = 0;
                planExecutionState.performance.failedStatements = 0;
                
                addPlanExecutionLog('üöÄ Starting DSL Plan Execution');
                addPlanExecutionLog(`üìä Plan: ${currentPlan.key || 'Untitled'}`);
                addPlanExecutionLog(`üéØ Orchestrator: ${orchestrator.key}`);
                addPlanExecutionLog(`üë• Total Agents: ${currentPlan.agents.size}`);
                
                // Show execution UI
                showExecutionUI();
                
                // Execute the orchestrator
                const result = await executeDSLAgent(orchestrator, {});
                
                // Calculate final performance metrics
                planExecutionState.performance.endTime = performance.now();
                const totalTime = planExecutionState.performance.endTime - planExecutionState.performance.startTime;
                const successRate = (planExecutionState.performance.successfulStatements / planExecutionState.performance.totalStatements * 100).toFixed(1);
                
                addPlanExecutionLog('‚úÖ Plan execution completed successfully');
                addPlanExecutionLog(`‚è±Ô∏è Performance: ${Math.round(totalTime)}ms total, ${planExecutionState.performance.totalStatements} statements, ${successRate}% success rate`);
                addPlanExecutionLog(`üìã Final Result: ${JSON.stringify(result, null, 2)}`);
                
            } catch (error) {
                planExecutionState.performance.endTime = performance.now();
                planExecutionState.performance.failedStatements++;
                
                addPlanExecutionLog(`‚ùå Plan execution failed: ${error.message}`);
                console.error('Plan execution error:', error);
            } finally {
                planExecutionState.isRunning = false;
                addPlanExecutionLog('üèÅ Plan execution finished');
                
                // Log final performance summary
                if (planExecutionState.performance.startTime) {
                    const totalTime = (planExecutionState.performance.endTime || performance.now()) - planExecutionState.performance.startTime;
                    addPlanExecutionLog(`üìà Final Performance: ${Math.round(totalTime)}ms, ${planExecutionState.performance.agentExecutionTimes.size} agents executed`);
                }
            }
        }

        function findOrchestratorAgent() {
            for (const [key, agent] of currentPlan.agents) {
                if (agent.purpose === 'Orchestrator') {
                    return { key, ...agent };
                }
            }
            return null;
        }

        function getAgentVisualNodes(agentKey) {
            if (visualDesignerState.currentAgent === agentKey) {
                return Array.from(visualDesignerState.nodes.values());
            }
            return [];
        }

        async function executeDSLAgent(agent, context = {}) {
            addPlanExecutionLog(`‚ñ∂Ô∏è Executing Agent: ${agent.key} (${agent.purpose})`);
            
            planExecutionState.callStack.push(agent);
            
            try {
                // If agent has visual nodes, execute them
                if (agent.nodes && agent.nodes.length > 0) {
                    return await executeVisualAgent(agent, context);
                }
                
                // If agent has parsed statements, execute them
                if (agent.statements && agent.statements.length > 0) {
                    return await executeStatementAgent(agent, context);
                }
                
                // Default empty execution
                addPlanExecutionLog(`‚ö†Ô∏è Agent ${agent.key} has no statements to execute`);
                return context;
                
            } finally {
                planExecutionState.callStack.pop();
            }
        }

        async function executeVisualAgent(agent, context) {
            addPlanExecutionLog(`üé® Executing visual flow for agent: ${agent.key}`);
            
            // Temporarily switch to this agent's visual state
            const originalAgent = visualDesignerState.currentAgent;
            const originalNodes = new Map(visualDesignerState.nodes);
            
            // Load this agent's nodes if they exist
            if (agent.key !== visualDesignerState.currentAgent) {
                // This would load the agent's saved visual state
                addPlanExecutionLog(`üì• Loading visual state for agent: ${agent.key}`);
            }
            
            // Execute the visual flow
            const result = await executeVisualFlow(agent.nodes, context);
            
            // Restore original state
            visualDesignerState.currentAgent = originalAgent;
            visualDesignerState.nodes = originalNodes;
            
            return result;
        }

        async function executeStatementAgent(agent, context) {
            addPlanExecutionLog(`üìú Executing parsed statements for agent: ${agent.key}`);
            
            // Copy context variables to plan state
            Object.entries(context).forEach(([key, value]) => {
                planExecutionState.variables.set(key, value);
            });
            
            let currentPrompt = null;
            let returnValue = undefined;
            
            try {
                for (const statement of agent.statements) {
                    if (!planExecutionState.isRunning) {
                        addPlanExecutionLog('‚èπÔ∏è Execution stopped');
                        break;
                    }
                    
                    const type = statement.type;
                    const props = statement.properties || {};
                    
                    addPlanExecutionLog(`üî∏ ${type}: ${props.Key || props.ToKey || 'unnamed'}`);
                    
                    try {
                        // Performance tracking for each statement
                        const statementStartTime = performance.now();
                        planExecutionState.performance.totalStatements++;
                        
                        switch (type) {
                            case 'DECLARE':
                                await executeDSLDeclare(props);
                                break;
                                
                            case 'ASSIGN':
                                await executeDSLAssign(props);
                                break;
                                
                            case 'OUT':
                                await executeDSLOut(props);
                                break;
                                
                            case 'IN':
                                await executeDSLIn(props);
                                break;
                                
                            case 'CHOICE':
                                await executeDSLChoice(props, statement);
                                break;
                                
                            case 'CALL':
                                await executeDSLCall(props);
                                break;
                                
                            case 'GENERATE':
                                await executeDSLGenerate(props);
                                break;
                                
                            case 'PROMPT':
                                currentPrompt = await executeDSLPrompt(props, statement);
                                break;
                                
                            case 'READ':
                                await executeDSLRead(props);
                                break;
                                
                            case 'WRITE':
                                await executeDSLWrite(props);
                                break;
                                
                            case 'IF':
                                const ifResult = await executeDSLIf(props);
                                // Note: Full IF/THEN/ELSE would require parsing child statements
                                break;
                                
                            case 'WHILE':
                                await executeDSLWhileStatement(props, statement);
                                break;
                                
                            case 'SWITCH':
                                await executeDSLSwitch(props, statement);
                                break;
                                
                            case 'PROP':
                                await executeDSLProp(props);
                                break;
                                
                            case 'RETURN':
                                returnValue = await executeDSLReturn(props);
                                addPlanExecutionLog(`üì§ Agent returning: ${JSON.stringify(returnValue)}`);
                                break;
                                
                            default:
                                addPlanExecutionLog(`‚ö†Ô∏è Unknown statement type: ${type}`);
                        }
                        
                        // Track successful statement execution
                        const statementEndTime = performance.now();
                        const statementDuration = statementEndTime - statementStartTime;
                        
                        planExecutionState.performance.successfulStatements++;
                        planExecutionState.performance.statementExecutionTimes.set(
                            `${type}_${Date.now()}`, 
                            statementDuration
                        );
                        
                        // Small delay for visual feedback
                        await sleep(50);
                        
                    } catch (statementError) {
                        planExecutionState.performance.failedStatements++;
                        addPlanExecutionLog(`‚ùå Error in ${type}: ${statementError.message}`);
                        
                        // Continue execution for non-critical errors
                        if (!isCriticalError(statementError)) {
                            continue;
                        } else {
                            throw statementError;
                        }
                    }
                }
                
                // Build result context
                const result = {};
                planExecutionState.variables.forEach((value, key) => {
                    result[key] = value;
                });
                
                if (returnValue !== undefined) {
                    result.__return__ = returnValue;
                }
                
                addPlanExecutionLog(`‚úÖ Agent ${agent.key} completed with ${Object.keys(result).length} variables`);
                return result;
                
            } catch (error) {
                addPlanExecutionLog(`‚ùå Agent ${agent.key} failed: ${error.message}`);
                throw error;
            }
        }

        function isCriticalError(error) {
            // Define which errors should stop execution vs continue
            const criticalErrors = [
                'Agent not found',
                'Maximum recursion',
                'Stack overflow'
            ];
            
            return criticalErrors.some(critical => 
                error.message.toLowerCase().includes(critical.toLowerCase())
            );
        }

        async function executeVisualFlow(nodes, context) {
            // Copy variables from context to interpreter state
            Object.entries(context).forEach(([key, value]) => {
                planExecutionState.variables.set(key, value);
            });

            // Find entry node (no incoming connections)
            const entryNode = findEntryNodeFromList(nodes);
            if (!entryNode) {
                throw new Error('No entry point found in visual flow');
            }

            return await executeVisualNode(entryNode, nodes);
        }

        function findEntryNodeFromList(nodes) {
            if (!nodes || nodes.length === 0) return null;
            
            const nodesWithIncoming = new Set();
            visualDesignerState.connections.forEach(conn => {
                nodesWithIncoming.add(conn.to);
            });
            
            for (const node of nodes) {
                if (!nodesWithIncoming.has(node.id)) {
                    return node;
                }
            }
            
            return nodes[0]; // fallback to first node
        }

        async function executeVisualNode(nodeData, allNodes) {
            const type = nodeData.template.type;
            const data = nodeData.data;
            
            addPlanExecutionLog(`üî∏ ${type}: ${data.Key || nodeData.id}`);
            
            try {
                switch (type) {
                    case 'DECLARE':
                        await executeDSLDeclare(data);
                        break;
                    case 'ASSIGN':
                        await executeDSLAssign(data);
                        break;
                    case 'OUT':
                        await executeDSLOut(data);
                        break;
                    case 'IN':
                        await executeDSLIn(data);
                        break;
                    case 'CALL':
                        await executeDSLCall(data);
                        break;
                    case 'GENERATE':
                        await executeDSLGenerate(data);
                        break;
                    case 'READ':
                        await executeDSLRead(data);
                        break;
                    case 'WRITE':
                        await executeDSLWrite(data);
                        break;
                    case 'IF':
                        const ifResult = await executeDSLIf(data);
                        // In full implementation, would branch based on result
                        break;
                    case 'WHILE':
                        await executeDSLWhile(nodeData, allNodes);
                        break;
                    default:
                        addPlanExecutionLog(`‚ö†Ô∏è Statement type '${type}' not implemented`);
                }
                
                // Execute connected nodes
                const nextNodes = getConnectedNodesFromList(nodeData, allNodes);
                for (const nextNode of nextNodes) {
                    await executeVisualNode(nextNode, allNodes);
                }
                
            } catch (error) {
                addPlanExecutionLog(`‚ùå Error in ${type}: ${error.message}`);
                throw error;
            }
        }

        function getConnectedNodesFromList(nodeData, allNodes) {
            return visualDesignerState.connections
                .filter(conn => conn.from === nodeData.id)
                .map(conn => allNodes.find(node => node.id === conn.to))
                .filter(node => node !== undefined);
        }

        // DSL Statement Implementations
        async function executeDSLDeclare(data) {
            const key = data.Key;
            if (!key) throw new Error('DECLARE: Key is required');
            
            let value = null;
            if (data.Expression) {
                value = interpolateDSLTemplate(data.Expression);
                
                // Type conversion
                switch (data.Type) {
                    case 'INTEGER':
                        value = parseInt(value, 10) || 0;
                        break;
                    case 'DOUBLE':
                        value = parseFloat(value) || 0.0;
                        break;
                    case 'BOOL':
                        value = value === 'true' || value === '1';
                        break;
                    default:
                        value = String(value);
                }
            }
            
            planExecutionState.variables.set(key, value);
            addPlanExecutionLog(`üìù Declared ${key} (${data.Type || 'STRING'}) = ${JSON.stringify(value)}`);
        }

        async function executeDSLAssign(data) {
            const key = data.Key;
            if (!key) throw new Error('ASSIGN: Key is required');
            
            const value = interpolateDSLTemplate(data.Template || '');
            planExecutionState.variables.set(key, value);
            
            addPlanExecutionLog(`‚úèÔ∏è Assigned ${key} = ${JSON.stringify(value)}`);
        }

        async function executeDSLOut(data) {
            const message = interpolateDSLTemplate(data.Template || '');
            addPlanExecutionLog(`üí¨ Output: ${message}`);
            
            // Show in execution UI
            showExecutionOutput(message);
        }

        async function executeDSLIn(data) {
            const key = data.Key;
            const label = data.Label || 'Please enter a value:';
            const type = data.Type || 'TEXT';
            const preset = data.Preset || '';
            
            if (!key) throw new Error('IN: Key is required');
            
            addPlanExecutionLog(`‚è∏Ô∏è Waiting for user input: ${label}`);
            
            try {
                const userInput = await showUserInputModal(key, label, type, preset);
                planExecutionState.variables.set(key, userInput);
                
                addPlanExecutionLog(`üë§ User input: ${key} = ${JSON.stringify(userInput)}`);
                
            } catch (error) {
                addPlanExecutionLog(`‚ùå User input cancelled: ${error.message}`);
                throw error;
            }
        }

        async function executeDSLCall(data) {
            const toKey = data.ToKey;
            if (!toKey) throw new Error('CALL: ToKey is required');
            
            const targetAgent = planExecutionState.agentMap.get(toKey);
            if (!targetAgent) {
                throw new Error(`CALL: Agent '${toKey}' not found`);
            }
            
            const resultKey = data.Key;
            const variables = data.Variables ? data.Variables.split(',').map(v => v.trim()) : [];
            
            // Build context for called agent
            const callContext = {};
            variables.forEach(varName => {
                if (planExecutionState.variables.has(varName)) {
                    callContext[varName] = planExecutionState.variables.get(varName);
                }
            });
            
            addPlanExecutionLog(`üìû CALL ${toKey} with variables: [${variables.join(', ')}]`);
            
            // Execute the called agent
            const result = await executeDSLAgent(targetAgent, callContext);
            
            // Store result if requested
            if (resultKey) {
                const returnValue = result.__return__ || result;
                planExecutionState.variables.set(resultKey, returnValue);
                addPlanExecutionLog(`üì• CALL result stored in ${resultKey}: ${JSON.stringify(returnValue)}`);
            }
        }

        async function executeDSLGenerate(data) {
            const key = data.Key;
            if (!key) throw new Error('GENERATE: Key is required');
            
            const maxTokens = parseInt(data.MaxTokens) || 500;
            const creativity = data.Creativity || 'Balanced';
            const promptKeys = data.Keys ? data.Keys.split(',').map(k => k.trim()) : [];
            
            addPlanExecutionLog(`ü§ñ Generating content for ${key} (${maxTokens} tokens, ${creativity})`);
            
            // Build prompt from referenced prompt variables
            let finalPrompt = '';
            if (promptKeys.length > 0) {
                promptKeys.forEach(promptKey => {
                    const promptContent = planExecutionState.variables.get(promptKey);
                    if (promptContent) {
                        finalPrompt += promptContent + '\n';
                    }
                });
            } else {
                // Fallback to a generic prompt
                finalPrompt = `Generate content for: ${key}\n\nContext variables:\n`;
                planExecutionState.variables.forEach((value, varKey) => {
                    if (typeof value === 'string' && value.length < 100) {
                        finalPrompt += `- ${varKey}: ${value}\n`;
                    }
                });
            }
            
            try {
                // Try to use configured LLM
                let generatedContent;
                const providerConfig = getProviderConfiguration();
                
                if (providerConfig.provider === 'webllm' && currentEngine && currentLLMConfig.model) {
                    addPlanExecutionLog(`üß† Using WebLLM ${currentLLMConfig.model} for generation...`);
                    
                    const response = await currentEngine.chat.completions.create({
                        messages: [
                            {
                                role: 'system',
                                content: currentLLMConfig.systemPrompt || 'You are a helpful AI assistant specialized in DSL execution and plan orchestration.'
                            },
                            {
                                role: 'user',
                                content: finalPrompt
                            }
                        ],
                        max_tokens: Math.min(maxTokens, currentLLMConfig.maxTokens || 512),
                        temperature: currentLLMConfig.temperature || (creativity === 'Creative' ? 0.9 : creativity === 'Focused' ? 0.3 : 0.7),
                        top_p: currentLLMConfig.topP || 0.9,
                        frequency_penalty: currentLLMConfig.frequencyPenalty || 0.0,
                        presence_penalty: currentLLMConfig.presencePenalty || 0.0,
                        stream: currentLLMConfig.enableStreaming || false
                    });
                    
                    if (currentLLMConfig.enableStreaming) {
                        generatedContent = '';
                        for await (const chunk of response) {
                            const delta = chunk.choices[0]?.delta?.content || '';
                            generatedContent += delta;
                        }
                    } else {
                        generatedContent = response.choices[0].message.content;
                    }
                    
                    addPlanExecutionLog(`‚ú® ${currentLLMConfig.model} generated ${generatedContent.length} characters`);
                    
                } else if (providerConfig.provider && providerConfig.model && providerConfig.provider !== 'webllm') {
                    // Use configured provider (simulation for now - in real implementation would make actual API calls)
                    addPlanExecutionLog(`üåê Using ${providerConfig.provider} ${providerConfig.model} for generation...`);
                    
                    // Simulate API call delay
                    await sleep(1000 + Math.random() * 2000);
                    
                    // Generate realistic content based on provider
                    const providerNames = {
                        'openai': 'OpenAI',
                        'github': 'GitHub Models',
                        'gemini': 'Google Gemini',
                        'groq': 'Groq',
                        'ollama': 'Ollama',
                        'foundry': 'Foundry',
                        'huggingface': 'Hugging Face'
                    };
                    
                    generatedContent = `# ${providerNames[providerConfig.provider] || providerConfig.provider} Generated Content

This content was generated by ${providerConfig.model} using the following configuration:
- Provider: ${providerConfig.provider}
- Model: ${providerConfig.model}
- Temperature: ${providerConfig.temperature}
- Max Tokens: ${providerConfig.maxTokens}
- System Prompt: ${providerConfig.systemPrompt.substring(0, 100)}...

Prompt: "${finalPrompt.substring(0, 200)}${finalPrompt.length > 200 ? '...' : ''}"

Generated Response:
${generateContextualContent(finalPrompt, creativity, providerConfig.provider)}

---
*Note: This is a simulated response. In a production environment, this would make actual API calls to the configured provider.*`;
                    
                    addPlanExecutionLog(`‚ú® ${providerConfig.provider} generated ${generatedContent.length} characters`);
                    
                } else if (typeof CreateMLCEngine !== 'undefined' && window.webLLMEngine) {
                    // Fallback to basic WebLLM if available
                    addPlanExecutionLog(`üß† Using basic WebLLM for generation...`);
                    
                    const response = await window.webLLMEngine.chat.completions.create({
                        messages: [
                            {
                                role: 'user',
                                content: finalPrompt
                            }
                        ],
                        max_tokens: maxTokens,
                        temperature: creativity === 'Creative' ? 0.9 : creativity === 'Focused' ? 0.3 : 0.7
                    });
                    
                    generatedContent = response.choices[0].message.content;
                    addPlanExecutionLog(`‚ú® WebLLM generated ${generatedContent.length} characters`);
                    
                } else {
                    // Fallback to sophisticated simulation
                    addPlanExecutionLog(`üìù Using simulation (No LLM configured)`);
                    await sleep(1500);
                    
                    generatedContent = `# AI-Generated Content for ${key}

**Generation Parameters:**
- Max Tokens: ${maxTokens}
- Creativity Level: ${creativity}
- Prompt Sources: ${promptKeys.length > 0 ? promptKeys.join(', ') : 'Default context'}

**Context-Aware Generation:**
Based on the current execution context, this content addresses the key aspects of the task. The generation system has analyzed ${planExecutionState.variables.size} variables and ${planExecutionState.callStack.length} call stack levels.

**Key Insights:**
${Array.from(planExecutionState.variables.entries())
    .filter(([k, v]) => typeof v === 'string' && v.length > 10 && v.length < 200)
    .slice(0, 3)
    .map(([k, v]) => `‚Ä¢ ${k}: ${v.substring(0, 100)}${v.length > 100 ? '...' : ''}`)
    .join('\n')}

**Generated Response:**
This sophisticated AI-generated content demonstrates contextual awareness and incorporates the specified creativity level of "${creativity}". The content is tailored to the current execution state and available variables.

*Generated at: ${new Date().toISOString()}*
*Session Variables: ${Array.from(planExecutionState.variables.keys()).join(', ')}*`;
                    
                    addPlanExecutionLog(`‚ú® Enhanced simulation generated ${generatedContent.length} characters`);
                }
                
                planExecutionState.variables.set(key, generatedContent);
                
            } catch (error) {
                addPlanExecutionLog(`‚ùå Generation failed: ${error.message}`);
                
                // Fallback content
                const fallbackContent = `Generation failed for ${key}. Error: ${error.message}`;
                planExecutionState.variables.set(key, fallbackContent);
            }
        }

        async function executeDSLRead(data) {
            const key = data.Key;
            const fileKey = data.FileKey;
            
            if (!key || !fileKey) throw new Error('READ: Key and FileKey are required');
            
            const storeFile = planExecutionState.storeIndex.get(fileKey);
            if (storeFile) {
                planExecutionState.variables.set(key, storeFile.content);
                addPlanExecutionLog(`üìñ Read ${storeFile.content.length} characters from ${fileKey} into ${key}`);
            } else {
                planExecutionState.variables.set(key, '');
                addPlanExecutionLog(`‚ö†Ô∏è File ${fileKey} not found, set ${key} to empty string`);
            }
        }

        async function executeDSLWrite(data) {
            const keys = data.Key;
            const fileKey = data.FileKey;
            
            if (!keys || !fileKey) throw new Error('WRITE: Key and FileKey are required');
            
            // Handle multiple variables (comma-separated)
            const keyList = keys.split(',').map(k => k.trim());
            let combinedContent = '';
            
            keyList.forEach((key, index) => {
                const value = planExecutionState.variables.get(key);
                if (value !== undefined) {
                    combinedContent += (index > 0 ? '\n---\n' : '') + `${key}: ${JSON.stringify(value)}`;
                }
            });
            
            // Store in store index
            planExecutionState.storeIndex.set(fileKey, {
                key: fileKey,
                content: combinedContent,
                variables: keyList,
                timestamp: new Date().toISOString()
            });
            
            addPlanExecutionLog(`üíæ Wrote ${combinedContent.length} characters from [${keyList.join(', ')}] to ${fileKey}`);
        }

        async function executeDSLIf(data) {
            const key = data.Key;
            const conditionType = data.ConditionType || 'Equal';
            const compareValue = interpolateDSLTemplate(data.Template || '');
            
            if (!key) throw new Error('IF: Key is required');
            
            const actualValue = String(planExecutionState.variables.get(key) || '');
            let conditionMet = false;
            
            switch (conditionType) {
                case 'Equal':
                    conditionMet = actualValue === compareValue;
                    break;
                case 'NotEqual':
                    conditionMet = actualValue !== compareValue;
                    break;
                case 'GreaterThan':
                    conditionMet = parseFloat(actualValue) > parseFloat(compareValue);
                    break;
                case 'LessThan':
                    conditionMet = parseFloat(actualValue) < parseFloat(compareValue);
                    break;
            }
            
            addPlanExecutionLog(`üîÄ IF ${key} ${conditionType} "${compareValue}" ‚Üí ${conditionMet ? 'TRUE' : 'FALSE'}`);
            return conditionMet;
        }

        async function executeDSLWhile(nodeData, allNodes) {
            const data = nodeData.data;
            const key = data.Key;
            const conditionType = data.ConditionType || 'Equal';
            const compareValue = interpolateDSLTemplate(data.Template || '');
            
            if (!key) throw new Error('WHILE: Key is required');
            
            let iterations = 0;
            const maxIterations = 100; // Safety limit
            
            while (iterations < maxIterations && planExecutionState.isRunning) {
                const actualValue = String(planExecutionState.variables.get(key) || '');
                let conditionMet = false;
                
                switch (conditionType) {
                    case 'Equal':
                        conditionMet = actualValue === compareValue;
                        break;
                    case 'NotEqual':
                        conditionMet = actualValue !== compareValue;
                        break;
                    case 'GreaterThan':
                        conditionMet = parseFloat(actualValue) > parseFloat(compareValue);
                        break;
                    case 'LessThan':
                        conditionMet = parseFloat(actualValue) < parseFloat(compareValue);
                        break;
                }
                
                if (!conditionMet) break;
                
                addPlanExecutionLog(`üîÅ WHILE iteration ${iterations + 1}: ${key} ${conditionType} "${compareValue}"`);
                
                // Execute connected nodes
                const bodyNodes = getConnectedNodesFromList(nodeData, allNodes);
                for (const bodyNode of bodyNodes) {
                    await executeVisualNode(bodyNode, allNodes);
                }
                
                iterations++;
                await sleep(100);
            }
            
            if (iterations >= maxIterations) {
                addPlanExecutionLog(`‚ö†Ô∏è WHILE loop reached maximum iterations (${maxIterations})`);
            }
        }

        // Helper Functions
        function interpolateDSLTemplate(template) {
            if (!template) return '';
            
            let result = template;
            planExecutionState.variables.forEach((value, key) => {
                const regex = new RegExp(`#${key}#`, 'g');
                result = result.replace(regex, String(value));
            });
            
            return result;
        }

        function addPlanExecutionLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            planExecutionState.executionLog.push({ timestamp, message });
            console.log(`[${timestamp}] ${message}`);
            
            // Update execution UI if visible
            updateExecutionUI(message);
        }

        function showExecutionUI() {
            // Create execution monitoring modal
            const modal = document.createElement('div');
            modal.id = 'executionModal';
            modal.className = 'execution-modal';
            modal.innerHTML = `
                <div class="execution-dialog">
                    <div class="execution-header">
                        <h3>üöÄ DSL Plan Execution</h3>
                        <button class="btn btn-icon" onclick="closeExecutionUI()">
                            <i class="material-icons">close</i>
                        </button>
                    </div>
                    <div class="execution-body">
                        <div class="execution-log" id="executionLogDisplay"></div>
                        <div class="execution-output" id="executionOutputDisplay"></div>
                    </div>
                    <div class="execution-footer">
                        <button class="btn btn-secondary" onclick="stopPlanExecution()">Stop Execution</button>
                        <button class="btn btn-primary" onclick="closeExecutionUI()">Close</button>
                    </div>
                </div>
            `;
            
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center;
                z-index: 10000;
            `;
            
            document.body.appendChild(modal);
        }

        function updateExecutionUI(message) {
            const logDisplay = document.getElementById('executionLogDisplay');
            if (logDisplay) {
                const logEntry = document.createElement('div');
                logEntry.textContent = message;
                logEntry.style.cssText = 'padding: 4px 0; border-bottom: 1px solid var(--border); font-family: monospace; font-size: 13px;';
                logDisplay.appendChild(logEntry);
                logDisplay.scrollTop = logDisplay.scrollHeight;
            }
        }

        function showExecutionOutput(message) {
            const outputDisplay = document.getElementById('executionOutputDisplay');
            if (outputDisplay) {
                const outputEntry = document.createElement('div');
                outputEntry.innerHTML = `<strong>Output:</strong> ${message}`;
                outputEntry.style.cssText = 'padding: 8px; margin: 4px 0; background: var(--surface-2); border-radius: 4px; border-left: 4px solid var(--primary);';
                outputDisplay.appendChild(outputEntry);
                outputDisplay.scrollTop = outputDisplay.scrollHeight;
            }
        }

        window.closeExecutionUI = function() {
            const modal = document.getElementById('executionModal');
            if (modal) {
                document.body.removeChild(modal);
            }
        };

        window.stopPlanExecution = function() {
            planExecutionState.isRunning = false;
            addPlanExecutionLog('‚èπÔ∏è Execution stopped by user');
        };

        // Additional DSL Statement Handlers for Parsed XML
        async function executeDSLProp(props) {
            // PROP statements define agent parameters/properties
            const key = props.Key;
            const type = props.Type || 'STRING';
            
            if (!key) {
                addPlanExecutionLog(`‚ö†Ô∏è PROP statement missing Key`);
                return;
            }
            
            // PROP acts like DECLARE but for agent parameters
            let value = null;
            if (props.Expression) {
                value = interpolateDSLTemplate(props.Expression);
                
                // Type conversion
                switch (type) {
                    case 'INTEGER':
                        value = parseInt(value, 10) || 0;
                        break;
                    case 'DOUBLE':
                        value = parseFloat(value) || 0.0;
                        break;
                    case 'BOOL':
                        value = value === 'true' || value === '1';
                        break;
                    default:
                        value = String(value);
                }
            }
            
            planExecutionState.variables.set(key, value);
            addPlanExecutionLog(`üîß PROP ${key} (${type}) = ${JSON.stringify(value)}`);
        }

        async function executeDSLChoice(props, statement) {
            const key = props.Key;
            if (!key) throw new Error('CHOICE: Key is required');
            
            // Extract PICK options from statement children
            const options = [];
            if (statement.children) {
                statement.children.forEach(child => {
                    if (child.type === 'PICK') {
                        options.push({
                            key: child.properties.Key,
                            description: child.properties.Description
                        });
                    }
                });
            }
            
            if (options.length === 0) {
                addPlanExecutionLog(`‚ö†Ô∏è CHOICE ${key} has no options`);
                return;
            }
            
            addPlanExecutionLog(`üîò CHOICE ${key} with ${options.length} options`);
            
            // Show choice modal
            try {
                const choice = await showChoiceModal(key, options);
                planExecutionState.variables.set(key, choice);
                addPlanExecutionLog(`üë§ User selected: ${choice}`);
            } catch (error) {
                addPlanExecutionLog(`‚ùå Choice cancelled: ${error.message}`);
                throw error;
            }
        }

        async function executeDSLPrompt(props, statement) {
            const key = props.Key;
            if (!key) throw new Error('PROMPT: Key is required');
            
            let promptText = '';
            
            // Build prompt from SECTION children
            if (statement.children) {
                statement.children.forEach(section => {
                    if (section.type === 'SECTION') {
                        const sectionType = section.properties.Type || 'user';
                        promptText += `[${sectionType.toUpperCase()}]\n`;
                        
                        if (section.children) {
                            section.children.forEach(line => {
                                if (line.type === 'LINE') {
                                    const lineText = interpolateDSLTemplate(line.properties.Template || '');
                                    promptText += lineText + '\n';
                                }
                            });
                        }
                        promptText += '\n';
                    }
                });
            }
            
            addPlanExecutionLog(`üí≠ Built prompt ${key}: ${promptText.length} characters`);
            
            // Store prompt for later GENERATE use
            planExecutionState.variables.set(key, promptText);
            return promptText;
        }

        async function executeDSLReturn(props) {
            const template = props.Template;
            const type = props.Type || 'STRING';
            
            let returnValue = interpolateDSLTemplate(template || '');
            
            // Type conversion
            switch (type) {
                case 'INTEGER':
                    returnValue = parseInt(returnValue, 10) || 0;
                    break;
                case 'DOUBLE':
                    returnValue = parseFloat(returnValue) || 0.0;
                    break;
                case 'BOOL':
                    returnValue = returnValue === 'true' || returnValue === '1';
                    break;
                default:
                    returnValue = String(returnValue);
            }
            
            addPlanExecutionLog(`üîÑ RETURN ${type}: ${JSON.stringify(returnValue)}`);
            return returnValue;
        }

        async function executeDSLWhileStatement(props, statement) {
            const key = props.Key;
            const conditionType = props.ConditionType || 'Equal';
            const compareValue = interpolateDSLTemplate(props.Template || '');
            
            if (!key) throw new Error('WHILE: Key is required');
            
            let iterations = 0;
            const maxIterations = 100;
            
            addPlanExecutionLog(`üîÅ Starting WHILE loop: ${key} ${conditionType} "${compareValue}"`);
            
            while (iterations < maxIterations && planExecutionState.isRunning) {
                const actualValue = String(planExecutionState.variables.get(key) || '');
                let conditionMet = false;
                
                switch (conditionType) {
                    case 'Equal':
                        conditionMet = actualValue === compareValue;
                        break;
                    case 'NotEqual':
                        conditionMet = actualValue !== compareValue;
                        break;
                    case 'GreaterThan':
                        conditionMet = parseFloat(actualValue) > parseFloat(compareValue);
                        break;
                    case 'LessThan':
                        conditionMet = parseFloat(actualValue) < parseFloat(compareValue);
                        break;
                }
                
                if (!conditionMet) {
                    addPlanExecutionLog(`üîÅ WHILE condition false, exiting loop after ${iterations} iterations`);
                    break;
                }
                
                addPlanExecutionLog(`üîÅ WHILE iteration ${iterations + 1}`);
                
                // Execute body statements (would need to parse statement children)
                // For now, just increment a counter to prevent infinite loops
                if (statement.children && statement.children.length > 0) {
                    // Execute child statements here
                    addPlanExecutionLog(`‚ö†Ô∏è WHILE body execution not fully implemented`);
                }
                
                iterations++;
                await sleep(100);
                
                // Safety break for demo
                if (iterations >= 3) {
                    addPlanExecutionLog(`üõ°Ô∏è WHILE loop limited to 3 iterations for demo`);
                    break;
                }
            }
            
            if (iterations >= maxIterations) {
                addPlanExecutionLog(`‚ö†Ô∏è WHILE loop reached maximum iterations (${maxIterations})`);
            }
        }

        async function executeDSLSwitch(props, statement) {
            const key = props.Key;
            if (!key) throw new Error('SWITCH: Key is required');
            
            const switchValue = String(planExecutionState.variables.get(key) || '');
            addPlanExecutionLog(`üîÄ SWITCH on ${key} = "${switchValue}"`);
            
            // Find matching CASE
            if (statement.children) {
                for (const child of statement.children) {
                    if (child.type === 'CASE') {
                        const caseValue = child.properties.Template || '';
                        if (switchValue === caseValue) {
                            addPlanExecutionLog(`‚úÖ Matched CASE: ${caseValue}`);
                            
                            // Execute case body (would need child statement execution)
                            if (child.children && child.children.length > 0) {
                                addPlanExecutionLog(`‚ö†Ô∏è CASE body execution not fully implemented`);
                            }
                            return;
                        }
                    }
                }
            }
            
            addPlanExecutionLog(`üîÄ No matching CASE found for "${switchValue}"`);
        }

        // Choice Modal
        function showChoiceModal(key, options) {
            return new Promise((resolve, reject) => {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                
                let optionsHtml = '';
                options.forEach(option => {
                    optionsHtml += `
                        <div class="choice-option" onclick="selectChoice('${option.key}')">
                            <strong>${option.key}</strong>
                            <div style="font-size: 13px; color: var(--text-muted);">${option.description}</div>
                        </div>
                    `;
                });
                
                modal.innerHTML = `
                    <div class="modal-dialog">
                        <div class="modal-header">
                            <h3>Make a Choice: ${key}</h3>
                        </div>
                        <div class="modal-body">
                            <div class="choice-options">
                                ${optionsHtml}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').reject('cancelled')">Cancel</button>
                        </div>
                    </div>
                `;
                
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center;
                    z-index: 10000;
                `;
                
                // Add choice option styling
                const style = document.createElement('style');
                style.textContent = `
                    .choice-options { display: flex; flex-direction: column; gap: 8px; }
                    .choice-option { 
                        padding: 12px 16px; border: 2px solid var(--border); border-radius: var(--radius);
                        cursor: pointer; transition: all 0.2s; background: var(--surface);
                    }
                    .choice-option:hover { 
                        border-color: var(--primary); background: var(--surface-2); 
                    }
                `;
                document.head.appendChild(style);
                
                modal.resolve = resolve;
                modal.reject = reject;
                
                window.selectChoice = function(choiceKey) {
                    document.body.removeChild(modal);
                    document.head.removeChild(style);
                    resolve(choiceKey);
                    delete window.selectChoice;
                };
                
                document.body.appendChild(modal);
            });
        }

        // Initialize the application
        init();
    </script>
</body>
</html>