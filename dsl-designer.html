<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enterprise DSL Designer - Multi-Layer Visual Designer</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --secondary: #64748b;
            --accent: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --background: #ffffff;
            --surface: #f8fafc;
            --surface-2: #f1f5f9;
            --surface-3: #e2e8f0;
            --border: #e2e8f0;
            --text: #0f172a;
            --text-muted: #64748b;
            --text-light: #94a3b8;
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --radius: 8px;
            --radius-lg: 12px;
        }

        .dark {
            --primary: #3b82f6;
            --primary-dark: #2563eb;
            --secondary: #6b7280;
            --accent: #a855f7;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --background: #0f172a;
            --surface: #1e293b;
            --surface-2: #334155;
            --surface-3: #475569;
            --border: #334155;
            --text: #f8fafc;
            --text-muted: #94a3b8;
            --text-light: #64748b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--background);
            color: var(--text);
            line-height: 1.5;
            overflow: hidden;
        }

        /* Main Layout */
        .designer-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: var(--background);
        }

        /* Header */
        .designer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 24px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            box-shadow: var(--shadow);
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 700;
            font-size: 18px;
            color: var(--primary);
        }

        .plan-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border: none;
            border-radius: var(--radius);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-secondary {
            background: var(--surface-2);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--surface-3);
        }

        .btn-icon {
            padding: 8px;
            background: transparent;
            color: var(--text-muted);
        }

        .btn-icon:hover {
            background: var(--surface-2);
            color: var(--text);
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            overflow-x: auto;
        }

        .tab-button {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 16px 24px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .tab-button:hover {
            background: var(--surface-2);
            color: var(--text);
        }

        .tab-button.active {
            background: var(--surface-2);
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .tab-badge {
            background: var(--primary);
            color: white;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 18px;
            text-align: center;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .tab-content {
            flex: 1;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .tab-content.active {
            display: flex;
        }

        /* Plan Overview Tab */
        .plan-overview {
            padding: 24px;
            overflow-y: auto;
        }

        .overview-section {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 24px;
            margin-bottom: 24px;
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .section-icon {
            width: 40px;
            height: 40px;
            background: var(--primary);
            color: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text);
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text);
        }

        .form-input, .form-textarea, .form-select {
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--background);
            color: var(--text);
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .form-input:focus, .form-textarea:focus, .form-select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgb(37 99 235 / 0.1);
        }

        .form-textarea {
            min-height: 80px;
            resize: vertical;
        }

        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .stat-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Agents Tab */
        .agents-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .agents-sidebar {
            width: 280px;
            background: var(--surface);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 12px;
        }

        .agent-search {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--background);
            color: var(--text);
            font-size: 14px;
        }

        .agents-list {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .agent-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: background-color 0.2s;
            margin-bottom: 8px;
        }

        .agent-item:hover {
            background: var(--surface-2);
        }

        .agent-item.selected {
            background: var(--primary);
            color: white;
        }

        .agent-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
        }

        .agent-orchestrator { background: #8b5cf6; }
        .agent-tool { background: #10b981; }
        .agent-ai { background: #f59e0b; }
        .agent-data { background: #3b82f6; }

        .agent-details {
            flex: 1;
            min-width: 0;
        }

        .agent-name {
            font-size: 14px;
            font-weight: 500;
            color: inherit;
            margin-bottom: 2px;
        }

        .agent-purpose {
            font-size: 12px;
            color: var(--text-muted);
        }

        .agent-item.selected .agent-purpose {
            color: rgba(255, 255, 255, 0.8);
        }

        .agents-workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .workspace-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
        }

        .workspace-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
        }

        .workspace-actions {
            display: flex;
            gap: 8px;
        }

        .agent-canvas {
            flex: 1;
            position: relative;
            background: var(--background);
            overflow: auto;
            background-image: 
                radial-gradient(circle, var(--border) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Store Tab */
        .store-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .store-tree {
            width: 350px;
            background: var(--surface);
            border-right: 1px solid var(--border);
            overflow-y: auto;
        }

        .tree-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        .tree-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .tree-item:hover {
            background: var(--surface-2);
        }

        .tree-item.selected {
            background: var(--primary);
            color: white;
        }

        .tree-indent {
            width: 20px;
        }

        .store-editor {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
        }

        .editor-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        /* Import/Export Tab */
        .import-export {
            padding: 24px;
            overflow-y: auto;
        }

        .xml-editor {
            width: 100%;
            height: 400px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 16px;
            background: var(--surface);
            color: var(--text);
            resize: vertical;
        }

        /* Visual Components */
        .node {
            position: absolute;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            min-width: 200px;
            max-width: 300px;
            box-shadow: var(--shadow);
            cursor: move;
            transition: all 0.2s;
        }

        .node:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }

        .node.selected {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgb(37 99 235 / 0.1);
        }

        .node-header {
            padding: 12px 16px;
            background: var(--surface-2);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .node-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
        }

        .node-body {
            padding: 16px;
        }

        .node-field {
            margin-bottom: 12px;
        }

        .node-field:last-child {
            margin-bottom: 0;
        }

        .node-field label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .node-field input,
        .node-field textarea,
        .node-field select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--background);
            color: var(--text);
            font-size: 13px;
        }

        .node-field textarea {
            min-height: 60px;
            resize: vertical;
        }

        /* Connection handles */
        .handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--primary);
            border: 2px solid white;
            border-radius: 50%;
            cursor: crosshair;
        }

        .handle.in {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .handle.out {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Status indicators */
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-ready {
            background: var(--surface-2);
            color: var(--text-muted);
        }

        .status-running {
            background: #dbeafe;
            color: #1d4ed8;
        }

        .status-completed {
            background: #d1fae5;
            color: #065f46;
        }

        .status-error {
            background: #fee2e2;
            color: #dc2626;
        }

        /* Visual Designer */
        .visual-designer {
            display: flex;
            height: 100%;
            background: var(--background);
        }

        .designer-palette {
            width: 280px;
            background: var(--surface);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .palette-header {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .palette-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 12px;
        }

        .palette-search {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--background);
            color: var(--text);
            font-size: 13px;
        }

        .palette-sections {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .palette-section {
            margin-bottom: 24px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .palette-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: var(--radius);
            cursor: grab;
            transition: all 0.2s;
            margin-bottom: 4px;
            border: 1px solid transparent;
        }

        .palette-item:hover {
            background: var(--surface-2);
            border-color: var(--border);
        }

        .palette-item:active {
            cursor: grabbing;
        }

        .palette-item i {
            font-size: 18px;
            color: var(--primary);
        }

        .palette-item span {
            font-size: 13px;
            font-weight: 500;
            color: var(--text);
        }

        .designer-workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .workspace-toolbar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .toolbar-divider {
            width: 1px;
            height: 20px;
            background: var(--border);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zoom-level {
            font-size: 13px;
            color: var(--text-muted);
            min-width: 40px;
            text-align: center;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: var(--background);
            overflow: hidden;
            background-image: 
                radial-gradient(circle, var(--border) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .connection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .statement-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        .designer-inspector {
            width: 320px;
            background: var(--surface);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .inspector-header {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .inspector-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
        }

        .inspector-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .inspector-empty {
            text-align: center;
            color: var(--text-muted);
            font-style: italic;
            padding: 40px 20px;
        }

        .inspector-section {
            border-top: 1px solid var(--border);
            padding: 16px;
        }

        .inspector-section h5 {
            font-size: 13px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 12px;
        }

        /* Statement Nodes */
        .statement-node {
            position: absolute;
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            min-width: 180px;
            max-width: 280px;
            box-shadow: var(--shadow);
            cursor: move;
            z-index: 10;
            transition: all 0.2s;
        }

        .statement-node:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-1px);
        }

        .statement-node.selected {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgb(37 99 235 / 0.1);
        }

        .statement-node.executing {
            border-color: var(--warning);
            box-shadow: 0 0 0 3px rgb(245 158 11 / 0.2);
            animation: pulse 1.5s infinite;
        }

        .statement-node.completed {
            border-color: var(--success);
        }

        .statement-node.error {
            border-color: var(--error);
        }

        .node-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            border-radius: var(--radius) var(--radius) 0 0;
        }

        .node-type {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text);
        }

        .node-type i {
            font-size: 16px;
            color: var(--primary);
        }

        .node-actions {
            display: flex;
            gap: 4px;
        }

        .node-action {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .node-action:hover {
            background: var(--surface-2);
            color: var(--text);
        }

        .node-action i {
            font-size: 16px;
        }

        .node-body {
            padding: 12px;
        }

        .node-summary {
            font-size: 12px;
            color: var(--text-muted);
            line-height: 1.4;
        }

        .node-key {
            font-size: 11px;
            color: var(--primary);
            font-weight: 500;
            margin-bottom: 2px;
        }

        /* Connection Points */
        .connection-point {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--primary);
            border: 2px solid var(--background);
            border-radius: 50%;
            cursor: crosshair;
            z-index: 20;
        }

        .connection-point.input {
            left: -5px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-point.output {
            right: -5px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-point:hover {
            background: var(--primary-dark);
            transform: translateY(-50%) scale(1.2);
        }

        /* Property Forms */
        .property-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .property-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .property-label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text);
        }

        .property-input, .property-textarea, .property-select {
            padding: 8px 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--background);
            color: var(--text);
            font-size: 13px;
        }

        .property-textarea {
            min-height: 60px;
            resize: vertical;
        }

        .property-help {
            font-size: 11px;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Variables List */
        .variable-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--surface-2);
            border-radius: 4px;
            margin-bottom: 4px;
        }

        .variable-name {
            font-size: 12px;
            font-weight: 500;
            color: var(--text);
        }

        .variable-type {
            font-size: 11px;
            color: var(--text-muted);
            background: var(--surface-3);
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .agents-sidebar {
                width: 240px;
            }
            
            .store-tree {
                width: 280px;
            }
            
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .visual-designer {
                flex-direction: column;
            }

            .designer-palette {
                width: 100%;
                height: 200px;
                border-right: none;
                border-bottom: 1px solid var(--border);
            }

            .designer-inspector {
                width: 100%;
                height: 200px;
                border-left: none;
                border-top: 1px solid var(--border);
            }
        }

        /* Animation classes */
        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            padding: 8px 0;
            z-index: 1000;
            min-width: 160px;
        }

        .context-menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text);
            transition: background-color 0.2s;
        }

        .context-menu-item:hover {
            background: var(--surface-2);
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        /* Execution UI */
        .execution-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .execution-dialog {
            background: var(--surface);
            border-radius: var(--radius-lg);
            width: 80vw;
            max-width: 900px;
            height: 70vh;
            box-shadow: var(--shadow-lg);
            display: flex;
            flex-direction: column;
        }

        .execution-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .execution-header h3 {
            margin: 0;
            color: var(--text);
            font-size: 18px;
        }

        .execution-body {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .execution-log {
            flex: 2;
            padding: 16px;
            overflow-y: auto;
            background: var(--background);
            border-right: 1px solid var(--border);
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .execution-output {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            background: var(--surface-2);
        }

        .execution-footer {
            padding: 20px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        /* Seed Editor Styles */
        .seed-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .seed-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .seed-items {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .seed-item {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            overflow: hidden;
        }

        .seed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--surface-2);
            border-bottom: 1px solid var(--border);
        }

        .seed-key {
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            color: var(--primary);
        }

        .seed-actions {
            display: flex;
            gap: 4px;
        }

        .seed-value {
            padding: 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            background: var(--background);
            white-space: pre-wrap;
            overflow-x: auto;
        }

        .empty-state {
            text-align: center;
            color: var(--text-muted);
            padding: 60px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .empty-state .material-icons {
            font-size: 64px;
            opacity: 0.3;
        }

        .empty-title {
            font-size: 18px;
            font-weight: 600;
        }

        .empty-description {
            font-size: 14px;
            max-width: 400px;
            line-height: 1.5;
        }

        .btn-icon {
            background: none;
            border: none;
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: var(--surface-3);
            color: var(--text);
        }
    </style>
</head>
<body>
    <div class="designer-container">
        <!-- Header -->
        <header class="designer-header">
            <div class="header-left">
                <div class="logo">
                    <i class="material-icons">account_tree</i>
                    <span>Enterprise DSL Designer</span>
                </div>
                <div class="plan-title" id="planTitle">Untitled Plan</div>
            </div>
            <div class="header-actions">
                <button class="btn btn-secondary" id="importBtn">
                    <i class="material-icons">upload</i>
                    Import XML
                </button>
                <button class="btn btn-secondary" id="exportBtn">
                    <i class="material-icons">download</i>
                    Export XML
                </button>
                <button class="btn btn-primary" id="executeBtn">
                    <i class="material-icons">play_arrow</i>
                    Execute Plan
                </button>
                <button class="btn btn-icon" id="themeBtn">
                    <i class="material-icons">dark_mode</i>
                </button>
            </div>
        </header>

        <!-- Tab Navigation -->
        <nav class="tab-nav">
            <button class="tab-button active" data-tab="plan">
                <i class="material-icons">description</i>
                Plan Overview
            </button>
            <button class="tab-button" data-tab="agents">
                <i class="material-icons">smart_toy</i>
                Agents
                <span class="tab-badge" id="agentCount">0</span>
            </button>
            <button class="tab-button" data-tab="store">
                <i class="material-icons">folder</i>
                Store
                <span class="tab-badge" id="storeCount">0</span>
            </button>
            <button class="tab-button" data-tab="schema">
                <i class="material-icons">schema</i>
                Schema
            </button>
            <button class="tab-button" data-tab="seed">
                <i class="material-icons">grass</i>
                Seed
            </button>
            <button class="tab-button" data-tab="import-export">
                <i class="material-icons">code</i>
                XML Source
            </button>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Plan Overview Tab -->
            <div class="tab-content active" id="planTab">
                <div class="plan-overview">
                    <div class="overview-section fade-in">
                        <div class="section-header">
                            <div class="section-icon">
                                <i class="material-icons">info</i>
                            </div>
                            <div class="section-title">Plan Information</div>
                        </div>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Plan Key</label>
                                <input type="text" class="form-input" id="planKey" placeholder="e.g., IntelligentKnowledgeExplorer">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Author</label>
                                <input type="text" class="form-input" id="planAuthor" placeholder="e.g., Knowledge Engineer">
                            </div>
                            <div class="form-group" style="grid-column: 1 / -1;">
                                <label class="form-label">Description</label>
                                <textarea class="form-textarea" id="planDescription" placeholder="Describe the purpose and functionality of this plan..."></textarea>
                            </div>
                        </div>
                    </div>

                    <div class="overview-section fade-in">
                        <div class="section-header">
                            <div class="section-icon">
                                <i class="material-icons">analytics</i>
                            </div>
                            <div class="section-title">Plan Statistics</div>
                        </div>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-value" id="totalAgents">0</div>
                                <div class="stat-label">Total Agents</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="orchestratorAgents">0</div>
                                <div class="stat-label">Orchestrators</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="toolAgents">0</div>
                                <div class="stat-label">Tools</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="aiAgents">0</div>
                                <div class="stat-label">AI Agents</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="storeFiles">0</div>
                                <div class="stat-label">Store Files</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="totalStatements">0</div>
                                <div class="stat-label">Statements</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Agents Tab -->
            <div class="tab-content" id="agentsTab">
                <div class="agents-container">
                    <div class="agents-sidebar">
                        <div class="sidebar-header">
                            <div class="sidebar-title">Agents</div>
                            <input type="text" class="agent-search" placeholder="Search agents..." id="agentSearch">
                        </div>
                        <div class="agents-list" id="agentsList">
                            <!-- Agents will be populated here -->
                        </div>
                        <div style="padding: 16px; border-top: 1px solid var(--border);">
                            <button class="btn btn-primary" style="width: 100%; justify-content: center;" id="addAgentBtn">
                                <i class="material-icons">add</i>
                                Add Agent
                            </button>
                        </div>
                    </div>
                    <div class="agents-workspace">
                        <div class="workspace-header">
                            <div class="workspace-title" id="selectedAgentTitle">Select an agent to edit</div>
                            <div class="workspace-actions">
                                <button class="btn btn-secondary" id="zoomOutBtn">
                                    <i class="material-icons">zoom_out</i>
                                </button>
                                <button class="btn btn-secondary" id="zoomInBtn">
                                    <i class="material-icons">zoom_in</i>
                                </button>
                                <button class="btn btn-secondary" id="centerViewBtn">
                                    <i class="material-icons">center_focus_strong</i>
                                </button>
                            </div>
                        </div>
                        <div class="agent-canvas" id="agentCanvas">
                            <!-- Agent visual editor will be here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Store Tab -->
            <div class="tab-content" id="storeTab">
                <div class="store-container">
                    <div class="store-tree">
                        <div class="tree-header">
                            <div class="sidebar-title">Store Structure</div>
                            <button class="btn btn-primary" style="width: 100%; margin-top: 12px; justify-content: center;" id="addStoreBtn">
                                <i class="material-icons">add</i>
                                Add Store
                            </button>
                        </div>
                        <div id="storeTree">
                            <!-- Store tree will be populated here -->
                        </div>
                    </div>
                    <div class="store-editor">
                        <div class="editor-header">
                            <div class="workspace-title" id="selectedStoreTitle">Select a store item to edit</div>
                        </div>
                        <div class="editor-content" id="storeEditorContent">
                            <!-- Store editor will be here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Schema Tab -->
            <div class="tab-content" id="schemaTab">
                <div class="plan-overview">
                    <div class="overview-section fade-in">
                        <div class="section-header">
                            <div class="section-icon">
                                <i class="material-icons">schema</i>
                            </div>
                            <div class="section-title">Schema Definitions</div>
                        </div>
                        <p style="color: var(--text-muted); margin-bottom: 20px;">
                            Define data schemas and types used across your DSL plan.
                        </p>
                        <div id="schemaEditor">
                            <!-- Schema editor will be populated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Seed Tab -->
            <div class="tab-content" id="seedTab">
                <div class="plan-overview">
                    <div class="overview-section fade-in">
                        <div class="section-header">
                            <div class="section-icon">
                                <i class="material-icons">grass</i>
                            </div>
                            <div class="section-title">Seed Data</div>
                        </div>
                        <p style="color: var(--text-muted); margin-bottom: 20px;">
                            Define initial data values and configurations for your DSL plan.
                        </p>
                        <div class="seed-container">
                            <div class="seed-controls">
                                <button class="btn btn-primary" id="addSeedBtn">
                                    <i class="material-icons">add</i>
                                    Add Seed Item
                                </button>
                                <button class="btn btn-secondary" id="importSeedBtn">
                                    <i class="material-icons">upload</i>
                                    Import JSON
                                </button>
                                <button class="btn btn-secondary" id="exportSeedBtn">
                                    <i class="material-icons">download</i>
                                    Export JSON
                                </button>
                            </div>
                            <div id="seedEditor">
                                <!-- Seed editor will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Import/Export Tab -->
            <div class="tab-content" id="importExportTab">
                <div class="import-export">
                    <div class="overview-section fade-in">
                        <div class="section-header">
                            <div class="section-icon">
                                <i class="material-icons">code</i>
                            </div>
                            <div class="section-title">XML Source</div>
                        </div>
                        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
                            <button class="btn btn-secondary" id="formatXmlBtn">
                                <i class="material-icons">format_align_left</i>
                                Format XML
                            </button>
                            <button class="btn btn-secondary" id="validateXmlBtn">
                                <i class="material-icons">check_circle</i>
                                Validate XML
                            </button>
                            <button class="btn btn-primary" id="syncFromXmlBtn">
                                <i class="material-icons">sync</i>
                                Sync from XML
                            </button>
                        </div>
                        <textarea class="xml-editor" id="xmlEditor" placeholder="Paste your DSL XML here or use Import XML button..."></textarea>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Hidden file input for XML import -->
    <input type="file" id="fileInput" accept=".xml" style="display: none;">

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu" style="display: none;">
        <div class="context-menu-item" data-action="edit">
            <i class="material-icons">edit</i>
            Edit
        </div>
        <div class="context-menu-item" data-action="duplicate">
            <i class="material-icons">content_copy</i>
            Duplicate
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="delete" style="color: var(--error);">
            <i class="material-icons">delete</i>
            Delete
        </div>
    </div>

    <script type="module">
        console.log('🏗️ Enterprise DSL Designer Loading...');
        
        // Core State Management
        let currentPlan = {
            key: '',
            description: '',
            author: '',
            agents: new Map(),
            stores: new Map(),
            schemas: new Map(),
            seed: new Map()
        };
        
        let currentTab = 'plan';
        let selectedAgent = null;
        let selectedStore = null;
        
        // Initialize the designer
        function init() {
            setupTabNavigation();
            setupEventListeners();
            updateStatistics();
            
            console.log('✅ Enterprise DSL Designer Ready');
        }
        
        // Tab Navigation
        function setupTabNavigation() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.dataset.tab;
                    
                    // Update active states
                    tabButtons.forEach(b => b.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    button.classList.add('active');
                    document.getElementById(tabId + 'Tab').classList.add('active');
                    
                    currentTab = tabId;
                    
                    // Load tab-specific content
                    loadTabContent(tabId);
                });
            });
        }
        
        // Load content for specific tab
        function loadTabContent(tabId) {
            switch(tabId) {
                case 'plan':
                    loadPlanOverview();
                    break;
                case 'agents':
                    loadAgentsView();
                    break;
                case 'store':
                    loadStoreView();
                    break;
                case 'schema':
                    loadSchemaView();
                    break;
                case 'seed':
                    loadSeedView();
                    break;
                case 'import-export':
                    loadImportExportView();
                    break;
            }
        }
        
        // Plan Overview
        function loadPlanOverview() {
            const planKey = document.getElementById('planKey');
            const planDescription = document.getElementById('planDescription');
            const planAuthor = document.getElementById('planAuthor');
            
            planKey.value = currentPlan.key;
            planDescription.value = currentPlan.description;
            planAuthor.value = currentPlan.author;
            
            // Update plan title in header
            document.getElementById('planTitle').textContent = currentPlan.key || 'Untitled Plan';
            
            updateStatistics();
        }
        
        // Update statistics
        function updateStatistics() {
            const stats = calculatePlanStatistics();
            
            document.getElementById('totalAgents').textContent = stats.totalAgents;
            document.getElementById('orchestratorAgents').textContent = stats.orchestrators;
            document.getElementById('toolAgents').textContent = stats.tools;
            document.getElementById('aiAgents').textContent = stats.aiAgents;
            document.getElementById('storeFiles').textContent = stats.storeFiles;
            document.getElementById('totalStatements').textContent = stats.totalStatements;
            
            // Update tab badges
            document.getElementById('agentCount').textContent = stats.totalAgents;
            document.getElementById('storeCount').textContent = stats.storeFiles;
        }
        
        function calculatePlanStatistics() {
            let orchestrators = 0, tools = 0, aiAgents = 0, totalStatements = 0;
            
            currentPlan.agents.forEach(agent => {
                switch(agent.purpose?.toLowerCase()) {
                    case 'orchestrator': orchestrators++; break;
                    case 'tool': tools++; break;
                    case 'ai': aiAgents++; break;
                }
                totalStatements += agent.statements?.length || 0;
            });
            
            return {
                totalAgents: currentPlan.agents.size,
                orchestrators,
                tools,
                aiAgents,
                storeFiles: currentPlan.stores.size,
                totalStatements
            };
        }
        
        // Agents View
        function loadAgentsView() {
            const agentsList = document.getElementById('agentsList');
            agentsList.innerHTML = '';
            
            if (currentPlan.agents.size === 0) {
                agentsList.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: var(--text-muted);">
                        <i class="material-icons" style="font-size: 48px; margin-bottom: 16px;">smart_toy</i>
                        <div style="font-size: 16px; margin-bottom: 8px;">No agents yet</div>
                        <div style="font-size: 14px;">Click "Add Agent" to create your first agent</div>
                    </div>
                `;
                return;
            }
            
            currentPlan.agents.forEach((agent, key) => {
                const agentItem = createAgentListItem(key, agent);
                agentsList.appendChild(agentItem);
            });
        }
        
        function createAgentListItem(key, agent) {
            const item = document.createElement('div');
            item.className = 'agent-item';
            item.dataset.agentKey = key;
            
            const purposeClass = `agent-${(agent.purpose || 'tool').toLowerCase()}`;
            const purposeIcon = getPurposeIcon(agent.purpose);
            
            item.innerHTML = `
                <div class="agent-icon ${purposeClass}">
                    <i class="material-icons">${purposeIcon}</i>
                </div>
                <div class="agent-details">
                    <div class="agent-name">${key}</div>
                    <div class="agent-purpose">${agent.purpose || 'Tool'}</div>
                </div>
            `;
            
            item.addEventListener('click', () => selectAgent(key));
            
            return item;
        }
        
        function getPurposeIcon(purpose) {
            switch(purpose?.toLowerCase()) {
                case 'orchestrator': return 'account_tree';
                case 'tool': return 'build';
                case 'ai': return 'psychology';
                case 'data': return 'storage';
                default: return 'smart_toy';
            }
        }
        
        function selectAgent(key) {
            selectedAgent = key;
            
            // Update UI
            document.querySelectorAll('.agent-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.querySelector(`[data-agent-key="${key}"]`).classList.add('selected');
            
            document.getElementById('selectedAgentTitle').textContent = `Agent: ${key}`;
            
            // Load agent canvas
            loadAgentCanvas(key);
        }
        
        function loadAgentCanvas(agentKey) {
            const canvas = document.getElementById('agentCanvas');
            const agent = currentPlan.agents.get(agentKey);
            
            if (!agent) return;
            
            // Create visual designer canvas
            canvas.innerHTML = `
                <div class="visual-designer">
                    <div class="designer-palette">
                        <div class="palette-header">
                            <h4>DSL Statements</h4>
                            <input type="text" class="palette-search" placeholder="Search statements...">
                        </div>
                        <div class="palette-sections">
                            <div class="palette-section">
                                <div class="section-title">Variables & Data</div>
                                <div class="palette-item" data-type="declare">
                                    <i class="material-icons">create</i>
                                    <span>DECLARE</span>
                                </div>
                                <div class="palette-item" data-type="prop">
                                    <i class="material-icons">input</i>
                                    <span>PROP</span>
                                </div>
                                <div class="palette-item" data-type="assign">
                                    <i class="material-icons">assignment</i>
                                    <span>ASSIGN</span>
                                </div>
                            </div>
                            <div class="palette-section">
                                <div class="section-title">User Interaction</div>
                                <div class="palette-item" data-type="in">
                                    <i class="material-icons">input</i>
                                    <span>IN</span>
                                </div>
                                <div class="palette-item" data-type="out">
                                    <i class="material-icons">message</i>
                                    <span>OUT</span>
                                </div>
                                <div class="palette-item" data-type="choice">
                                    <i class="material-icons">radio_button_checked</i>
                                    <span>CHOICE</span>
                                </div>
                            </div>
                            <div class="palette-section">
                                <div class="section-title">Control Flow</div>
                                <div class="palette-item" data-type="if">
                                    <i class="material-icons">call_split</i>
                                    <span>IF</span>
                                </div>
                                <div class="palette-item" data-type="while">
                                    <i class="material-icons">loop</i>
                                    <span>WHILE</span>
                                </div>
                                <div class="palette-item" data-type="switch">
                                    <i class="material-icons">alt_route</i>
                                    <span>SWITCH</span>
                                </div>
                                <div class="palette-item" data-type="case">
                                    <i class="material-icons">arrow_forward</i>
                                    <span>CASE</span>
                                </div>
                            </div>
                            <div class="palette-section">
                                <div class="section-title">Agent Communication</div>
                                <div class="palette-item" data-type="call">
                                    <i class="material-icons">call</i>
                                    <span>CALL</span>
                                </div>
                                <div class="palette-item" data-type="return">
                                    <i class="material-icons">keyboard_return</i>
                                    <span>RETURN</span>
                                </div>
                            </div>
                            <div class="palette-section">
                                <div class="section-title">AI & Generation</div>
                                <div class="palette-item" data-type="prompt">
                                    <i class="material-icons">chat</i>
                                    <span>PROMPT</span>
                                </div>
                                <div class="palette-item" data-type="generate">
                                    <i class="material-icons">auto_awesome</i>
                                    <span>GENERATE</span>
                                </div>
                            </div>
                            <div class="palette-section">
                                <div class="section-title">File Operations</div>
                                <div class="palette-item" data-type="read">
                                    <i class="material-icons">file_open</i>
                                    <span>READ</span>
                                </div>
                                <div class="palette-item" data-type="write">
                                    <i class="material-icons">save</i>
                                    <span>WRITE</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="designer-workspace">
                        <div class="workspace-toolbar">
                            <button class="btn btn-secondary" id="zoomToFit">
                                <i class="material-icons">zoom_out_map</i>
                                Zoom to Fit
                            </button>
                            <button class="btn btn-secondary" id="runAgent">
                                <i class="material-icons">play_arrow</i>
                                Run Agent
                            </button>
                            <div class="toolbar-divider"></div>
                            <div class="zoom-controls">
                                <button class="btn btn-icon" id="zoomOut">
                                    <i class="material-icons">zoom_out</i>
                                </button>
                                <span class="zoom-level">100%</span>
                                <button class="btn btn-icon" id="zoomIn">
                                    <i class="material-icons">zoom_in</i>
                                </button>
                            </div>
                        </div>
                        <div class="canvas-container" id="canvasContainer">
                            <svg class="connection-svg" id="connectionSvg">
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="var(--primary)"/>
                                    </marker>
                                </defs>
                            </svg>
                            <div class="statement-canvas" id="statementCanvas">
                                <!-- Visual statements will be added here -->
                            </div>
                        </div>
                    </div>
                    <div class="designer-inspector">
                        <div class="inspector-header">
                            <h4>Properties</h4>
                        </div>
                        <div class="inspector-content" id="inspectorContent">
                            <div class="inspector-empty">
                                Select a statement to edit properties
                            </div>
                        </div>
                        <div class="inspector-section">
                            <h5>Agent Variables</h5>
                            <div class="variables-list" id="agentVariables">
                                <!-- Variables will be listed here -->
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Initialize the visual designer for this agent
            initializeVisualDesigner(agentKey);
        }
        
        // Store View
        function loadStoreView() {
            const storeTree = document.getElementById('storeTree');
            storeTree.innerHTML = '';
            
            if (currentPlan.stores.size === 0) {
                storeTree.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: var(--text-muted);">
                        <i class="material-icons" style="font-size: 48px; margin-bottom: 16px;">folder</i>
                        <div style="font-size: 16px; margin-bottom: 8px;">No stores yet</div>
                        <div style="font-size: 14px;">Click "Add Store" to create your first store</div>
                    </div>
                `;
                return;
            }
            
            currentPlan.stores.forEach((store, key) => {
                const storeItem = createStoreTreeItem(key, store);
                storeTree.appendChild(storeItem);
            });
        }
        
        function createStoreTreeItem(key, store) {
            const item = document.createElement('div');
            item.className = 'tree-item';
            item.dataset.storeKey = key;
            
            item.innerHTML = `
                <i class="material-icons">storage</i>
                <span>${key}</span>
            `;
            
            item.addEventListener('click', () => selectStore(key));
            
            return item;
        }
        
        function selectStore(key) {
            selectedStore = key;
            
            // Update UI
            document.querySelectorAll('.tree-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.querySelector(`[data-store-key="${key}"]`).classList.add('selected');
            
            document.getElementById('selectedStoreTitle').textContent = `Store: ${key}`;
            
            // Load store editor
            loadStoreEditor(key);
        }
        
        function loadStoreEditor(storeKey) {
            const editorContent = document.getElementById('storeEditorContent');
            const store = currentPlan.stores.get(storeKey);
            
            if (!store) return;
            
            editorContent.innerHTML = `
                <div style="text-align: center; color: var(--text-muted); padding: 40px;">
                    <i class="material-icons" style="font-size: 64px; margin-bottom: 20px;">construction</i>
                    <div style="font-size: 18px; margin-bottom: 12px;">Store Editor Coming Soon</div>
                    <div style="font-size: 14px;">Visual store structure editor will be implemented here</div>
                    <div style="margin-top: 20px; padding: 20px; background: var(--surface); border-radius: var(--radius); text-align: left;">
                        <strong>Store Details:</strong><br>
                        Key: ${storeKey}<br>
                        Type: Storage Definition
                    </div>
                </div>
            `;
        }
        
        // Schema View
        function loadSchemaView() {
            const schemaEditor = document.getElementById('schemaEditor');
            schemaEditor.innerHTML = `
                <div style="text-align: center; color: var(--text-muted); padding: 40px;">
                    <i class="material-icons" style="font-size: 64px; margin-bottom: 20px;">construction</i>
                    <div style="font-size: 18px; margin-bottom: 12px;">Schema Editor Coming Soon</div>
                    <div style="font-size: 14px;">Data schema definition editor will be implemented here</div>
                </div>
            `;
        }
        
        // Seed View
        function loadSeedView() {
            const seedEditor = document.getElementById('seedEditor');
            
            // Initialize seed data if not exists
            if (!currentPlan.seed) {
                currentPlan.seed = new Map();
            }
            
            let seedHtml = '<div class="seed-items">';
            
            if (currentPlan.seed.size === 0) {
                seedHtml += `
                    <div class="empty-state">
                        <i class="material-icons">grass</i>
                        <div class="empty-title">No Seed Data</div>  
                        <div class="empty-description">Add seed data to initialize your DSL plan with predefined values</div>
                    </div>
                `;
            } else {
                currentPlan.seed.forEach((value, key) => {
                    seedHtml += `
                        <div class="seed-item" data-key="${key}">
                            <div class="seed-header">
                                <div class="seed-key">${key}</div>
                                <div class="seed-actions">
                                    <button class="btn-icon" onclick="editSeedItem('${key}')">
                                        <i class="material-icons">edit</i>
                                    </button>
                                    <button class="btn-icon" onclick="deleteSeedItem('${key}')">
                                        <i class="material-icons">delete</i>
                                    </button>
                                </div>
                            </div>
                            <div class="seed-value">${JSON.stringify(value, null, 2)}</div>
                        </div>
                    `;
                });
            }
            
            seedHtml += '</div>';
            seedEditor.innerHTML = seedHtml;
        }
        
        // Seed Management Functions
        function addSeedItem() {
            const key = prompt('Enter seed key:');
            if (!key) return;
            
            const value = prompt('Enter seed value (JSON):');
            if (value === null) return;
            
            try {
                const parsedValue = JSON.parse(value || '""');
                currentPlan.seed.set(key, parsedValue);
                loadSeedView();
                console.log(`✅ Added seed item: ${key}`);
            } catch (e) {
                alert('Invalid JSON format');
            }
        }
        
        function editSeedItem(key) {
            const currentValue = currentPlan.seed.get(key);
            const newValue = prompt('Edit seed value (JSON):', JSON.stringify(currentValue));
            if (newValue === null) return;
            
            try {
                const parsedValue = JSON.parse(newValue);
                currentPlan.seed.set(key, parsedValue);
                loadSeedView();
                console.log(`✅ Updated seed item: ${key}`);
            } catch (e) {
                alert('Invalid JSON format');
            }
        }
        
        function deleteSeedItem(key) {
            if (confirm(`Delete seed item "${key}"?`)) {
                currentPlan.seed.delete(key);
                loadSeedView();
                console.log(`🗑️ Deleted seed item: ${key}`);
            }
        }
        
        function importSeedData() {
            const jsonStr = prompt('Paste JSON seed data:');
            if (!jsonStr) return;
            
            try {
                const seedData = JSON.parse(jsonStr);
                Object.entries(seedData).forEach(([key, value]) => {
                    currentPlan.seed.set(key, value);
                });
                loadSeedView();
                console.log(`✅ Imported ${Object.keys(seedData).length} seed items`);
            } catch (e) {
                alert('Invalid JSON format');
            }
        }
        
        function exportSeedData() {
            const seedData = {};
            currentPlan.seed.forEach((value, key) => {
                seedData[key] = value;
            });
            
            const jsonStr = JSON.stringify(seedData, null, 2);
            
            // Create download link
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'seed-data.json';
            a.click();
            URL.revokeObjectURL(url);
            
            console.log(`✅ Exported seed data`);
        }
        
        // Import/Export View
        function loadImportExportView() {
            const xmlEditor = document.getElementById('xmlEditor');
            if (xmlEditor.value.trim() === '') {
                xmlEditor.value = generateXML();
            }
        }



        
        // Visual Designer Core
        let visualDesignerState = {
            currentAgent: null,
            nodes: new Map(),
            connections: [],
            selectedNode: null,
            draggedNode: null,
            connecting: null,
            nodeCounter: 1,
            canvasOffset: { x: 0, y: 0 },
            canvasScale: 1,
            isPanning: false,
            lastPanPoint: { x: 0, y: 0 }
        };

        // DSL Statement Templates - Complete RULES.xml Implementation
        const statementTemplates = {
            declare: {
                type: 'DECLARE',
                icon: 'create',
                color: '#3b82f6',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable name' },
                    { name: 'Type', type: 'select', options: ['AUTO', 'UNIQ', 'STRING', 'COLOR', 'EMAIL', 'PASSWORD', 'TEL', 'IMAGE', 'INTEGER', 'DOUBLE', 'FLOAT', 'BOOL', 'ENUM', 'ENUMSTR', 'DATE', 'DATETIME', 'WEEK', 'TIME', 'URL', 'ONE', 'MANY', 'PARENTKEY', 'KEYS', 'NEXTKEY', 'CSV', 'FILE', 'FOLDER'], help: 'Variable type from RULES.xml' },
                    { name: 'ForeignType', type: 'text', help: 'Reference to external type' },
                    { name: 'Expression', type: 'text', help: 'Initial value expression' }
                ]
            },
            prop: {
                type: 'PROP',
                icon: 'input',
                color: '#8b5cf6',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Property name' },
                    { name: 'Type', type: 'select', options: ['STRING', 'INTEGER', 'DOUBLE', 'BOOL'], help: 'Property type' }
                ]
            },
            assign: {
                type: 'ASSIGN',
                icon: 'assignment',
                color: '#10b981',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to assign' },
                    { name: 'Template', type: 'textarea', required: true, help: 'Value template with #variable# interpolation' }
                ]
            },
            in: {
                type: 'IN',
                icon: 'input',
                color: '#ec4899',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store input' },
                    { name: 'Label', type: 'text', required: true, help: 'Prompt for user' },
                    { name: 'Type', type: 'select', options: ['TEXT', 'TEXTAREA', 'CHOICE'], help: 'Input type' },
                    { name: 'Preset', type: 'text', help: 'Default value' }
                ]
            },
            out: {
                type: 'OUT',
                icon: 'message',
                color: '#f59e0b',
                properties: [
                    { name: 'Template', type: 'textarea', required: true, help: 'Output message with #variable# interpolation' }
                ]
            },
            choice: {
                type: 'CHOICE',
                icon: 'radio_button_checked',
                color: '#06b6d4',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Choice identifier' },
                    { name: 'Options', type: 'textarea', help: 'Choice options (one per line)' }
                ]
            },
            if: {
                type: 'IF',
                icon: 'call_split',
                color: '#f97316',
                hasElse: true,
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to check' },
                    { name: 'ConditionType', type: 'select', options: ['Equal', 'NotEqual', 'GreaterThan', 'LessThan'], help: 'Comparison type' },
                    { name: 'Template', type: 'text', required: true, help: 'Value to compare against' }
                ]
            },
            while: {
                type: 'WHILE',
                icon: 'loop',
                color: '#7c3aed',
                hasBody: true,
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to check' },
                    { name: 'ConditionType', type: 'select', options: ['Equal', 'NotEqual', 'GreaterThan', 'LessThan'], help: 'Comparison type' },
                    { name: 'Template', type: 'text', required: true, help: 'Value to compare against' }
                ]
            },
            switch: {
                type: 'SWITCH',
                icon: 'alt_route',
                color: '#e11d48',
                hasMultipleCases: true,
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to switch on' }
                ]
            },
            case: {
                type: 'CASE',
                icon: 'arrow_forward',
                color: '#0ea5e9',
                parentType: 'switch',
                properties: [
                    { name: 'Template', type: 'text', required: true, help: 'Case value to match' }
                ]
            },
            call: {
                type: 'CALL',
                icon: 'call',
                color: '#dc2626',
                properties: [
                    { name: 'Key', type: 'text', help: 'Variable to store result' },
                    { name: 'ToKey', type: 'text', required: true, help: 'Target agent key' },
                    { name: 'Variables', type: 'text', help: 'Variables to pass (comma-separated)' }
                ]
            },
            return: {
                type: 'RETURN',
                icon: 'keyboard_return',
                color: '#059669',
                properties: [
                    { name: 'Type', type: 'select', options: ['STRING', 'INTEGER', 'DOUBLE', 'BOOL'], help: 'Return type' },
                    { name: 'Template', type: 'textarea', required: true, help: 'Return value template' }
                ]
            },
            prompt: {
                type: 'PROMPT',
                icon: 'chat',
                color: '#7c2d12',
                hasChildren: true,
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Prompt identifier' }
                ]
            },
            generate: {
                type: 'GENERATE',
                icon: 'auto_awesome',
                color: '#be185d',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store result' },
                    { name: 'Keys', type: 'text', help: 'Prompt keys to use' },
                    { name: 'MaxTokens', type: 'number', help: 'Maximum tokens to generate' },
                    { name: 'Creativity', type: 'select', options: ['Focused', 'Balanced', 'Creative'], help: 'Generation creativity level' }
                ]
            },
            read: {
                type: 'READ',
                icon: 'file_open',
                color: '#1f2937',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store content' },
                    { name: 'FileKey', type: 'text', required: true, help: 'File identifier to read' }
                ]
            },
            write: {
                type: 'WRITE',
                icon: 'save',
                color: '#374151',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Content to write (variable names)' },
                    { name: 'FileKey', type: 'text', required: true, help: 'File identifier to write to' }
                ]
            },
            // Additional RULES.xml Statement Types
            design: {
                type: 'DESIGN',
                icon: 'design_services',
                color: '#8b5cf6',
                properties: [
                    { name: 'Type', type: 'select', options: ['UI', 'API', 'ARCHITECTURE', 'DATABASE'], help: 'Design type' },
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store design' },
                    { name: 'Template', type: 'textarea', required: true, help: 'Design requirements' }
                ]
            },
            fetch: {
                type: 'FETCH',
                icon: 'download',
                color: '#06b6d4',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store response' },
                    { name: 'Url', type: 'text', required: true, help: 'URL to fetch' },
                    { name: 'Method', type: 'select', options: ['GET', 'POST', 'PUT', 'DELETE'], help: 'HTTP method' },
                    { name: 'Headers', type: 'text', help: 'Request headers (JSON)' },
                    { name: 'Body', type: 'text', help: 'Request body' }
                ]
            },
            sql: {
                type: 'SQL',
                icon: 'storage',
                color: '#f59e0b',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store results' },
                    { name: 'Connection', type: 'text', help: 'Database connection string' },
                    { name: 'Query', type: 'textarea', required: true, help: 'SQL query' },
                    { name: 'Parameters', type: 'text', help: 'Query parameters (JSON)' }
                ]
            },
            analyze: {
                type: 'ANALYZE',
                icon: 'analytics',
                color: '#10b981',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store analysis' },
                    { name: 'Data', type: 'text', required: true, help: 'Data to analyze' },
                    { name: 'Type', type: 'select', options: ['STATISTICAL', 'PATTERN', 'SENTIMENT', 'TREND'], help: 'Analysis type' },
                    { name: 'Criteria', type: 'text', help: 'Analysis criteria' }
                ]
            },
            sense: {
                type: 'SENSE',
                icon: 'sensors',
                color: '#f97316',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store sensed data' },
                    { name: 'Source', type: 'select', options: ['CAMERA', 'MICROPHONE', 'SENSOR', 'FILE', 'STREAM'], help: 'Data source' },
                    { name: 'Duration', type: 'text', help: 'Sensing duration' },
                    { name: 'Filter', type: 'text', help: 'Data filter criteria' }
                ]
            },
            actuate: {
                type: 'ACTUATE',
                icon: 'settings_remote',
                color: '#dc2626',
                properties: [
                    { name: 'Device', type: 'text', required: true, help: 'Target device/actuator' },
                    { name: 'Action', type: 'text', required: true, help: 'Action to perform' },
                    { name: 'Parameters', type: 'text', help: 'Action parameters' },
                    { name: 'Timeout', type: 'text', help: 'Action timeout' }
                ]
            },
            injest: {
                type: 'INJEST',
                icon: 'cloud_upload',
                color: '#7c3aed',
                properties: [
                    { name: 'Key', type: 'text', required: true, help: 'Variable to store processed data' },
                    { name: 'Source', type: 'text', required: true, help: 'Data source' },
                    { name: 'Format', type: 'select', options: ['JSON', 'XML', 'CSV', 'TEXT', 'BINARY'], help: 'Data format' },
                    { name: 'Transform', type: 'text', help: 'Data transformation rules' }
                ]
            },
            foreach: {
                type: 'FOREACH',
                icon: 'repeat',
                color: '#059669',
                hasChildren: true,
                properties: [
                    { name: 'Variable', type: 'text', required: true, help: 'Iterator variable' },
                    { name: 'Collection', type: 'text', required: true, help: 'Collection to iterate' }
                ]
            },
            for: {
                type: 'FOR',
                icon: 'loop',
                color: '#0d9488',
                hasChildren: true,
                properties: [
                    { name: 'Variable', type: 'text', required: true, help: 'Loop variable' },
                    { name: 'Start', type: 'text', required: true, help: 'Start value' },
                    { name: 'End', type: 'text', required: true, help: 'End value' },
                    { name: 'Step', type: 'text', help: 'Step increment (default: 1)' }
                ]
            },
            do: {
                type: 'DO',
                icon: 'play_circle',
                color: '#1d4ed8',
                hasChildren: true,
                properties: []
            },
            elseif: {
                type: 'ELSEIF',
                icon: 'alt_route',
                color: '#7c2d12',
                hasChildren: true,
                properties: [
                    { name: 'Condition', type: 'text', required: true, help: 'Boolean condition' }
                ]
            },
            default: {
                type: 'DEFAULT',
                icon: 'rule',
                color: '#6b7280',
                hasChildren: true,
                properties: []
            },
            else: {
                type: 'ELSE',
                icon: 'alt_route',
                color: '#78716c',
                hasChildren: true,
                properties: []
            },
            break: {
                type: 'BREAK',
                icon: 'stop',
                color: '#dc2626',
                properties: []
            },
            continue: {
                type: 'CONTINUE',
                icon: 'skip_next',
                color: '#059669',
                properties: []
            }
        };

        // Initialize Visual Designer for an Agent
        function initializeVisualDesigner(agentKey) {
            visualDesignerState.currentAgent = agentKey;
            visualDesignerState.nodes.clear();
            visualDesignerState.connections = [];
            visualDesignerState.selectedNode = null;
            
            setupPaletteDragDrop();
            setupCanvasInteraction();
            setupInspectorHandlers();
            
            // Load existing statements if any
            const agent = currentPlan.agents.get(agentKey);
            if (agent && agent.statements) {
                loadStatementsAsNodes(agent.statements);
            }
            
            console.log(`🎨 Visual Designer initialized for agent: ${agentKey}`);
        }

        // Setup Palette Drag & Drop
        function setupPaletteDragDrop() {
            const paletteItems = document.querySelectorAll('.palette-item');
            
            paletteItems.forEach(item => {
                item.addEventListener('mousedown', startPaletteDrag);
                item.addEventListener('dragstart', e => e.preventDefault());
            });
        }

        function startPaletteDrag(e) {
            const item = e.currentTarget;
            const type = item.dataset.type;
            const template = statementTemplates[type];
            
            if (!template) return;
            
            // Create preview element
            const preview = item.cloneNode(true);
            preview.style.position = 'fixed';
            preview.style.pointerEvents = 'none';
            preview.style.zIndex = '10000';
            preview.style.opacity = '0.8';
            preview.style.transform = 'rotate(2deg)';
            document.body.appendChild(preview);
            
            const moveHandler = (e) => {
                preview.style.left = `${e.clientX - 60}px`;
                preview.style.top = `${e.clientY - 20}px`;
            };
            
            const dropHandler = (e) => {
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', dropHandler);
                document.body.removeChild(preview);
                
                // Check if dropped on canvas
                const canvas = document.getElementById('statementCanvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                if (e.clientX >= canvasRect.left && e.clientX <= canvasRect.right &&
                    e.clientY >= canvasRect.top && e.clientY <= canvasRect.bottom) {
                    
                    const x = e.clientX - canvasRect.left;
                    const y = e.clientY - canvasRect.top;
                    
                    createStatementNode(type, x, y);
                }
            };
            
            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', dropHandler);
            
            moveHandler(e);
        }

        // Create Statement Node
        function createStatementNode(type, x, y, data = {}) {
            const template = statementTemplates[type];
            if (!template) return null;
            
            const nodeId = `node_${visualDesignerState.nodeCounter++}`;
            const canvas = document.getElementById('statementCanvas');
            
            const nodeElement = document.createElement('div');
            nodeElement.className = 'statement-node';
            nodeElement.id = nodeId;
            nodeElement.style.left = `${x}px`;
            nodeElement.style.top = `${y}px`;
            
            // Create node summary from data
            const summary = createNodeSummary(template, data);
            
            nodeElement.innerHTML = `
                <div class="node-header">
                    <div class="node-type">
                        <i class="material-icons" style="color: ${template.color}">${template.icon}</i>
                        <span>${template.type}</span>
                    </div>
                    <div class="node-actions">
                        <button class="node-action" onclick="deleteStatementNode('${nodeId}')">
                            <i class="material-icons">delete</i>
                        </button>
                    </div>
                </div>
                <div class="node-body">
                    ${data.Key ? `<div class="node-key">${data.Key}</div>` : ''}
                    <div class="node-summary">${summary}</div>
                </div>
                <div class="connection-point input"></div>
                <div class="connection-point output"></div>
            `;
            
            // Store node data
            const nodeData = {
                id: nodeId,
                type: type,
                template: template,
                x: x,
                y: y,
                data: { ...data },
                element: nodeElement
            };
            
            visualDesignerState.nodes.set(nodeId, nodeData);
            
            // Setup node interactions
            setupNodeInteractions(nodeElement, nodeData);
            
            canvas.appendChild(nodeElement);
            
            // Auto-select new node
            selectStatementNode(nodeId);
            
            console.log(`➕ Created ${template.type} node:`, nodeId);
            return nodeElement;
        }

        // Create Node Summary Text
        function createNodeSummary(template, data) {
            const summaries = {
                'DECLARE': () => `${data.Key || 'Variable'}: ${data.Type || 'STRING'}${data.Expression ? ` = ${data.Expression}` : ''}`,
                'PROP': () => `${data.Key || 'Property'}: ${data.Type || 'STRING'}`,
                'ASSIGN': () => `${data.Key || 'Variable'} = ${(data.Template || 'Value').substring(0, 30)}${data.Template?.length > 30 ? '...' : ''}`,
                'IN': () => `Input: ${data.Label || 'User input'} → ${data.Key || 'Variable'}`,
                'OUT': () => `Output: ${(data.Template || 'Message').substring(0, 40)}${data.Template?.length > 40 ? '...' : ''}`,
                'CHOICE': () => `Choice: ${data.Key || 'Selection'}`,
                'IF': () => `If ${data.Key || 'Variable'} ${data.ConditionType || 'Equal'} ${data.Template || 'Value'}`,
                'WHILE': () => `While ${data.Key || 'Variable'} ${data.ConditionType || 'Equal'} ${data.Template || 'Value'}`,
                'SWITCH': () => `Switch on ${data.Key || 'Variable'}`,
                'CASE': () => `Case: ${data.Template || 'Value'}`,
                'CALL': () => `Call ${data.ToKey || 'Agent'}${data.Key ? ` → ${data.Key}` : ''}`,
                'RETURN': () => `Return ${data.Type || 'STRING'}: ${(data.Template || 'Value').substring(0, 30)}`,
                'PROMPT': () => `Prompt: ${data.Key || 'Identifier'}`,
                'GENERATE': () => `Generate → ${data.Key || 'Variable'} (${data.MaxTokens || 500} tokens)`,
                'READ': () => `Read ${data.FileKey || 'File'} → ${data.Key || 'Variable'}`,
                'WRITE': () => `Write ${data.Key || 'Data'} → ${data.FileKey || 'File'}`
            };
            
            const summaryFn = summaries[template.type];
            return summaryFn ? summaryFn() : `${template.type} statement`;
        }

        // Setup Node Interactions
        function setupNodeInteractions(element, nodeData) {
            // Node selection and dragging
            element.addEventListener('mousedown', (e) => {
                if (e.target.closest('.node-action') || e.target.closest('.connection-point')) return;
                
                selectStatementNode(nodeData.id);
                
                visualDesignerState.draggedNode = nodeData;
                const rect = element.getBoundingClientRect();
                const canvasRect = document.getElementById('statementCanvas').getBoundingClientRect();
                
                visualDesignerState.draggedNode.dragOffset = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                
                e.preventDefault();
            });
            
            // Connection points
            const inputPoint = element.querySelector('.connection-point.input');
            const outputPoint = element.querySelector('.connection-point.output');
            
            if (outputPoint) {
                outputPoint.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    startConnection(nodeData, 'output');
                });
            }
            
            if (inputPoint) {
                inputPoint.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    startConnection(nodeData, 'input');
                });
            }
        }

        // Select Statement Node
        function selectStatementNode(nodeId) {
            visualDesignerState.selectedNode = nodeId;
            
            // Update visual selection
            document.querySelectorAll('.statement-node').forEach(node => {
                node.classList.remove('selected');
            });
            
            const nodeElement = document.getElementById(nodeId);
            if (nodeElement) {
                nodeElement.classList.add('selected');
            }
            
            // Update inspector
            updateInspector();
        }

        // Update Inspector Panel
        function updateInspector() {
            const inspectorContent = document.getElementById('inspectorContent');
            const agentVariables = document.getElementById('agentVariables');
            
            if (!visualDesignerState.selectedNode) {
                inspectorContent.innerHTML = '<div class="inspector-empty">Select a statement to edit properties</div>';
                return;
            }
            
            const nodeData = visualDesignerState.nodes.get(visualDesignerState.selectedNode);
            if (!nodeData) return;
            
            const template = nodeData.template;
            
            // Create property form
            let formHtml = `<div class="property-form">`;
            
            template.properties.forEach(prop => {
                const value = nodeData.data[prop.name] || '';
                const inputId = `prop_${prop.name}`;
                
                formHtml += `
                    <div class="property-group">
                        <label class="property-label" for="${inputId}">
                            ${prop.name}${prop.required ? ' *' : ''}
                        </label>
                `;
                
                switch(prop.type) {
                    case 'textarea':
                        formHtml += `<textarea class="property-textarea" id="${inputId}" data-prop="${prop.name}">${value}</textarea>`;
                        break;
                    case 'select':
                        formHtml += `<select class="property-select" id="${inputId}" data-prop="${prop.name}">`;
                        formHtml += `<option value="">-- Select --</option>`;
                        prop.options.forEach(opt => {
                            formHtml += `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`;
                        });
                        formHtml += `</select>`;
                        break;
                    case 'number':
                        formHtml += `<input type="number" class="property-input" id="${inputId}" data-prop="${prop.name}" value="${value}">`;
                        break;
                    default:
                        formHtml += `<input type="text" class="property-input" id="${inputId}" data-prop="${prop.name}" value="${value}">`;
                }
                
                if (prop.help) {
                    formHtml += `<div class="property-help">${prop.help}</div>`;
                }
                
                formHtml += `</div>`;
            });
            
            formHtml += `</div>`;
            
            inspectorContent.innerHTML = formHtml;
            
            // Setup property change handlers
            setupPropertyHandlers();
            
            // Update variables list
            updateVariablesList();
        }

        // Setup Property Change Handlers
        function setupPropertyHandlers() {
            const propertyInputs = document.querySelectorAll('.property-input, .property-textarea, .property-select');
            
            propertyInputs.forEach(input => {
                input.addEventListener('input', () => {
                    const propName = input.dataset.prop;
                    const nodeData = visualDesignerState.nodes.get(visualDesignerState.selectedNode);
                    
                    if (nodeData) {
                        nodeData.data[propName] = input.value;
                        updateNodeSummary(nodeData);
                    }
                });
            });
        }

        // Update Node Summary
        function updateNodeSummary(nodeData) {
            const summary = createNodeSummary(nodeData.template, nodeData.data);
            const summaryElement = nodeData.element.querySelector('.node-summary');
            const keyElement = nodeData.element.querySelector('.node-key');
            
            if (summaryElement) {
                summaryElement.textContent = summary;
            }
            
            // Update key display
            if (nodeData.data.Key) {
                if (keyElement) {
                    keyElement.textContent = nodeData.data.Key;
                } else {
                    const nodeBody = nodeData.element.querySelector('.node-body');
                    nodeBody.insertAdjacentHTML('afterbegin', `<div class="node-key">${nodeData.data.Key}</div>`);
                }
            } else if (keyElement) {
                keyElement.remove();
            }
        }

        // Update Variables List
        function updateVariablesList() {
            const agentVariables = document.getElementById('agentVariables');
            const variables = extractVariablesFromNodes();
            
            if (variables.length === 0) {
                agentVariables.innerHTML = '<div style="color: var(--text-muted); font-style: italic; text-align: center; padding: 20px;">No variables declared</div>';
                return;
            }
            
            let variablesHtml = '';
            variables.forEach(variable => {
                variablesHtml += `
                    <div class="variable-item">
                        <div class="variable-name">${variable.name}</div>
                        <div class="variable-type">${variable.type}</div>
                    </div>
                `;
            });
            
            agentVariables.innerHTML = variablesHtml;
        }

        // Extract Variables from Nodes
        function extractVariablesFromNodes() {
            const variables = [];
            
            visualDesignerState.nodes.forEach(nodeData => {
                if (nodeData.type === 'declare' && nodeData.data.Key) {
                    variables.push({
                        name: nodeData.data.Key,
                        type: nodeData.data.Type || 'STRING'
                    });
                } else if (nodeData.type === 'prop' && nodeData.data.Key) {
                    variables.push({
                        name: nodeData.data.Key,
                        type: (nodeData.data.Type || 'STRING') + ' (PROP)'
                    });
                }
            });
            
            return variables;
        }

        // Setup Canvas Interaction
        function setupCanvasInteraction() {
            const canvasContainer = document.getElementById('canvasContainer');
            
            // Mouse move for dragging and connections
            document.addEventListener('mousemove', (e) => {
                if (visualDesignerState.draggedNode) {
                    const canvasRect = document.getElementById('statementCanvas').getBoundingClientRect();
                    const x = e.clientX - canvasRect.left - visualDesignerState.draggedNode.dragOffset.x;
                    const y = e.clientY - canvasRect.top - visualDesignerState.draggedNode.dragOffset.y;
                    
                    visualDesignerState.draggedNode.x = Math.max(0, x);
                    visualDesignerState.draggedNode.y = Math.max(0, y);
                    
                    visualDesignerState.draggedNode.element.style.left = `${visualDesignerState.draggedNode.x}px`;
                    visualDesignerState.draggedNode.element.style.top = `${visualDesignerState.draggedNode.y}px`;
                    
                    updateConnections();
                }
            });
            
            // Mouse up to stop dragging
            document.addEventListener('mouseup', () => {
                visualDesignerState.draggedNode = null;
                visualDesignerState.connecting = null;
            });
            
            // Canvas click to deselect
            canvasContainer.addEventListener('click', (e) => {
                if (e.target === canvasContainer || e.target.id === 'statementCanvas') {
                    visualDesignerState.selectedNode = null;
                    document.querySelectorAll('.statement-node').forEach(node => {
                        node.classList.remove('selected');
                    });
                    updateInspector();
                }
            });
        }

        // Global functions for node management
        window.deleteStatementNode = function(nodeId) {
            const nodeData = visualDesignerState.nodes.get(nodeId);
            if (nodeData) {
                nodeData.element.remove();
                visualDesignerState.nodes.delete(nodeId);
                
                if (visualDesignerState.selectedNode === nodeId) {
                    visualDesignerState.selectedNode = null;
                    updateInspector();
                }
                
                // Remove connections
                visualDesignerState.connections = visualDesignerState.connections.filter(
                    conn => conn.from !== nodeId && conn.to !== nodeId
                );
                updateConnections();
                
                console.log(`🗑️ Deleted node: ${nodeId}`);
            }
        };

        // Connection System
        function startConnection(nodeData, pointType) {
            visualDesignerState.connecting = {
                sourceNode: nodeData,
                sourceType: pointType,
                tempLine: null
            };
            
            // Create temporary connection line
            const svg = document.getElementById('connectionSvg');
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            line.setAttribute('stroke', 'var(--primary)');
            line.setAttribute('stroke-width', '2');
            line.setAttribute('fill', 'none');
            line.setAttribute('stroke-dasharray', '5,5');
            line.setAttribute('marker-end', 'url(#arrowhead)');
            
            visualDesignerState.connecting.tempLine = line;
            svg.appendChild(line);
            
            // Add mouse move handler for temporary line
            const mouseMoveHandler = (e) => {
                if (visualDesignerState.connecting) {
                    updateTempConnection(e);
                }
            };
            
            const mouseUpHandler = (e) => {
                document.removeEventListener('mousemove', mouseMoveHandler);
                document.removeEventListener('mouseup', mouseUpHandler);
                
                // Check if connecting to another node
                const targetElement = document.elementFromPoint(e.clientX, e.clientY);
                const targetNode = targetElement?.closest('.statement-node');
                
                if (targetNode && targetNode.id !== nodeData.id) {
                    const targetNodeData = visualDesignerState.nodes.get(targetNode.id);
                    if (targetNodeData) {
                        createConnection(visualDesignerState.connecting.sourceNode, targetNodeData);
                    }
                }
                
                // Clean up temporary line
                if (visualDesignerState.connecting?.tempLine) {
                    svg.removeChild(visualDesignerState.connecting.tempLine);
                }
                visualDesignerState.connecting = null;
            };
            
            document.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('mouseup', mouseUpHandler);
            
            console.log(`🔗 Starting connection from ${nodeData.id} (${pointType})`);
        }

        function updateTempConnection(e) {
            if (!visualDesignerState.connecting?.tempLine) return;
            
            const sourceNode = visualDesignerState.connecting.sourceNode;
            const canvasRect = document.getElementById('statementCanvas').getBoundingClientRect();
            
            const sourceX = sourceNode.x + (sourceNode.element.offsetWidth / 2);
            const sourceY = sourceNode.y + (sourceNode.element.offsetHeight / 2);
            
            const targetX = e.clientX - canvasRect.left;
            const targetY = e.clientY - canvasRect.top;
            
            const path = createConnectionPath(sourceX, sourceY, targetX, targetY);
            visualDesignerState.connecting.tempLine.setAttribute('d', path);
        }

        function createConnection(sourceNode, targetNode) {
            // Check if connection already exists
            const existingConnection = visualDesignerState.connections.find(
                conn => conn.from === sourceNode.id && conn.to === targetNode.id
            );
            
            if (existingConnection) {
                console.log('Connection already exists');
                return;
            }
            
            // Create connection data
            const connection = {
                id: `conn_${Date.now()}`,
                from: sourceNode.id,
                to: targetNode.id,
                fromNode: sourceNode,
                toNode: targetNode
            };
            
            visualDesignerState.connections.push(connection);
            updateConnections();
            
            console.log(`✅ Created connection: ${sourceNode.id} → ${targetNode.id}`);
        }

        function updateConnections() {
            const svg = document.getElementById('connectionSvg');
            
            // Clear existing connection paths (keep defs)
            const existingPaths = svg.querySelectorAll('path:not([stroke-dasharray])');
            existingPaths.forEach(path => path.remove());
            
            // Render all connections
            visualDesignerState.connections.forEach(connection => {
                const fromNode = connection.fromNode;
                const toNode = connection.toNode;
                
                if (!fromNode.element.parentNode || !toNode.element.parentNode) {
                    // Node was deleted, remove connection
                    return;
                }
                
                const fromX = fromNode.x + fromNode.element.offsetWidth;
                const fromY = fromNode.y + (fromNode.element.offsetHeight / 2);
                
                const toX = toNode.x;
                const toY = toNode.y + (toNode.element.offsetHeight / 2);
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', createConnectionPath(fromX, fromY, toX, toY));
                path.setAttribute('stroke', 'var(--primary)');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                path.setAttribute('marker-end', 'url(#arrowhead)');
                path.setAttribute('data-connection-id', connection.id);
                path.style.cursor = 'pointer';
                
                // Add click handler to delete connection
                path.addEventListener('click', () => {
                    deleteConnection(connection.id);
                });
                
                svg.appendChild(path);
            });
        }

        function createConnectionPath(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            
            // Create curved path
            const controlPoint1X = x1 + dx * 0.5;
            const controlPoint1Y = y1;
            const controlPoint2X = x2 - dx * 0.5;
            const controlPoint2Y = y2;
            
            return `M ${x1} ${y1} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${x2} ${y2}`;
        }

        function deleteConnection(connectionId) {
            visualDesignerState.connections = visualDesignerState.connections.filter(
                conn => conn.id !== connectionId
            );
            updateConnections();
            console.log(`🗑️ Deleted connection: ${connectionId}`);
        }

        // DSL Parser & Generator
        function loadStatementsAsNodes(statements) {
            if (!statements || statements.length === 0) return;
            
            console.log('📥 Loading existing statements as visual nodes');
            
            let yOffset = 50;
            statements.forEach((statement, index) => {
                const x = 100 + (index % 3) * 250;
                const y = yOffset + Math.floor(index / 3) * 150;
                
                const nodeType = statement.type?.toLowerCase();
                if (statementTemplates[nodeType]) {
                    createStatementNode(nodeType, x, y, statement.properties || {});
                }
            });
        }

        function parseXMLToAgentStatements(agentElement) {
            const statements = [];
            
            Array.from(agentElement.children).forEach(child => {
                const statement = parseXMLStatement(child);
                if (statement) {
                    statements.push(statement);
                }
            });
            
            return statements;
        }

        function parseXMLStatement(element) {
            const tagName = element.tagName;
            const statement = {
                type: tagName,
                properties: {}
            };
            
            // Parse attributes
            Array.from(element.attributes).forEach(attr => {
                statement.properties[attr.name] = attr.value;
            });
            
            // Parse text content for template-based statements
            if (element.textContent?.trim()) {
                statement.properties.Template = element.textContent.trim();
            }
            
            // Handle special cases
            switch(tagName) {
                case 'PROMPT':
                    statement.children = [];
                    Array.from(element.children).forEach(child => {
                        if (child.tagName === 'SECTION') {
                            const section = {
                                type: 'SECTION',
                                properties: { Type: child.getAttribute('Type') },
                                children: []
                            };
                            
                            Array.from(child.children).forEach(line => {
                                if (line.tagName === 'LINE') {
                                    section.children.push({
                                        type: 'LINE',
                                        properties: { Template: line.getAttribute('Template') || line.textContent }
                                    });
                                }
                            });
                            
                            statement.children.push(section);
                        }
                    });
                    break;
                    
                case 'CHOICE':
                    statement.children = [];
                    Array.from(element.children).forEach(child => {
                        if (child.tagName === 'PICK') {
                            statement.children.push({
                                type: 'PICK',
                                properties: {
                                    Key: child.getAttribute('Key'),
                                    Description: child.getAttribute('Description')
                                }
                            });
                        }
                    });
                    break;
            }
            
            return statement;
        }

        function generateAgentXML(agentKey) {
            const agent = currentPlan.agents.get(agentKey);
            if (!agent) return '';
            
            let xml = `    <AGENT Key="${agentKey}" Purpose="${agent.purpose || 'Tool'}">\n`;
            
            // Generate statements from visual nodes
            const sortedNodes = Array.from(visualDesignerState.nodes.values())
                .sort((a, b) => a.y - b.y); // Sort by vertical position
            
            sortedNodes.forEach(nodeData => {
                xml += generateStatementXML(nodeData, 2);
            });
            
            xml += `    </AGENT>\n`;
            return xml;
        }

        function generateStatementXML(nodeData, indentLevel = 0) {
            const indent = '    '.repeat(indentLevel);
            const template = nodeData.template;
            const data = nodeData.data;
            
            let xml = `${indent}<${template.type}`;
            
            // Add attributes
            Object.entries(data).forEach(([key, value]) => {
                if (value && key !== 'Template' && key !== 'Content') {
                    xml += ` ${key}="${escapeXML(value)}"`;
                }
            });
            
            // Handle content
            if (data.Template) {
                xml += ` Template="${escapeXML(data.Template)}"`;
            }
            
            // Close tag
            if (template.hasChildren || template.hasBody || data.Content) {
                xml += `>\n`;
                
                // Add content if any
                if (data.Content) {
                    xml += `${indent}    ${escapeXML(data.Content)}\n`;
                }
                
                xml += `${indent}</${template.type}>\n`;
            } else {
                xml += `/>\n`;
            }
            
            return xml;
        }

        function escapeXML(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#x27;');
        }

        // Enhanced XML Generation
        function generateXML() {
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += `<PLAN Key="${currentPlan.key || 'UntitledPlan'}" Description="${currentPlan.description || 'Generated by Enterprise DSL Designer'}" Author="${currentPlan.author || 'DSL Designer'}">\n\n`;
            
            // Generate SCHEMA section if schemas exist
            if (currentPlan.schemas.size > 0) {
                xml += '    <SCHEMA>\n';
                currentPlan.schemas.forEach((schema, key) => {
                    xml += `        <!-- Schema ${key} definition -->\n`;
                });
                xml += '    </SCHEMA>\n\n';
            }
            
            // Generate SEED section if seed data exists
            if (currentPlan.seed.size > 0) {
                xml += '    <SEED>\n';
                currentPlan.seed.forEach((value, key) => {
                    xml += `        <DECLARE Key="${key}" Type="AUTO" Expression="${escapeXml(JSON.stringify(value))}" />\n`;
                });
                xml += '    </SEED>\n\n';
            }
            
            // Generate agents with visual statements
            currentPlan.agents.forEach((agent, key) => {
                if (visualDesignerState.currentAgent === key && visualDesignerState.nodes.size > 0) {
                    // Generate from visual designer
                    xml += generateAgentXML(key);
                } else {
                    // Generate basic agent structure
                    xml += `    <AGENT Key="${key}" Purpose="${agent.purpose || 'Tool'}">\n`;
                    xml += '        <!-- Agent statements will be here -->\n';
                    xml += '    </AGENT>\n';
                }
                xml += '\n';
            });
            
            // Add stores
            currentPlan.stores.forEach((store, key) => {
                xml += `    <STORE Key="${key}">\n`;
                xml += '        <!-- Store structure will be here -->\n';
                xml += '    </STORE>\n\n';
            });
            
            xml += '</PLAN>';
            return xml;
        }

        // Setup Inspector Handlers
        function setupInspectorHandlers() {
            // Already handled in updateInspector and setupPropertyHandlers
        }

        // DSL Interpreter Engine
        let interpreterState = {
            isRunning: false,
            currentNode: null,
            variables: new Map(),
            executionLog: [],
            callStack: [],
            userInputResolve: null,
            userInputReject: null
        };

        // Execute Agent Flow
        async function executeAgentFlow() {
            if (interpreterState.isRunning) return;
            
            interpreterState.isRunning = true;
            interpreterState.variables.clear();
            interpreterState.executionLog = [];
            interpreterState.callStack = [];
            
            console.log('🚀 Starting agent execution');
            addExecutionLog('🚀 Starting agent execution');
            
            try {
                // Find entry point (first node or one without inputs)
                const entryNode = findEntryNode();
                if (!entryNode) {
                    throw new Error('No entry point found. Add some statements and connect them.');
                }
                
                await executeFromNode(entryNode);
                
                console.log('✅ Agent execution completed');
                addExecutionLog('✅ Agent execution completed successfully');
                
            } catch (error) {
                console.error('❌ Agent execution failed:', error);
                addExecutionLog(`❌ Execution failed: ${error.message}`);
            } finally {
                interpreterState.isRunning = false;
                clearNodeStates();
            }
        }

        function findEntryNode() {
            // Find node with no incoming connections
            const nodesWithIncoming = new Set();
            visualDesignerState.connections.forEach(conn => {
                nodesWithIncoming.add(conn.to);
            });
            
            for (const [nodeId, nodeData] of visualDesignerState.nodes) {
                if (!nodesWithIncoming.has(nodeId)) {
                    return nodeData;
                }
            }
            
            // If all nodes have connections, return the first one
            return visualDesignerState.nodes.values().next().value;
        }

        async function executeFromNode(nodeData) {
            if (!interpreterState.isRunning) return;
            
            interpreterState.currentNode = nodeData;
            
            // Visual feedback
            clearNodeStates();
            nodeData.element.classList.add('executing');
            
            addExecutionLog(`▶️ Executing ${nodeData.template.type}: ${nodeData.data.Key || nodeData.id}`);
            
            try {
                await executeStatement(nodeData);
                
                // Mark as completed
                nodeData.element.classList.remove('executing');
                nodeData.element.classList.add('completed');
                
                // Brief pause for visual feedback
                await sleep(300);
                
                // Execute next connected nodes
                const nextNodes = getConnectedNodes(nodeData);
                for (const nextNode of nextNodes) {
                    await executeFromNode(nextNode);
                }
                
            } catch (error) {
                nodeData.element.classList.remove('executing');
                nodeData.element.classList.add('error');
                throw error;
            }
        }

        function getConnectedNodes(nodeData) {
            return visualDesignerState.connections
                .filter(conn => conn.from === nodeData.id)
                .map(conn => visualDesignerState.nodes.get(conn.to))
                .filter(node => node !== undefined);
        }

        async function executeStatement(nodeData) {
            const type = nodeData.template.type;
            const data = nodeData.data;
            
            switch (type) {
                case 'DECLARE':
                    await executeDeclare(data);
                    break;
                case 'ASSIGN':
                    await executeAssign(data);
                    break;
                case 'OUT':
                    await executeOut(data);
                    break;
                case 'IN':
                    await executeIn(data);
                    break;
                case 'IF':
                    return await executeIf(nodeData, data);
                case 'WHILE':
                    return await executeWhile(nodeData, data);
                case 'CALL':
                    await executeCall(data);
                    break;
                case 'GENERATE':
                    await executeGenerate(data);
                    break;
                case 'READ':
                    await executeRead(data);
                    break;
                case 'WRITE':
                    await executeWrite(data);
                    break;
                case 'DESIGN':
                    await executeDesign(data);
                    break;
                case 'FETCH':
                    await executeFetch(data);
                    break;
                case 'SQL':
                    await executeSql(data);
                    break;
                case 'ANALYZE':
                    await executeAnalyze(data);
                    break;
                case 'SENSE':
                    await executeSense(data);
                    break;
                case 'ACTUATE':
                    await executeActuate(data);
                    break;
                case 'INJEST':
                    await executeInjest(data);
                    break;
                case 'FOREACH':
                    return await executeForeach(nodeData, data);
                case 'FOR':
                    return await executeFor(nodeData, data);
                case 'DO':
                    return await executeDo(nodeData, data);
                case 'ELSEIF':
                    return await executeElseIf(nodeData, data);
                case 'DEFAULT':
                    return await executeDefault(nodeData, data);
                case 'ELSE':
                    return await executeElse(nodeData, data);
                case 'BREAK':
                    return 'break';
                case 'CONTINUE':
                    return 'continue';
                default:
                    addExecutionLog(`⚠️ Statement type '${type}' not implemented yet`);
            }
        }

        async function executeDeclare(data) {
            const key = data.Key;
            if (!key) throw new Error('DECLARE: Key is required');
            
            let value = null;
            if (data.Expression) {
                value = interpolateTemplate(data.Expression);
                // Try to convert to appropriate type
                switch (data.Type) {
                    case 'INTEGER':
                        value = parseInt(value, 10) || 0;
                        break;
                    case 'DOUBLE':
                        value = parseFloat(value) || 0.0;
                        break;
                    case 'BOOL':
                        value = value === 'true' || value === '1';
                        break;
                    default:
                        value = String(value);
                }
            }
            
            interpreterState.variables.set(key, value);
            addExecutionLog(`📝 Declared ${key} (${data.Type || 'STRING'}) = ${JSON.stringify(value)}`);
            updateVariablesList();
        }

        async function executeAssign(data) {
            const key = data.Key;
            if (!key) throw new Error('ASSIGN: Key is required');
            
            const value = interpolateTemplate(data.Template || '');
            interpreterState.variables.set(key, value);
            
            addExecutionLog(`✏️ Assigned ${key} = ${JSON.stringify(value)}`);
            updateVariablesList();
        }

        async function executeOut(data) {
            const message = interpolateTemplate(data.Template || '');
            addExecutionLog(`💬 Output: ${message}`);
            
            // Show output in a modal or console
            console.log('OUTPUT:', message);
            
            // Could show in a modal dialog
            if (message.length < 200) {
                showNotification(message, 'info');
            } else {
                showOutputModal(message);
            }
        }

        async function executeIn(data) {
            const key = data.Key;
            const label = data.Label || 'Please enter a value:';
            const type = data.Type || 'TEXT';
            const preset = data.Preset || '';
            
            if (!key) throw new Error('IN: Key is required');
            
            // Show visual feedback
            interpreterState.currentNode.element.classList.remove('executing');
            interpreterState.currentNode.element.classList.add('waiting');
            
            addExecutionLog(`⏸️ Waiting for user input: ${label}`);
            
            try {
                const userInput = await showUserInputModal(key, label, type, preset);
                interpreterState.variables.set(key, userInput);
                
                addExecutionLog(`👤 User input: ${key} = ${JSON.stringify(userInput)}`);
                updateVariablesList();
                
            } finally {
                interpreterState.currentNode.element.classList.remove('waiting');
            }
        }

        async function executeIf(nodeData, data) {
            const key = data.Key;
            const conditionType = data.ConditionType || 'Equal';
            const compareValue = interpolateTemplate(data.Template || '');
            
            if (!key) throw new Error('IF: Key is required');
            
            const actualValue = String(interpreterState.variables.get(key) || '');
            let conditionMet = false;
            
            switch (conditionType) {
                case 'Equal':
                    conditionMet = actualValue === compareValue;
                    break;
                case 'NotEqual':
                    conditionMet = actualValue !== compareValue;
                    break;
                case 'GreaterThan':
                    conditionMet = parseFloat(actualValue) > parseFloat(compareValue);
                    break;
                case 'LessThan':
                    conditionMet = parseFloat(actualValue) < parseFloat(compareValue);
                    break;
            }
            
            addExecutionLog(`🔀 IF ${key} ${conditionType} "${compareValue}" → ${conditionMet ? 'TRUE' : 'FALSE'}`);
            
            // For now, execute all connected nodes regardless
            // In a full implementation, we'd need THEN/ELSE connection types
            return conditionMet;
        }

        async function executeWhile(nodeData, data) {
            const key = data.Key;
            const conditionType = data.ConditionType || 'Equal';
            const compareValue = interpolateTemplate(data.Template || '');
            
            if (!key) throw new Error('WHILE: Key is required');
            
            let iterations = 0;
            const maxIterations = 100; // Safety limit
            
            while (iterations < maxIterations && interpreterState.isRunning) {
                const actualValue = String(interpreterState.variables.get(key) || '');
                let conditionMet = false;
                
                switch (conditionType) {
                    case 'Equal':
                        conditionMet = actualValue === compareValue;
                        break;
                    case 'NotEqual':
                        conditionMet = actualValue !== compareValue;
                        break;
                    case 'GreaterThan':
                        conditionMet = parseFloat(actualValue) > parseFloat(compareValue);
                        break;
                    case 'LessThan':
                        conditionMet = parseFloat(actualValue) < parseFloat(compareValue);
                        break;
                }
                
                if (!conditionMet) break;
                
                addExecutionLog(`🔁 WHILE iteration ${iterations + 1}: ${key} ${conditionType} "${compareValue}"`);
                
                // Execute body (connected nodes)
                const bodyNodes = getConnectedNodes(nodeData);
                for (const bodyNode of bodyNodes) {
                    await executeFromNode(bodyNode);
                }
                
                iterations++;
                await sleep(100); // Brief pause
            }
            
            if (iterations >= maxIterations) {
                addExecutionLog(`⚠️ WHILE loop reached maximum iterations (${maxIterations})`);
            }
        }

        async function executeCall(data) {
            const toKey = data.ToKey;
            if (!toKey) throw new Error('CALL: ToKey is required');
            
            const resultKey = data.Key;
            const variables = data.Variables ? data.Variables.split(',').map(v => v.trim()) : [];
            
            addExecutionLog(`📞 CALL ${toKey} with variables: [${variables.join(', ')}]`);
            
            // For now, simulate the call
            if (resultKey) {
                interpreterState.variables.set(resultKey, `Result from ${toKey}`);
                addExecutionLog(`📥 CALL result stored in ${resultKey}`);
                updateVariablesList();
            }
        }

        async function executeGenerate(data) {
            const key = data.Key;
            if (!key) throw new Error('GENERATE: Key is required');
            
            const maxTokens = parseInt(data.MaxTokens) || 500;
            const creativity = data.Creativity || 'Balanced';
            
            addExecutionLog(`🤖 Generating content for ${key} (${maxTokens} tokens, ${creativity})`);
            
            // Simulate AI generation
            await sleep(1000);
            const generatedContent = `Generated content for ${key} using ${creativity} creativity level. This would be actual AI-generated text in a real implementation.`;
            
            interpreterState.variables.set(key, generatedContent);
            addExecutionLog(`✨ Generated ${generatedContent.length} characters for ${key}`);
            updateVariablesList();
        }

        async function executeRead(data) {
            const key = data.Key;
            const fileKey = data.FileKey;
            
            if (!key || !fileKey) throw new Error('READ: Key and FileKey are required');
            
            addExecutionLog(`📖 Reading file ${fileKey} into ${key}`);
            
            // Simulate file read
            const content = `Content from file: ${fileKey}`;
            interpreterState.variables.set(key, content);
            
            addExecutionLog(`📄 Read ${content.length} characters from ${fileKey}`);
            updateVariablesList();
        }

        async function executeWrite(data) {
            const key = data.Key;
            const fileKey = data.FileKey;
            
            if (!key || !fileKey) throw new Error('WRITE: Key and FileKey are required');
            
            const content = interpreterState.variables.get(key) || '';
            addExecutionLog(`💾 Writing ${key} to file ${fileKey} (${content.length} characters)`);
            
            // Simulate file write
            await sleep(200);
            addExecutionLog(`✅ Successfully wrote to ${fileKey}`);
        }

        // New RULES.xml Statement Handlers
        async function executeDesign(data) {
            const key = data.Key;
            const type = data.Type || 'UI';
            const template = data.Template;
            
            if (!key || !template) throw new Error('DESIGN: Key and Template are required');
            
            addExecutionLog(`🎨 Designing ${type}: ${template}`);
            await sleep(1000); // Simulate design generation
            
            const designResult = `${type} Design: ${template}`;
            interpreterState.variables.set(key, designResult);
            
            addExecutionLog(`✅ Design completed and stored in ${key}`);
            updateVariablesList();
        }

        async function executeFetch(data) {
            const key = data.Key;
            const url = data.Url;
            const method = data.Method || 'GET';
            
            if (!key || !url) throw new Error('FETCH: Key and Url are required');
            
            addExecutionLog(`🌐 Fetching ${method} ${url}`);
            await sleep(500); // Simulate network request
            
            const mockResponse = {
                status: 200,
                data: `Response from ${url}`,
                headers: { 'content-type': 'application/json' }
            };
            
            interpreterState.variables.set(key, JSON.stringify(mockResponse));
            addExecutionLog(`✅ Fetch completed, response stored in ${key}`);
            updateVariablesList();
        }

        async function executeSql(data) {
            const key = data.Key;
            const query = data.Query;
            const connection = data.Connection || 'default';
            
            if (!key || !query) throw new Error('SQL: Key and Query are required');
            
            addExecutionLog(`🗄️ Executing SQL query on ${connection}`);
            addExecutionLog(`   Query: ${query.substring(0, 100)}${query.length > 100 ? '...' : ''}`);
            await sleep(800); // Simulate database query
            
            const mockResults = [
                { id: 1, name: 'Sample Record 1' },
                { id: 2, name: 'Sample Record 2' }
            ];
            
            interpreterState.variables.set(key, JSON.stringify(mockResults));
            addExecutionLog(`✅ SQL query completed, ${mockResults.length} records stored in ${key}`);
            updateVariablesList();
        }

        async function executeAnalyze(data) {
            const key = data.Key;
            const dataSource = data.Data;
            const type = data.Type || 'STATISTICAL';
            
            if (!key || !dataSource) throw new Error('ANALYZE: Key and Data are required');
            
            addExecutionLog(`📊 Analyzing data (${type}): ${dataSource}`);
            await sleep(1200); // Simulate analysis processing
            
            const analysisResult = {
                type: type,
                source: dataSource,
                results: `${type} analysis of ${dataSource}`,
                confidence: 0.85,
                timestamp: new Date().toISOString()
            };
            
            interpreterState.variables.set(key, JSON.stringify(analysisResult));
            addExecutionLog(`✅ Analysis completed, results stored in ${key}`);
            updateVariablesList();
        }

        async function executeSense(data) {
            const key = data.Key;
            const source = data.Source || 'SENSOR';
            const duration = data.Duration || '1s';
            
            if (!key) throw new Error('SENSE: Key is required');
            
            addExecutionLog(`👁️ Sensing from ${source} for ${duration}`);
            await sleep(1000); // Simulate sensing duration
            
            const sensorData = {
                source: source,
                timestamp: new Date().toISOString(),
                data: `Sensed data from ${source}`,
                quality: 'HIGH'
            };
            
            interpreterState.variables.set(key, JSON.stringify(sensorData));
            addExecutionLog(`✅ Sensing completed, data stored in ${key}`);
            updateVariablesList();
        }

        async function executeActuate(data) {
            const device = data.Device;
            const action = data.Action;
            const timeout = data.Timeout || '5s';
            
            if (!device || !action) throw new Error('ACTUATE: Device and Action are required');
            
            addExecutionLog(`⚡ Actuating device ${device}: ${action} (timeout: ${timeout})`);
            await sleep(600); // Simulate actuation delay
            
            addExecutionLog(`✅ Device ${device} actuated successfully`);
        }

        async function executeInjest(data) {
            const key = data.Key;
            const source = data.Source;
            const format = data.Format || 'JSON';
            
            if (!key || !source) throw new Error('INJEST: Key and Source are required');
            
            addExecutionLog(`📥 Ingesting data from ${source} (format: ${format})`);
            await sleep(800); // Simulate data ingestion
            
            const ingestedData = {
                source: source,
                format: format,
                processed: true,
                recordCount: 142,
                timestamp: new Date().toISOString()
            };
            
            interpreterState.variables.set(key, JSON.stringify(ingestedData));
            addExecutionLog(`✅ Data ingested successfully, ${ingestedData.recordCount} records stored in ${key}`);
            updateVariablesList();
        }

        async function executeForeach(nodeData, data) {
            const variable = data.Variable;
            const collection = data.Collection;
            
            if (!variable || !collection) throw new Error('FOREACH: Variable and Collection are required');
            
            // Get collection data
            const collectionData = interpreterState.variables.get(collection) || [];
            let items = [];
            
            try {
                items = JSON.parse(collectionData);
                if (!Array.isArray(items)) {
                    items = [items];
                }
            } catch {
                items = String(collectionData).split(',');
            }
            
            addExecutionLog(`🔄 FOREACH ${variable} in ${collection} (${items.length} items)`);
            
            for (let i = 0; i < items.length; i++) {
                interpreterState.variables.set(variable, items[i]);
                addExecutionLog(`   Processing item ${i + 1}: ${JSON.stringify(items[i])}`);
                updateVariablesList();
                
                // Execute child statements
                const result = await executeChildStatements(nodeData);
                if (result === 'break') break;
                if (result === 'continue') continue;
                
                await sleep(200);
            }
            
            addExecutionLog(`✅ FOREACH completed`);
        }

        async function executeFor(nodeData, data) {
            const variable = data.Variable;
            const start = parseInt(data.Start) || 0;
            const end = parseInt(data.End) || 0;
            const step = parseInt(data.Step) || 1;
            
            if (!variable) throw new Error('FOR: Variable is required');
            
            addExecutionLog(`🔢 FOR ${variable} = ${start} to ${end} step ${step}`);
            
            for (let i = start; i <= end; i += step) {
                interpreterState.variables.set(variable, i);
                addExecutionLog(`   Iteration: ${variable} = ${i}`);
                updateVariablesList();
                
                // Execute child statements
                const result = await executeChildStatements(nodeData);
                if (result === 'break') break;
                if (result === 'continue') continue;
                
                await sleep(100);
            }
            
            addExecutionLog(`✅ FOR loop completed`);
        }

        async function executeDo(nodeData, data) {
            addExecutionLog(`🔄 DO block executing`);
            await executeChildStatements(nodeData);
            addExecutionLog(`✅ DO block completed`);
        }

        async function executeElseIf(nodeData, data) {
            const condition = data.Condition;
            if (!condition) throw new Error('ELSEIF: Condition is required');
            
            const conditionResult = evaluateCondition(condition);
            addExecutionLog(`🔀 ELSEIF: ${condition} = ${conditionResult}`);
            
            if (conditionResult) {
                await executeChildStatements(nodeData);
                return true; // Condition was true
            }
            return false; // Condition was false
        }

        async function executeDefault(nodeData, data) {
            addExecutionLog(`🔄 DEFAULT case executing`);
            await executeChildStatements(nodeData);
            addExecutionLog(`✅ DEFAULT case completed`);
        }

        async function executeElse(nodeData, data) {
            addExecutionLog(`🔄 ELSE block executing`);
            await executeChildStatements(nodeData);
            addExecutionLog(`✅ ELSE block completed`);
        }

        async function executeChildStatements(nodeData) {
            // Execute child statements if this node has them
            if (nodeData.children && nodeData.children.length > 0) {
                for (const child of nodeData.children) {
                    const result = await executeStatement(child);
                    if (result === 'break' || result === 'continue') {
                        return result;
                    }
                }
            }
            return null;
        }

        // Helper Functions
        function interpolateTemplate(template) {
            if (!template) return '';
            
            let result = template;
            interpreterState.variables.forEach((value, key) => {
                const regex = new RegExp(`#${key}#`, 'g');
                result = result.replace(regex, String(value));
            });
            
            return result;
        }

        function addExecutionLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            interpreterState.executionLog.push({ timestamp, message });
            console.log(`[${timestamp}] ${message}`);
        }

        function clearNodeStates() {
            document.querySelectorAll('.statement-node').forEach(node => {
                node.classList.remove('executing', 'completed', 'error', 'waiting');
            });
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // User Input Modal
        function showUserInputModal(key, label, type, preset) {
            return new Promise((resolve, reject) => {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-dialog">
                        <div class="modal-header">
                            <h3>${label}</h3>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>Input for variable: <strong>${key}</strong></label>
                                ${type === 'TEXTAREA' 
                                    ? `<textarea id="userInput" placeholder="${label}" style="width: 100%; min-height: 80px; padding: 8px; border: 1px solid var(--border); border-radius: 4px;">${preset}</textarea>`
                                    : `<input type="text" id="userInput" placeholder="${label}" value="${preset}" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px;">`
                                }
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').resolve(null)">Cancel</button>
                            <button class="btn btn-primary" onclick="this.closest('.modal-overlay').resolve(document.getElementById('userInput').value)">Submit</button>
                        </div>
                    </div>
                `;
                
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center;
                    z-index: 10000;
                `;
                
                modal.querySelector('.modal-dialog').style.cssText = `
                    background: var(--surface); border-radius: var(--radius-lg);
                    min-width: 400px; max-width: 600px; box-shadow: var(--shadow-lg);
                `;
                
                modal.querySelector('.modal-header').style.cssText = `
                    padding: 20px; border-bottom: 1px solid var(--border);
                `;
                
                modal.querySelector('.modal-body').style.cssText = `
                    padding: 20px;
                `;
                
                modal.querySelector('.modal-footer').style.cssText = `
                    padding: 20px; border-top: 1px solid var(--border);
                    display: flex; gap: 12px; justify-content: flex-end;
                `;
                
                modal.resolve = (value) => {
                    document.body.removeChild(modal);
                    if (value !== null) {
                        resolve(value);
                    } else {
                        reject(new Error('User cancelled input'));
                    }
                };
                
                document.body.appendChild(modal);
                
                // Focus input
                setTimeout(() => {
                    document.getElementById('userInput').focus();
                }, 100);
            });
        }

        function showOutputModal(message) {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-dialog">
                    <div class="modal-header">
                        <h3>Output</h3>
                        <button class="btn btn-icon" onclick="document.body.removeChild(this.closest('.modal-overlay'))">
                            <i class="material-icons">close</i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div style="white-space: pre-wrap; max-height: 400px; overflow-y: auto; padding: 12px; background: var(--surface-2); border-radius: 4px; font-family: monospace;">${message}</div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-primary" onclick="document.body.removeChild(this.closest('.modal-overlay'))">Close</button>
                    </div>
                </div>
            `;
            
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center;
                z-index: 10000;
            `;
            
            document.body.appendChild(modal);
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 10001;
                background: var(--surface); border: 1px solid var(--border);
                border-radius: var(--radius); padding: 12px 16px; box-shadow: var(--shadow-lg);
                max-width: 300px; animation: slideIn 0.3s ease-out;
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    document.body.removeChild(notification);
                }
            }, 3000);
        }

        // Action Handler Functions
        function importXML() {
            document.getElementById('fileInput').click();
        }
        
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const xmlContent = e.target.result;
                document.getElementById('xmlEditor').value = xmlContent;
                parseXMLToPlan(xmlContent);
            };
            reader.readAsText(file);
        }
        
        function exportXML() {
            const xml = generateXML();
            const blob = new Blob([xml], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentPlan.key || 'plan'}.xml`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function toggleTheme() {
            document.body.classList.toggle('dark');
            const themeBtn = document.getElementById('themeBtn');
            const icon = themeBtn.querySelector('i');
            icon.textContent = document.body.classList.contains('dark') ? 'light_mode' : 'dark_mode';
        }
        
        function addAgent() {
            const key = prompt('Enter agent key:');
            if (!key) return;
            
            const purpose = prompt('Enter agent purpose (Orchestrator/Tool/AI/Data):', 'Tool');
            
            currentPlan.agents.set(key, {
                purpose: purpose,
                statements: []
            });
            
            updateStatistics();
            if (currentTab === 'agents') {
                loadAgentsView();
            }
        }
        
        function addStore() {
            const key = prompt('Enter store key:');
            if (!key) return;
            
            currentPlan.stores.set(key, {
                folders: new Map(),
                files: new Map()
            });
            
            updateStatistics();
            if (currentTab === 'store') {
                loadStoreView();
            }
        }
        
        function formatXML() {
            const xmlEditor = document.getElementById('xmlEditor');
            try {
                const formatted = formatXMLString(xmlEditor.value);
                xmlEditor.value = formatted;
            } catch (error) {
                alert('Failed to format XML: ' + error.message);
            }
        }
        
        function validateXML() {
            const xmlEditor = document.getElementById('xmlEditor');
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(xmlEditor.value, 'application/xml');
                const errorNode = doc.querySelector('parsererror');
                
                if (errorNode) {
                    alert('XML Validation Failed: ' + errorNode.textContent);
                } else {
                    alert('XML is valid!');
                }
            } catch (error) {
                alert('XML Validation Failed: ' + error.message);
            }
        }
        
        function syncFromXML() {
            const xmlContent = document.getElementById('xmlEditor').value;
            parseXMLToPlan(xmlContent);
        }
        
        function parseXMLToPlan(xmlContent) {
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(xmlContent, 'application/xml');
                const planElement = doc.documentElement;
                
                if (planElement.tagName !== 'PLAN') {
                    throw new Error('Root element must be PLAN');
                }
                
                // Parse plan attributes
                currentPlan.key = planElement.getAttribute('Key') || '';
                currentPlan.description = planElement.getAttribute('Description') || '';
                currentPlan.author = planElement.getAttribute('Author') || '';
                
                // Parse agents
                currentPlan.agents.clear();
                const agents = planElement.querySelectorAll('AGENT');
                agents.forEach(agentEl => {
                    const key = agentEl.getAttribute('Key');
                    const purpose = agentEl.getAttribute('Purpose');
                    
                    if (key) {
                        const statements = parseXMLToAgentStatements(agentEl);
                        currentPlan.agents.set(key, {
                            purpose: purpose,
                            statements: statements
                        });
                    }
                });
                
                // Parse stores
                currentPlan.stores.clear();
                const stores = planElement.querySelectorAll('STORE');
                stores.forEach(storeEl => {
                    const key = storeEl.getAttribute('Key');
                    
                    if (key) {
                        currentPlan.stores.set(key, {
                            folders: new Map(),
                            files: new Map()
                        });
                    }
                });
                
                // Refresh UI
                loadTabContent(currentTab);
                updateStatistics();
                
                alert('XML imported successfully!');
                
            } catch (error) {
                alert('Failed to parse XML: ' + error.message);
                console.error('XML parsing error:', error);
            }
        }
        
        function formatXMLString(xml) {
            const PADDING = ' '.repeat(4);
            const reg = /(>)(<)(\/*)/g;
            let formatted = xml.replace(reg, '$1\r\n$2$3');
            let pad = 0;
            
            return formatted.split('\r\n').map(line => {
                let indent = 0;
                if (line.match(/.+<\/\w[^>]*>$/)) {
                    indent = 0;
                } else if (line.match(/^<\/\w/) && pad > 0) {
                    pad -= 1;
                } else if (line.match(/^<\w[^>]*[^\/]>.*$/)) {
                    indent = 1;
                } else {
                    indent = 0;
                }
                
                const padding = PADDING.repeat(pad);
                pad += indent;
                
                return padding + line;
            }).join('\r\n');
        }

        // Enhanced Event Listeners
        function setupEventListeners() {
            // Plan form changes
            document.getElementById('planKey').addEventListener('input', (e) => {
                currentPlan.key = e.target.value;
                document.getElementById('planTitle').textContent = e.target.value || 'Untitled Plan';
            });
            
            document.getElementById('planDescription').addEventListener('input', (e) => {
                currentPlan.description = e.target.value;
            });
            
            document.getElementById('planAuthor').addEventListener('input', (e) => {
                currentPlan.author = e.target.value;
            });
            
            // Header actions
            document.getElementById('importBtn').addEventListener('click', importXML);
            document.getElementById('exportBtn').addEventListener('click', exportXML);
            document.getElementById('executeBtn').addEventListener('click', executePlan);
            document.getElementById('themeBtn').addEventListener('click', toggleTheme);
            
            // Agent actions
            document.getElementById('addAgentBtn').addEventListener('click', addAgent);
            
            // Store actions
            document.getElementById('addStoreBtn').addEventListener('click', addStore);
            
            // Seed actions
            document.getElementById('addSeedBtn').addEventListener('click', addSeedItem);
            document.getElementById('importSeedBtn').addEventListener('click', importSeedData);
            document.getElementById('exportSeedBtn').addEventListener('click', exportSeedData);
            
            // XML actions
            document.getElementById('formatXmlBtn').addEventListener('click', formatXML);
            document.getElementById('validateXmlBtn').addEventListener('click', validateXML);
            document.getElementById('syncFromXmlBtn').addEventListener('click', syncFromXML);
            
            // File input
            document.getElementById('fileInput').addEventListener('change', handleFileImport);
        }

        // Complete DSL Plan Execution Engine with Performance Monitoring
        let planExecutionState = {
            isRunning: false,
            currentPlan: null,
            variables: new Map(),
            agentMap: new Map(),
            executionLog: [],
            callStack: [],
            storeIndex: new Map(),
            performance: {
                startTime: null,
                endTime: null,
                agentExecutionTimes: new Map(),
                statementExecutionTimes: new Map(),
                totalStatements: 0,
                successfulStatements: 0,
                failedStatements: 0,
                averageStatementTime: 0,
                peakMemoryUsage: 0,
                executionBreakdown: new Map()
            },
            debugging: {
                breakpoints: new Set(),
                isStepMode: false,
                isPaused: false,
                watchedVariables: new Set(),
                executionHistory: [],
                errorRecoveryAttempts: 0
            }
        };

        async function executePlan() {
            if (planExecutionState.isRunning) {
                alert('Plan is already running!');
                return;
            }

            if (currentPlan.agents.size === 0) {
                alert('No agents found in the plan. Please add some agents first.');
                return;
            }

            // Find orchestrator agent
            const orchestrator = findOrchestratorAgent();
            if (!orchestrator) {
                alert('No Orchestrator agent found. Please create an agent with Purpose="Orchestrator".');
                return;
            }

            planExecutionState.isRunning = true;
            planExecutionState.variables.clear();
            planExecutionState.executionLog = [];
            planExecutionState.callStack = [];
            
            // Build agent map
            planExecutionState.agentMap.clear();
            currentPlan.agents.forEach((agent, key) => {
                planExecutionState.agentMap.set(key, {
                    key: key,
                    purpose: agent.purpose,
                    statements: agent.statements || [],
                    nodes: getAgentVisualNodes(key)
                });
            });

            // Build store index
            planExecutionState.storeIndex.clear();
            currentPlan.stores.forEach((store, key) => {
                planExecutionState.storeIndex.set(key, {
                    key: key,
                    content: `Sample content for store: ${key}`
                });
            });

            try {
                // Initialize performance tracking
                planExecutionState.performance.startTime = performance.now();
                planExecutionState.performance.totalStatements = 0;
                planExecutionState.performance.successfulStatements = 0;
                planExecutionState.performance.failedStatements = 0;
                
                addPlanExecutionLog('🚀 Starting DSL Plan Execution');
                addPlanExecutionLog(`📊 Plan: ${currentPlan.key || 'Untitled'}`);
                addPlanExecutionLog(`🎯 Orchestrator: ${orchestrator.key}`);
                addPlanExecutionLog(`👥 Total Agents: ${currentPlan.agents.size}`);
                
                // Show execution UI
                showExecutionUI();
                
                // Execute the orchestrator
                const result = await executeDSLAgent(orchestrator, {});
                
                // Calculate final performance metrics
                planExecutionState.performance.endTime = performance.now();
                const totalTime = planExecutionState.performance.endTime - planExecutionState.performance.startTime;
                const successRate = (planExecutionState.performance.successfulStatements / planExecutionState.performance.totalStatements * 100).toFixed(1);
                
                addPlanExecutionLog('✅ Plan execution completed successfully');
                addPlanExecutionLog(`⏱️ Performance: ${Math.round(totalTime)}ms total, ${planExecutionState.performance.totalStatements} statements, ${successRate}% success rate`);
                addPlanExecutionLog(`📋 Final Result: ${JSON.stringify(result, null, 2)}`);
                
            } catch (error) {
                planExecutionState.performance.endTime = performance.now();
                planExecutionState.performance.failedStatements++;
                
                addPlanExecutionLog(`❌ Plan execution failed: ${error.message}`);
                console.error('Plan execution error:', error);
            } finally {
                planExecutionState.isRunning = false;
                addPlanExecutionLog('🏁 Plan execution finished');
                
                // Log final performance summary
                if (planExecutionState.performance.startTime) {
                    const totalTime = (planExecutionState.performance.endTime || performance.now()) - planExecutionState.performance.startTime;
                    addPlanExecutionLog(`📈 Final Performance: ${Math.round(totalTime)}ms, ${planExecutionState.performance.agentExecutionTimes.size} agents executed`);
                }
            }
        }

        function findOrchestratorAgent() {
            for (const [key, agent] of currentPlan.agents) {
                if (agent.purpose === 'Orchestrator') {
                    return { key, ...agent };
                }
            }
            return null;
        }

        function getAgentVisualNodes(agentKey) {
            if (visualDesignerState.currentAgent === agentKey) {
                return Array.from(visualDesignerState.nodes.values());
            }
            return [];
        }

        async function executeDSLAgent(agent, context = {}) {
            addPlanExecutionLog(`▶️ Executing Agent: ${agent.key} (${agent.purpose})`);
            
            planExecutionState.callStack.push(agent);
            
            try {
                // If agent has visual nodes, execute them
                if (agent.nodes && agent.nodes.length > 0) {
                    return await executeVisualAgent(agent, context);
                }
                
                // If agent has parsed statements, execute them
                if (agent.statements && agent.statements.length > 0) {
                    return await executeStatementAgent(agent, context);
                }
                
                // Default empty execution
                addPlanExecutionLog(`⚠️ Agent ${agent.key} has no statements to execute`);
                return context;
                
            } finally {
                planExecutionState.callStack.pop();
            }
        }

        async function executeVisualAgent(agent, context) {
            addPlanExecutionLog(`🎨 Executing visual flow for agent: ${agent.key}`);
            
            // Temporarily switch to this agent's visual state
            const originalAgent = visualDesignerState.currentAgent;
            const originalNodes = new Map(visualDesignerState.nodes);
            
            // Load this agent's nodes if they exist
            if (agent.key !== visualDesignerState.currentAgent) {
                // This would load the agent's saved visual state
                addPlanExecutionLog(`📥 Loading visual state for agent: ${agent.key}`);
            }
            
            // Execute the visual flow
            const result = await executeVisualFlow(agent.nodes, context);
            
            // Restore original state
            visualDesignerState.currentAgent = originalAgent;
            visualDesignerState.nodes = originalNodes;
            
            return result;
        }

        async function executeStatementAgent(agent, context) {
            addPlanExecutionLog(`📜 Executing parsed statements for agent: ${agent.key}`);
            
            // Copy context variables to plan state
            Object.entries(context).forEach(([key, value]) => {
                planExecutionState.variables.set(key, value);
            });
            
            let currentPrompt = null;
            let returnValue = undefined;
            
            try {
                for (const statement of agent.statements) {
                    if (!planExecutionState.isRunning) {
                        addPlanExecutionLog('⏹️ Execution stopped');
                        break;
                    }
                    
                    const type = statement.type;
                    const props = statement.properties || {};
                    
                    addPlanExecutionLog(`🔸 ${type}: ${props.Key || props.ToKey || 'unnamed'}`);
                    
                    try {
                        // Performance tracking for each statement
                        const statementStartTime = performance.now();
                        planExecutionState.performance.totalStatements++;
                        
                        switch (type) {
                            case 'DECLARE':
                                await executeDSLDeclare(props);
                                break;
                                
                            case 'ASSIGN':
                                await executeDSLAssign(props);
                                break;
                                
                            case 'OUT':
                                await executeDSLOut(props);
                                break;
                                
                            case 'IN':
                                await executeDSLIn(props);
                                break;
                                
                            case 'CHOICE':
                                await executeDSLChoice(props, statement);
                                break;
                                
                            case 'CALL':
                                await executeDSLCall(props);
                                break;
                                
                            case 'GENERATE':
                                await executeDSLGenerate(props);
                                break;
                                
                            case 'PROMPT':
                                currentPrompt = await executeDSLPrompt(props, statement);
                                break;
                                
                            case 'READ':
                                await executeDSLRead(props);
                                break;
                                
                            case 'WRITE':
                                await executeDSLWrite(props);
                                break;
                                
                            case 'IF':
                                const ifResult = await executeDSLIf(props);
                                // Note: Full IF/THEN/ELSE would require parsing child statements
                                break;
                                
                            case 'WHILE':
                                await executeDSLWhileStatement(props, statement);
                                break;
                                
                            case 'SWITCH':
                                await executeDSLSwitch(props, statement);
                                break;
                                
                            case 'PROP':
                                await executeDSLProp(props);
                                break;
                                
                            case 'RETURN':
                                returnValue = await executeDSLReturn(props);
                                addPlanExecutionLog(`📤 Agent returning: ${JSON.stringify(returnValue)}`);
                                break;
                                
                            default:
                                addPlanExecutionLog(`⚠️ Unknown statement type: ${type}`);
                        }
                        
                        // Track successful statement execution
                        const statementEndTime = performance.now();
                        const statementDuration = statementEndTime - statementStartTime;
                        
                        planExecutionState.performance.successfulStatements++;
                        planExecutionState.performance.statementExecutionTimes.set(
                            `${type}_${Date.now()}`, 
                            statementDuration
                        );
                        
                        // Small delay for visual feedback
                        await sleep(50);
                        
                    } catch (statementError) {
                        planExecutionState.performance.failedStatements++;
                        addPlanExecutionLog(`❌ Error in ${type}: ${statementError.message}`);
                        
                        // Continue execution for non-critical errors
                        if (!isCriticalError(statementError)) {
                            continue;
                        } else {
                            throw statementError;
                        }
                    }
                }
                
                // Build result context
                const result = {};
                planExecutionState.variables.forEach((value, key) => {
                    result[key] = value;
                });
                
                if (returnValue !== undefined) {
                    result.__return__ = returnValue;
                }
                
                addPlanExecutionLog(`✅ Agent ${agent.key} completed with ${Object.keys(result).length} variables`);
                return result;
                
            } catch (error) {
                addPlanExecutionLog(`❌ Agent ${agent.key} failed: ${error.message}`);
                throw error;
            }
        }

        function isCriticalError(error) {
            // Define which errors should stop execution vs continue
            const criticalErrors = [
                'Agent not found',
                'Maximum recursion',
                'Stack overflow'
            ];
            
            return criticalErrors.some(critical => 
                error.message.toLowerCase().includes(critical.toLowerCase())
            );
        }

        async function executeVisualFlow(nodes, context) {
            // Copy variables from context to interpreter state
            Object.entries(context).forEach(([key, value]) => {
                planExecutionState.variables.set(key, value);
            });

            // Find entry node (no incoming connections)
            const entryNode = findEntryNodeFromList(nodes);
            if (!entryNode) {
                throw new Error('No entry point found in visual flow');
            }

            return await executeVisualNode(entryNode, nodes);
        }

        function findEntryNodeFromList(nodes) {
            if (!nodes || nodes.length === 0) return null;
            
            const nodesWithIncoming = new Set();
            visualDesignerState.connections.forEach(conn => {
                nodesWithIncoming.add(conn.to);
            });
            
            for (const node of nodes) {
                if (!nodesWithIncoming.has(node.id)) {
                    return node;
                }
            }
            
            return nodes[0]; // fallback to first node
        }

        async function executeVisualNode(nodeData, allNodes) {
            const type = nodeData.template.type;
            const data = nodeData.data;
            
            addPlanExecutionLog(`🔸 ${type}: ${data.Key || nodeData.id}`);
            
            try {
                switch (type) {
                    case 'DECLARE':
                        await executeDSLDeclare(data);
                        break;
                    case 'ASSIGN':
                        await executeDSLAssign(data);
                        break;
                    case 'OUT':
                        await executeDSLOut(data);
                        break;
                    case 'IN':
                        await executeDSLIn(data);
                        break;
                    case 'CALL':
                        await executeDSLCall(data);
                        break;
                    case 'GENERATE':
                        await executeDSLGenerate(data);
                        break;
                    case 'READ':
                        await executeDSLRead(data);
                        break;
                    case 'WRITE':
                        await executeDSLWrite(data);
                        break;
                    case 'IF':
                        const ifResult = await executeDSLIf(data);
                        // In full implementation, would branch based on result
                        break;
                    case 'WHILE':
                        await executeDSLWhile(nodeData, allNodes);
                        break;
                    default:
                        addPlanExecutionLog(`⚠️ Statement type '${type}' not implemented`);
                }
                
                // Execute connected nodes
                const nextNodes = getConnectedNodesFromList(nodeData, allNodes);
                for (const nextNode of nextNodes) {
                    await executeVisualNode(nextNode, allNodes);
                }
                
            } catch (error) {
                addPlanExecutionLog(`❌ Error in ${type}: ${error.message}`);
                throw error;
            }
        }

        function getConnectedNodesFromList(nodeData, allNodes) {
            return visualDesignerState.connections
                .filter(conn => conn.from === nodeData.id)
                .map(conn => allNodes.find(node => node.id === conn.to))
                .filter(node => node !== undefined);
        }

        // DSL Statement Implementations
        async function executeDSLDeclare(data) {
            const key = data.Key;
            if (!key) throw new Error('DECLARE: Key is required');
            
            let value = null;
            if (data.Expression) {
                value = interpolateDSLTemplate(data.Expression);
                
                // Type conversion
                switch (data.Type) {
                    case 'INTEGER':
                        value = parseInt(value, 10) || 0;
                        break;
                    case 'DOUBLE':
                        value = parseFloat(value) || 0.0;
                        break;
                    case 'BOOL':
                        value = value === 'true' || value === '1';
                        break;
                    default:
                        value = String(value);
                }
            }
            
            planExecutionState.variables.set(key, value);
            addPlanExecutionLog(`📝 Declared ${key} (${data.Type || 'STRING'}) = ${JSON.stringify(value)}`);
        }

        async function executeDSLAssign(data) {
            const key = data.Key;
            if (!key) throw new Error('ASSIGN: Key is required');
            
            const value = interpolateDSLTemplate(data.Template || '');
            planExecutionState.variables.set(key, value);
            
            addPlanExecutionLog(`✏️ Assigned ${key} = ${JSON.stringify(value)}`);
        }

        async function executeDSLOut(data) {
            const message = interpolateDSLTemplate(data.Template || '');
            addPlanExecutionLog(`💬 Output: ${message}`);
            
            // Show in execution UI
            showExecutionOutput(message);
        }

        async function executeDSLIn(data) {
            const key = data.Key;
            const label = data.Label || 'Please enter a value:';
            const type = data.Type || 'TEXT';
            const preset = data.Preset || '';
            
            if (!key) throw new Error('IN: Key is required');
            
            addPlanExecutionLog(`⏸️ Waiting for user input: ${label}`);
            
            try {
                const userInput = await showUserInputModal(key, label, type, preset);
                planExecutionState.variables.set(key, userInput);
                
                addPlanExecutionLog(`👤 User input: ${key} = ${JSON.stringify(userInput)}`);
                
            } catch (error) {
                addPlanExecutionLog(`❌ User input cancelled: ${error.message}`);
                throw error;
            }
        }

        async function executeDSLCall(data) {
            const toKey = data.ToKey;
            if (!toKey) throw new Error('CALL: ToKey is required');
            
            const targetAgent = planExecutionState.agentMap.get(toKey);
            if (!targetAgent) {
                throw new Error(`CALL: Agent '${toKey}' not found`);
            }
            
            const resultKey = data.Key;
            const variables = data.Variables ? data.Variables.split(',').map(v => v.trim()) : [];
            
            // Build context for called agent
            const callContext = {};
            variables.forEach(varName => {
                if (planExecutionState.variables.has(varName)) {
                    callContext[varName] = planExecutionState.variables.get(varName);
                }
            });
            
            addPlanExecutionLog(`📞 CALL ${toKey} with variables: [${variables.join(', ')}]`);
            
            // Execute the called agent
            const result = await executeDSLAgent(targetAgent, callContext);
            
            // Store result if requested
            if (resultKey) {
                const returnValue = result.__return__ || result;
                planExecutionState.variables.set(resultKey, returnValue);
                addPlanExecutionLog(`📥 CALL result stored in ${resultKey}: ${JSON.stringify(returnValue)}`);
            }
        }

        async function executeDSLGenerate(data) {
            const key = data.Key;
            if (!key) throw new Error('GENERATE: Key is required');
            
            const maxTokens = parseInt(data.MaxTokens) || 500;
            const creativity = data.Creativity || 'Balanced';
            const promptKeys = data.Keys ? data.Keys.split(',').map(k => k.trim()) : [];
            
            addPlanExecutionLog(`🤖 Generating content for ${key} (${maxTokens} tokens, ${creativity})`);
            
            // Build prompt from referenced prompt variables
            let finalPrompt = '';
            if (promptKeys.length > 0) {
                promptKeys.forEach(promptKey => {
                    const promptContent = planExecutionState.variables.get(promptKey);
                    if (promptContent) {
                        finalPrompt += promptContent + '\n';
                    }
                });
            } else {
                // Fallback to a generic prompt
                finalPrompt = `Generate content for: ${key}\n\nContext variables:\n`;
                planExecutionState.variables.forEach((value, varKey) => {
                    if (typeof value === 'string' && value.length < 100) {
                        finalPrompt += `- ${varKey}: ${value}\n`;
                    }
                });
            }
            
            try {
                // Try to use WebLLM if available
                let generatedContent;
                
                if (typeof CreateMLCEngine !== 'undefined' && window.webLLMEngine) {
                    addPlanExecutionLog(`🧠 Using WebLLM for generation...`);
                    
                    const response = await window.webLLMEngine.chat.completions.create({
                        messages: [
                            {
                                role: 'user',
                                content: finalPrompt
                            }
                        ],
                        max_tokens: maxTokens,
                        temperature: creativity === 'Creative' ? 0.9 : creativity === 'Focused' ? 0.3 : 0.7
                    });
                    
                    generatedContent = response.choices[0].message.content;
                    addPlanExecutionLog(`✨ WebLLM generated ${generatedContent.length} characters`);
                    
                } else {
                    // Fallback to sophisticated simulation
                    await sleep(1500);
                    
                    generatedContent = `# AI-Generated Content for ${key}

**Generation Parameters:**
- Max Tokens: ${maxTokens}
- Creativity Level: ${creativity}
- Prompt Sources: ${promptKeys.length > 0 ? promptKeys.join(', ') : 'Default context'}

**Context-Aware Generation:**
Based on the current execution context, this content addresses the key aspects of the task. The generation system has analyzed ${planExecutionState.variables.size} variables and ${planExecutionState.callStack.length} call stack levels.

**Key Insights:**
${Array.from(planExecutionState.variables.entries())
    .filter(([k, v]) => typeof v === 'string' && v.length > 10 && v.length < 200)
    .slice(0, 3)
    .map(([k, v]) => `• ${k}: ${v.substring(0, 100)}${v.length > 100 ? '...' : ''}`)
    .join('\n')}

**Generated Response:**
This sophisticated AI-generated content demonstrates contextual awareness and incorporates the specified creativity level of "${creativity}". The content is tailored to the current execution state and available variables.

*Generated at: ${new Date().toISOString()}*
*Session Variables: ${Array.from(planExecutionState.variables.keys()).join(', ')}*`;
                    
                    addPlanExecutionLog(`✨ Enhanced simulation generated ${generatedContent.length} characters`);
                }
                
                planExecutionState.variables.set(key, generatedContent);
                
            } catch (error) {
                addPlanExecutionLog(`❌ Generation failed: ${error.message}`);
                
                // Fallback content
                const fallbackContent = `Generation failed for ${key}. Error: ${error.message}`;
                planExecutionState.variables.set(key, fallbackContent);
            }
        }

        async function executeDSLRead(data) {
            const key = data.Key;
            const fileKey = data.FileKey;
            
            if (!key || !fileKey) throw new Error('READ: Key and FileKey are required');
            
            const storeFile = planExecutionState.storeIndex.get(fileKey);
            if (storeFile) {
                planExecutionState.variables.set(key, storeFile.content);
                addPlanExecutionLog(`📖 Read ${storeFile.content.length} characters from ${fileKey} into ${key}`);
            } else {
                planExecutionState.variables.set(key, '');
                addPlanExecutionLog(`⚠️ File ${fileKey} not found, set ${key} to empty string`);
            }
        }

        async function executeDSLWrite(data) {
            const keys = data.Key;
            const fileKey = data.FileKey;
            
            if (!keys || !fileKey) throw new Error('WRITE: Key and FileKey are required');
            
            // Handle multiple variables (comma-separated)
            const keyList = keys.split(',').map(k => k.trim());
            let combinedContent = '';
            
            keyList.forEach((key, index) => {
                const value = planExecutionState.variables.get(key);
                if (value !== undefined) {
                    combinedContent += (index > 0 ? '\n---\n' : '') + `${key}: ${JSON.stringify(value)}`;
                }
            });
            
            // Store in store index
            planExecutionState.storeIndex.set(fileKey, {
                key: fileKey,
                content: combinedContent,
                variables: keyList,
                timestamp: new Date().toISOString()
            });
            
            addPlanExecutionLog(`💾 Wrote ${combinedContent.length} characters from [${keyList.join(', ')}] to ${fileKey}`);
        }

        async function executeDSLIf(data) {
            const key = data.Key;
            const conditionType = data.ConditionType || 'Equal';
            const compareValue = interpolateDSLTemplate(data.Template || '');
            
            if (!key) throw new Error('IF: Key is required');
            
            const actualValue = String(planExecutionState.variables.get(key) || '');
            let conditionMet = false;
            
            switch (conditionType) {
                case 'Equal':
                    conditionMet = actualValue === compareValue;
                    break;
                case 'NotEqual':
                    conditionMet = actualValue !== compareValue;
                    break;
                case 'GreaterThan':
                    conditionMet = parseFloat(actualValue) > parseFloat(compareValue);
                    break;
                case 'LessThan':
                    conditionMet = parseFloat(actualValue) < parseFloat(compareValue);
                    break;
            }
            
            addPlanExecutionLog(`🔀 IF ${key} ${conditionType} "${compareValue}" → ${conditionMet ? 'TRUE' : 'FALSE'}`);
            return conditionMet;
        }

        async function executeDSLWhile(nodeData, allNodes) {
            const data = nodeData.data;
            const key = data.Key;
            const conditionType = data.ConditionType || 'Equal';
            const compareValue = interpolateDSLTemplate(data.Template || '');
            
            if (!key) throw new Error('WHILE: Key is required');
            
            let iterations = 0;
            const maxIterations = 100; // Safety limit
            
            while (iterations < maxIterations && planExecutionState.isRunning) {
                const actualValue = String(planExecutionState.variables.get(key) || '');
                let conditionMet = false;
                
                switch (conditionType) {
                    case 'Equal':
                        conditionMet = actualValue === compareValue;
                        break;
                    case 'NotEqual':
                        conditionMet = actualValue !== compareValue;
                        break;
                    case 'GreaterThan':
                        conditionMet = parseFloat(actualValue) > parseFloat(compareValue);
                        break;
                    case 'LessThan':
                        conditionMet = parseFloat(actualValue) < parseFloat(compareValue);
                        break;
                }
                
                if (!conditionMet) break;
                
                addPlanExecutionLog(`🔁 WHILE iteration ${iterations + 1}: ${key} ${conditionType} "${compareValue}"`);
                
                // Execute connected nodes
                const bodyNodes = getConnectedNodesFromList(nodeData, allNodes);
                for (const bodyNode of bodyNodes) {
                    await executeVisualNode(bodyNode, allNodes);
                }
                
                iterations++;
                await sleep(100);
            }
            
            if (iterations >= maxIterations) {
                addPlanExecutionLog(`⚠️ WHILE loop reached maximum iterations (${maxIterations})`);
            }
        }

        // Helper Functions
        function interpolateDSLTemplate(template) {
            if (!template) return '';
            
            let result = template;
            planExecutionState.variables.forEach((value, key) => {
                const regex = new RegExp(`#${key}#`, 'g');
                result = result.replace(regex, String(value));
            });
            
            return result;
        }

        function addPlanExecutionLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            planExecutionState.executionLog.push({ timestamp, message });
            console.log(`[${timestamp}] ${message}`);
            
            // Update execution UI if visible
            updateExecutionUI(message);
        }

        function showExecutionUI() {
            // Create execution monitoring modal
            const modal = document.createElement('div');
            modal.id = 'executionModal';
            modal.className = 'execution-modal';
            modal.innerHTML = `
                <div class="execution-dialog">
                    <div class="execution-header">
                        <h3>🚀 DSL Plan Execution</h3>
                        <button class="btn btn-icon" onclick="closeExecutionUI()">
                            <i class="material-icons">close</i>
                        </button>
                    </div>
                    <div class="execution-body">
                        <div class="execution-log" id="executionLogDisplay"></div>
                        <div class="execution-output" id="executionOutputDisplay"></div>
                    </div>
                    <div class="execution-footer">
                        <button class="btn btn-secondary" onclick="stopPlanExecution()">Stop Execution</button>
                        <button class="btn btn-primary" onclick="closeExecutionUI()">Close</button>
                    </div>
                </div>
            `;
            
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center;
                z-index: 10000;
            `;
            
            document.body.appendChild(modal);
        }

        function updateExecutionUI(message) {
            const logDisplay = document.getElementById('executionLogDisplay');
            if (logDisplay) {
                const logEntry = document.createElement('div');
                logEntry.textContent = message;
                logEntry.style.cssText = 'padding: 4px 0; border-bottom: 1px solid var(--border); font-family: monospace; font-size: 13px;';
                logDisplay.appendChild(logEntry);
                logDisplay.scrollTop = logDisplay.scrollHeight;
            }
        }

        function showExecutionOutput(message) {
            const outputDisplay = document.getElementById('executionOutputDisplay');
            if (outputDisplay) {
                const outputEntry = document.createElement('div');
                outputEntry.innerHTML = `<strong>Output:</strong> ${message}`;
                outputEntry.style.cssText = 'padding: 8px; margin: 4px 0; background: var(--surface-2); border-radius: 4px; border-left: 4px solid var(--primary);';
                outputDisplay.appendChild(outputEntry);
                outputDisplay.scrollTop = outputDisplay.scrollHeight;
            }
        }

        window.closeExecutionUI = function() {
            const modal = document.getElementById('executionModal');
            if (modal) {
                document.body.removeChild(modal);
            }
        };

        window.stopPlanExecution = function() {
            planExecutionState.isRunning = false;
            addPlanExecutionLog('⏹️ Execution stopped by user');
        };

        // Additional DSL Statement Handlers for Parsed XML
        async function executeDSLProp(props) {
            // PROP statements define agent parameters/properties
            const key = props.Key;
            const type = props.Type || 'STRING';
            
            if (!key) {
                addPlanExecutionLog(`⚠️ PROP statement missing Key`);
                return;
            }
            
            // PROP acts like DECLARE but for agent parameters
            let value = null;
            if (props.Expression) {
                value = interpolateDSLTemplate(props.Expression);
                
                // Type conversion
                switch (type) {
                    case 'INTEGER':
                        value = parseInt(value, 10) || 0;
                        break;
                    case 'DOUBLE':
                        value = parseFloat(value) || 0.0;
                        break;
                    case 'BOOL':
                        value = value === 'true' || value === '1';
                        break;
                    default:
                        value = String(value);
                }
            }
            
            planExecutionState.variables.set(key, value);
            addPlanExecutionLog(`🔧 PROP ${key} (${type}) = ${JSON.stringify(value)}`);
        }

        async function executeDSLChoice(props, statement) {
            const key = props.Key;
            if (!key) throw new Error('CHOICE: Key is required');
            
            // Extract PICK options from statement children
            const options = [];
            if (statement.children) {
                statement.children.forEach(child => {
                    if (child.type === 'PICK') {
                        options.push({
                            key: child.properties.Key,
                            description: child.properties.Description
                        });
                    }
                });
            }
            
            if (options.length === 0) {
                addPlanExecutionLog(`⚠️ CHOICE ${key} has no options`);
                return;
            }
            
            addPlanExecutionLog(`🔘 CHOICE ${key} with ${options.length} options`);
            
            // Show choice modal
            try {
                const choice = await showChoiceModal(key, options);
                planExecutionState.variables.set(key, choice);
                addPlanExecutionLog(`👤 User selected: ${choice}`);
            } catch (error) {
                addPlanExecutionLog(`❌ Choice cancelled: ${error.message}`);
                throw error;
            }
        }

        async function executeDSLPrompt(props, statement) {
            const key = props.Key;
            if (!key) throw new Error('PROMPT: Key is required');
            
            let promptText = '';
            
            // Build prompt from SECTION children
            if (statement.children) {
                statement.children.forEach(section => {
                    if (section.type === 'SECTION') {
                        const sectionType = section.properties.Type || 'user';
                        promptText += `[${sectionType.toUpperCase()}]\n`;
                        
                        if (section.children) {
                            section.children.forEach(line => {
                                if (line.type === 'LINE') {
                                    const lineText = interpolateDSLTemplate(line.properties.Template || '');
                                    promptText += lineText + '\n';
                                }
                            });
                        }
                        promptText += '\n';
                    }
                });
            }
            
            addPlanExecutionLog(`💭 Built prompt ${key}: ${promptText.length} characters`);
            
            // Store prompt for later GENERATE use
            planExecutionState.variables.set(key, promptText);
            return promptText;
        }

        async function executeDSLReturn(props) {
            const template = props.Template;
            const type = props.Type || 'STRING';
            
            let returnValue = interpolateDSLTemplate(template || '');
            
            // Type conversion
            switch (type) {
                case 'INTEGER':
                    returnValue = parseInt(returnValue, 10) || 0;
                    break;
                case 'DOUBLE':
                    returnValue = parseFloat(returnValue) || 0.0;
                    break;
                case 'BOOL':
                    returnValue = returnValue === 'true' || returnValue === '1';
                    break;
                default:
                    returnValue = String(returnValue);
            }
            
            addPlanExecutionLog(`🔄 RETURN ${type}: ${JSON.stringify(returnValue)}`);
            return returnValue;
        }

        async function executeDSLWhileStatement(props, statement) {
            const key = props.Key;
            const conditionType = props.ConditionType || 'Equal';
            const compareValue = interpolateDSLTemplate(props.Template || '');
            
            if (!key) throw new Error('WHILE: Key is required');
            
            let iterations = 0;
            const maxIterations = 100;
            
            addPlanExecutionLog(`🔁 Starting WHILE loop: ${key} ${conditionType} "${compareValue}"`);
            
            while (iterations < maxIterations && planExecutionState.isRunning) {
                const actualValue = String(planExecutionState.variables.get(key) || '');
                let conditionMet = false;
                
                switch (conditionType) {
                    case 'Equal':
                        conditionMet = actualValue === compareValue;
                        break;
                    case 'NotEqual':
                        conditionMet = actualValue !== compareValue;
                        break;
                    case 'GreaterThan':
                        conditionMet = parseFloat(actualValue) > parseFloat(compareValue);
                        break;
                    case 'LessThan':
                        conditionMet = parseFloat(actualValue) < parseFloat(compareValue);
                        break;
                }
                
                if (!conditionMet) {
                    addPlanExecutionLog(`🔁 WHILE condition false, exiting loop after ${iterations} iterations`);
                    break;
                }
                
                addPlanExecutionLog(`🔁 WHILE iteration ${iterations + 1}`);
                
                // Execute body statements (would need to parse statement children)
                // For now, just increment a counter to prevent infinite loops
                if (statement.children && statement.children.length > 0) {
                    // Execute child statements here
                    addPlanExecutionLog(`⚠️ WHILE body execution not fully implemented`);
                }
                
                iterations++;
                await sleep(100);
                
                // Safety break for demo
                if (iterations >= 3) {
                    addPlanExecutionLog(`🛡️ WHILE loop limited to 3 iterations for demo`);
                    break;
                }
            }
            
            if (iterations >= maxIterations) {
                addPlanExecutionLog(`⚠️ WHILE loop reached maximum iterations (${maxIterations})`);
            }
        }

        async function executeDSLSwitch(props, statement) {
            const key = props.Key;
            if (!key) throw new Error('SWITCH: Key is required');
            
            const switchValue = String(planExecutionState.variables.get(key) || '');
            addPlanExecutionLog(`🔀 SWITCH on ${key} = "${switchValue}"`);
            
            // Find matching CASE
            if (statement.children) {
                for (const child of statement.children) {
                    if (child.type === 'CASE') {
                        const caseValue = child.properties.Template || '';
                        if (switchValue === caseValue) {
                            addPlanExecutionLog(`✅ Matched CASE: ${caseValue}`);
                            
                            // Execute case body (would need child statement execution)
                            if (child.children && child.children.length > 0) {
                                addPlanExecutionLog(`⚠️ CASE body execution not fully implemented`);
                            }
                            return;
                        }
                    }
                }
            }
            
            addPlanExecutionLog(`🔀 No matching CASE found for "${switchValue}"`);
        }

        // Choice Modal
        function showChoiceModal(key, options) {
            return new Promise((resolve, reject) => {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                
                let optionsHtml = '';
                options.forEach(option => {
                    optionsHtml += `
                        <div class="choice-option" onclick="selectChoice('${option.key}')">
                            <strong>${option.key}</strong>
                            <div style="font-size: 13px; color: var(--text-muted);">${option.description}</div>
                        </div>
                    `;
                });
                
                modal.innerHTML = `
                    <div class="modal-dialog">
                        <div class="modal-header">
                            <h3>Make a Choice: ${key}</h3>
                        </div>
                        <div class="modal-body">
                            <div class="choice-options">
                                ${optionsHtml}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').reject('cancelled')">Cancel</button>
                        </div>
                    </div>
                `;
                
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center;
                    z-index: 10000;
                `;
                
                // Add choice option styling
                const style = document.createElement('style');
                style.textContent = `
                    .choice-options { display: flex; flex-direction: column; gap: 8px; }
                    .choice-option { 
                        padding: 12px 16px; border: 2px solid var(--border); border-radius: var(--radius);
                        cursor: pointer; transition: all 0.2s; background: var(--surface);
                    }
                    .choice-option:hover { 
                        border-color: var(--primary); background: var(--surface-2); 
                    }
                `;
                document.head.appendChild(style);
                
                modal.resolve = resolve;
                modal.reject = reject;
                
                window.selectChoice = function(choiceKey) {
                    document.body.removeChild(modal);
                    document.head.removeChild(style);
                    resolve(choiceKey);
                    delete window.selectChoice;
                };
                
                document.body.appendChild(modal);
            });
        }

        // Initialize the application
        init();
    </script>
</body>
</html>