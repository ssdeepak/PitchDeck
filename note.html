<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NeuroNotes</title>
    <!-- Optional: <link rel="manifest" href="manifest.json"> -->

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />

    <!-- Material Icons -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />

    <style>
      /* Hamburger Menu Buttons */
      .hamburger-btn {
        position: fixed;
        top: 80px;
        z-index: 30;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 12px;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        transition: all 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .hamburger-btn:hover {
        background: #f5f5f5;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      .hamburger-btn .material-icons {
        font-size: 24px;
        color: #333;
      }
      #leftHamburger {
        left: 16px;
      }
      #rightHamburger {
        right: 16px;
      }

      /* Drawer Overlay */
      #drawerOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.4);
        z-index: 19;
        display: none;
        opacity: 0;
        transition: opacity 0.3s;
      }
      #drawerOverlay.show {
        display: block;
        opacity: 1;
      }

      /* Left Drawer (Canvas List) */
      #sidebar {
        position: fixed;
        left: -280px;
        top: 0;
        width: 280px;
        height: 100vh;
        background: #fff;
        box-shadow: 2px 0 12px rgba(0, 0, 0, 0.08);
        z-index: 20;
        display: flex;
        flex-direction: column;
        transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }
      #sidebar.open {
        left: 0;
      }
      #sidebar .sidebar-title {
        font-weight: 700;
        font-size: 1.2rem;
        padding: 18px 16px 8px 16px;
        border-bottom: 1px solid #eee;
      }
      .drawer-actions {
        padding: 12px;
        border-top: 1px solid #eee;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .drawer-btn {
        padding: 12px;
        border: none;
        border-radius: 8px;
        background: #4caf50;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.95rem;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }
      .drawer-btn .material-icons {
        font-size: 20px;
      }
      .drawer-btn:hover {
        background: #45a049;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
      }
      #new-canvas {
        background: #2196f3;
      }
      #new-canvas:hover {
        background: #1976d2;
        box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
      }
      #canvas-list {
        flex: 1;
        overflow-y: auto;
        padding: 8px 0;
      }
      .canvas-list-item {
        padding: 10px 16px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .canvas-list-item .canvas-name {
        font-weight: bold;
        font-size: 1rem;
      }
      .canvas-list-item .canvas-id {
        font-size: 0.9em;
        color: #888;
        margin-left: 8px;
      }
      .canvas-list-item .canvas-delete {
        margin-left: 12px;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1.1rem;
      }
      #save-canvas {
        margin: 12px 16px 16px 16px;
        padding: 12px 0;
        font-size: 1rem;
        background: #2196f3;
        color: #fff;
        border: none;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
        cursor: pointer;
      }

      /* Right Drawer (LLM Config) */
      #rightDrawer {
        position: fixed;
        right: -400px;
        top: 0;
        width: 400px;
        height: 100vh;
        background: #fff;
        box-shadow: -2px 0 12px rgba(0, 0, 0, 0.08);
        z-index: 20;
        display: flex;
        flex-direction: column;
        transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow-y: auto;
      }
      #rightDrawer.open {
        right: 0;
      }
      .drawer-header {
        padding: 20px;
        border-bottom: 2px solid #e0e0e0;
        background: #fafafa;
        font-weight: 700;
        font-size: 1.2rem;
        display: flex;
        align-items: center;
        gap: 12px;
        flex-shrink: 0;
      }
      .drawer-header .material-icons {
        margin-right: 8px;
      }
      .drawer-content {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
      }

      /* LLM Configuration Styles */
      .config-section {
        margin-bottom: 24px;
        padding: 16px;
        background: #f9f9f9;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
      }
      .config-section h3 {
        margin: 0 0 12px 0;
        font-size: 1rem;
        font-weight: 600;
        color: #333;
      }
      .form-group {
        margin-bottom: 16px;
      }
      .form-group label {
        display: block;
        margin-bottom: 6px;
        font-weight: 500;
        font-size: 0.9rem;
        color: #555;
      }
      .form-group select,
      .form-group input {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 0.9rem;
        background: #fff;
      }
      .form-group select:focus,
      .form-group input:focus {
        outline: none;
        border-color: #2196f3;
        box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.1);
      }
      .form-group small {
        display: block;
        margin-top: 4px;
        font-size: 0.8rem;
        color: #888;
      }
      .provider-status {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
      }
      .provider-status.online {
        background: #10b981;
        color: white;
      }
      .provider-status.offline {
        background: #6b7280;
        color: white;
      }
      .btn-group {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }
      .btn-sm {
        padding: 8px 16px;
        font-size: 0.85rem;
      }
      .loading-indicator {
        display: none;
        padding: 12px;
        background: #fff9c4;
        border-radius: 6px;
        margin-top: 12px;
        font-size: 0.9rem;
        color: #333;
      }
      .loading-indicator.active {
        display: block;
      }
      .hidden {
        display: none;
      }
      .model-info-text {
        font-size: 0.85rem;
        color: #666;
      }
      .status-bar {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 12px;
      }
      #testPrompt {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 6px;
      }
      #testResponse {
        margin-top: 12px;
        padding: 12px;
        background: #f5f5f5;
        border-radius: 6px;
        font-size: 0.85rem;
        display: none;
      }
      #testResponse.show {
        display: block;
      }

      /* Responsive Drawer Widths */
      @media (max-width: 768px) {
        #sidebar {
          width: 85vw;
          left: -85vw;
        }
        #rightDrawer {
          width: 90vw;
          right: -90vw;
        }
        .hamburger-btn {
          top: 70px;
        }
      }

      #canvas-container {
        margin-left: 0;
      }
      :root {
        --bg-color: #f8f7f4;
        --note-yellow: #fff9c4;
        --note-pink: #f8bbd0;
        --note-teal: #b2dfdb;
        --note-purple: #d1c4e9;
        --text-color: #2f4f4f;
        --border-color: #e0e0e0;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --line-color: #9e9e9e;
        --line-hover-color: #2f4f4f;
        --label-bg: rgba(255, 255, 255, 0.8);
      }

      body {
        font-family: "Inter", sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      /* Header */
      .header {
        display: flex;
        align-items: center;
        padding: 12px 24px;
        border-bottom: 1px solid var(--border-color);
        background-color: white;
        flex-shrink: 0;
        flex-wrap: wrap;
        gap: 16px;
      }
      .logo {
        font-weight: 700;
        font-size: 1.5rem;
      }
      .logo span {
        color: #7c4dff;
      }
      .llm-controls {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-left: auto;
      }
      #analyze-button {
        background-color: #673ab7;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.2s;
        box-shadow: 0 2px 4px var(--shadow-color);
      }
      #analyze-button:hover {
        background-color: #512da8;
      }
      #analyze-button:active {
        transform: scale(0.98);
      }
      #analyze-button:disabled {
        background-color: #bdbdbd;
        cursor: not-allowed;
      }
      #llm-status {
        font-size: 0.875rem;
        color: #757575;
        min-width: 220px;
        text-align: right;
      }
      #add-note-button {
        background-color: #2196f3;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.3s;
        box-shadow: 0 2px 4px var(--shadow-color);
      }
      #add-note-button:hover {
        background-color: #1976d2;
      }

      /* Canvas */
      #canvas-container {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-image: radial-gradient(#e0e0e0 1px, transparent 0);
        background-size: 20px 20px;
      }

      #beautify-button {
        background-color: #009688;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.3s;
        box-shadow: 0 2px 4px var(--shadow-color);
      }
      #beautify-button:hover {
        background-color: #00796b;
      }
      #note-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      #semantic-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
      }
      #semantic-overlay .connection {
        fill: none;
        stroke-width: 4;
        transition: all 0.3s ease;
        opacity: 0.85;
      }
      #semantic-overlay .connection.temporal {
        stroke-dasharray: 10, 5;
        animation: dash 1.6s linear infinite;
      }
      #semantic-overlay .connection:hover {
        stroke-width: 5;
        opacity: 1;
        filter: drop-shadow(0 0 6px currentColor);
      }
      #semantic-overlay .connection-label {
        font-size: 12px;
        text-anchor: middle;
        pointer-events: all;
      }
      .label-bg {
        fill: var(--label-bg);
        stroke: #ddd;
        stroke-width: 0.7;
      }
      .tooltip {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 0.8rem;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 100;
        max-width: 280px;
      }

      @keyframes dash {
        to {
          stroke-dashoffset: -20;
        }
      }

      /* Arrow markers */
      svg defs marker path {
        fill: var(--line-color);
      }

      /* Notes */
      .note {
        position: absolute;
        min-width: 180px;
        min-height: 180px;
        width: 220px;
        height: 220px;
        padding: 15px;
        box-shadow: 0 4px 12px var(--shadow-color);
        border-radius: 8px;
        border-top: 1px solid rgba(255, 255, 255, 0.6);
        border-left: 1px solid rgba(255, 255, 255, 0.6);
        cursor: grab;
        display: flex;
        flex-direction: column;
        transition: box-shadow 0.3s, transform 0.2s;
        resize: both;
        overflow: auto;
      }
      .note::after {
        content: "";
        position: absolute;
        bottom: 2px;
        right: 2px;
        width: 14px;
        height: 14px;
        cursor: se-resize;
        background: linear-gradient(
          135deg,
          transparent 45%,
          rgba(0, 0, 0, 0.15) 50%,
          transparent 55%
        );
        pointer-events: none;
      }
      .note:hover {
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      }
      .note.dragging {
        cursor: grabbing;
        box-shadow: 0 12px 32px rgba(0, 0, 0, 0.2);
        transform: scale(1.05);
        z-index: 10;
      }
      .note.color-yellow {
        background-color: var(--note-yellow);
      }
      .note.color-pink {
        background-color: var(--note-pink);
      }
      .note.color-teal {
        background-color: var(--note-teal);
      }
      .note.color-purple {
        background-color: var(--note-purple);
      }
      .note-header {
        position: relative;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-bottom: 5px;
        padding-left: 90px;
      }
      .note-actions {
        display: flex;
        gap: 8px;
      }
      .note-delete,
      .note-color {
        border: none;
        background: none;
        cursor: pointer;
        opacity: 0.6;
        transition: opacity 0.2s;
        padding: 2px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .note-delete:hover,
      .note-color:hover {
        opacity: 1;
      }
      .note-delete .material-icons,
      .note-color .material-icons {
        font-size: 20px;
      }
      .note-title {
        font-weight: 600;
        font-size: 0.95rem;
        background: transparent;
        border: none;
        width: 75%;
      }
      .note-title:focus {
        outline: none;
      }
      .note-content {
        flex-grow: 1;
        width: 100%;
        height: 100%;
        background: transparent;
        border: none;
        resize: none;
        font-family: "Inter", sans-serif;
        font-size: 1rem;
        color: var(--text-color);
      }
      .note-content:focus {
        outline: none;
      }

      /* Step 1.5: Hierarchy Controls */
      .hierarchy-controls {
        position: absolute;
        top: 5px;
        left: 5px;
        display: flex;
        gap: 4px;
        z-index: 10;
      }

      .hierarchy-controls button {
        width: 28px;
        height: 28px;
        border: 1px solid rgba(0, 0, 0, 0.15);
        border-radius: 4px;
        cursor: pointer;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        opacity: 0.9;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      .hierarchy-controls button .material-icons {
        font-size: 18px;
      }

      .hierarchy-controls button:hover {
        opacity: 1;
        transform: scale(1.15);
      }

      .expand-btn {
        background: rgba(100, 150, 255, 0.5);
        color: #1a1a1a;
        font-weight: bold;
      }

      .add-child-btn {
        background: rgba(50, 200, 100, 0.5);
        color: #1a4d1a;
        font-weight: bold;
        font-size: 15px;
      }

      .deep-dive-btn {
        background: rgba(255, 150, 50, 0.5);
        font-size: 13px;
      }

      .child-note {
        border-left: 4px solid rgba(0, 0, 0, 0.25);
        padding-left: 8px;
      }

      .parent-note {
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        font-weight: 500;
      }

      .parent-note .note-title {
        font-weight: 700;
      }

      /* Step 2: Template Wizard */
      .wizard-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.6);
        z-index: 100;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .wizard-modal.show {
        display: flex;
      }

      .wizard-content {
        background: white;
        border-radius: 16px;
        max-width: 900px;
        width: 100%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      .wizard-header {
        padding: 24px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .wizard-header h2 {
        margin: 0;
        font-size: 1.5rem;
        color: #333;
      }

      .wizard-close {
        width: 32px;
        height: 32px;
        border: none;
        background: #f5f5f5;
        border-radius: 50%;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }

      .wizard-close:hover {
        background: #e0e0e0;
        transform: scale(1.1);
      }

      .wizard-body {
        padding: 24px;
      }

      .template-grid {
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .template-category h3 {
        margin: 0 0 12px 0;
        font-size: 1.1rem;
        color: #666;
      }

      .template-card {
        background: white;
        border: 2px solid #e0e0e0;
        border-radius: 12px;
        padding: 16px;
        text-align: left;
        cursor: pointer;
        transition: all 0.2s;
        width: 100%;
        margin-bottom: 8px;
      }

      .template-card:hover {
        border-color: #4caf50;
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.2);
        transform: translateY(-2px);
      }

      .template-icon {
        font-size: 2rem;
        margin-bottom: 8px;
      }

      .template-title {
        font-weight: 600;
        font-size: 1.1rem;
        color: #333;
        margin-bottom: 4px;
      }

      .template-desc {
        font-size: 0.9rem;
        color: #666;
        line-height: 1.4;
      }

      /* Responsive */
      @media (max-width: 768px) {
        .header {
          flex-direction: column;
          align-items: flex-start;
        }
        .llm-controls {
          width: 100%;
          margin-left: 0;
          justify-content: space-between;
        }
        .hierarchy-controls button {
          width: 26px;
          height: 26px;
          font-size: 13px;
        }
        .wizard-content {
          max-height: 95vh;
        }
        .wizard-header h2 {
          font-size: 1.2rem;
        }
      }
    </style>
  </head>
  <body>
    <!-- Hamburger Menus -->
    <button id="leftHamburger" class="hamburger-btn" title="Saved Canvases">
      <span class="material-icons">folder_open</span>
    </button>
    <button id="rightHamburger" class="hamburger-btn" title="LLM Configuration">
      <span class="material-icons">settings</span>
    </button>

    <!-- Drawer Overlay -->
    <div id="drawerOverlay"></div>

    <!-- Header -->
    <div class="header">
      <div class="logo">Neuro<span>Notes</span></div>
      <button id="add-note-button">Add Note +</button>
      <div class="llm-controls">
        <div id="llm-status">Initializing AI engine‚Ä¶</div>
        <button id="analyze-button" disabled>Analyze Notes</button>
        <button id="beautify-button" disabled>Beautify Layout</button>
      </div>
    </div>

    <!-- Left Drawer: Saved Canvases -->
    <div id="sidebar">
      <div class="drawer-header">
        <span class="material-icons">folder_open</span>
        <span>Saved Canvases</span>
      </div>
      <div id="canvas-list"></div>
      <div class="drawer-actions">
        <button id="new-canvas" class="drawer-btn">
          <span class="material-icons">add_circle_outline</span>
          <span>New Canvas</span>
        </button>
        <button id="save-canvas" class="drawer-btn">
          <span class="material-icons">save</span>
          <span>Save Current</span>
        </button>
      </div>
    </div>

    <!-- Right Drawer: LLM Configuration -->
    <div id="rightDrawer">
      <div class="drawer-header">
        <span class="material-icons">smart_toy</span>
        <span>LLM Configuration</span>
      </div>
      <div class="drawer-content">
        <!-- Model Selection -->
        <div class="config-section">
          <h3>Model Provider</h3>
          <div class="form-group">
            <label>Provider:</label>
            <select id="modelProvider">
              <option value="webllm">WebLLM (Browser)</option>
              <option value="openai">OpenAI API</option>
              <option value="github">GitHub Models (Free)</option>
              <option value="gemini">Google Gemini</option>
              <option value="groq">Groq (Fast)</option>
              <option value="ollama">Ollama (Local)</option>
              <option value="custom">Custom Endpoint</option>
            </select>
          </div>

          <!-- API Key Section -->
          <div class="form-group hidden" id="apiKeyGroup">
            <label>API Key:</label>
            <input
              type="password"
              id="apiKeyInput"
              placeholder="Enter API key..."
            />
            <small id="apiKeyHelp">Required for this provider</small>
          </div>

          <!-- Custom Endpoint -->
          <div class="form-group hidden" id="endpointGroup">
            <label>API Endpoint:</label>
            <input
              type="url"
              id="endpointInput"
              placeholder="https://api.example.com/v1/chat/completions"
            />
            <small>Custom API endpoint URL</small>
          </div>

          <!-- Model Selection -->
          <div class="form-group">
            <label>Model:</label>
            <select id="modelSelect">
              <option value="">Select a model...</option>
            </select>
            <div class="loading-indicator" id="modelLoading">
              Loading models...
            </div>
          </div>

          <div class="status-bar">
            <span class="provider-status" id="providerStatus">Offline</span>
            <span id="currentModelInfo" class="model-info-text"
              >No model loaded</span
            >
          </div>

          <div class="btn-group">
            <button class="btn btn-primary btn-sm" id="loadModelBtn" disabled>
              Load Model
            </button>
            <button class="btn btn-secondary btn-sm" id="refreshModelsBtn">
              Refresh
            </button>
          </div>
        </div>

        <!-- Generation Parameters -->
        <div class="config-section">
          <h3>Generation Parameters</h3>
          <div class="form-group">
            <label>Temperature: <span id="tempValue">0.7</span></label>
            <input
              type="range"
              id="temperature"
              min="0"
              max="2"
              step="0.1"
              value="0.7"
            />
            <small>Lower = focused, Higher = creative</small>
          </div>
          <div class="form-group">
            <label>Max Tokens: <span id="tokensValue">512</span></label>
            <input
              type="range"
              id="maxTokens"
              min="50"
              max="4096"
              step="50"
              value="512"
            />
            <small>Maximum response length</small>
          </div>
        </div>

        <!-- Test Section -->
        <div class="config-section">
          <h3>Test Configuration</h3>
          <div class="form-group">
            <label>Test Prompt:</label>
            <textarea id="testPrompt" rows="3">
Hello! Please respond to test the configuration.</textarea
            >
          </div>
          <button class="btn btn-primary btn-sm" id="testConfigBtn" disabled>
            Test
          </button>
          <div id="testResponse"></div>
        </div>
      </div>
    </div>

    <!-- Main -->
    <div id="canvas-container">
      <div id="note-canvas"></div>
      <svg id="semantic-overlay"></svg>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <!-- Step 2: Template Wizard Modal -->
    <div id="templateWizard" class="wizard-modal">
      <div class="wizard-content">
        <div class="wizard-header">
          <h2>
            <span class="material-icons">auto_awesome</span>What do you want to
            create?
          </h2>
          <button class="wizard-close" onclick="closeTemplateWizard()">
            <span class="material-icons">close</span>
          </button>
        </div>

        <div class="wizard-body">
          <div class="template-grid">
            <!-- Documents -->
            <div class="template-category">
              <h3>üìÑ Documents</h3>
              <button class="template-card" onclick="selectTemplate('prd')">
                <div class="template-icon">üìã</div>
                <div class="template-title">Product Requirements</div>
                <div class="template-desc">
                  Detailed PRD with features, user stories, and acceptance
                  criteria
                </div>
              </button>
              <button class="template-card" onclick="selectTemplate('blog')">
                <div class="template-icon">‚úçÔ∏è</div>
                <div class="template-title">Blog Post</div>
                <div class="template-desc">
                  Engaging article with intro, body, and conclusion
                </div>
              </button>
              <button
                class="template-card"
                onclick="selectTemplate('research')"
              >
                <div class="template-icon">üî¨</div>
                <div class="template-title">Research Paper</div>
                <div class="template-desc">
                  Academic paper with abstract, methodology, and findings
                </div>
              </button>
            </div>

            <!-- Technical -->
            <div class="template-category">
              <h3>üíª Technical</h3>
              <button
                class="template-card"
                onclick="selectTemplate('architecture')"
              >
                <div class="template-icon">üèóÔ∏è</div>
                <div class="template-title">System Architecture</div>
                <div class="template-desc">
                  Technical design with components, data flow, and decisions
                </div>
              </button>
              <button class="template-card" onclick="selectTemplate('api')">
                <div class="template-icon">üîå</div>
                <div class="template-title">API Documentation</div>
                <div class="template-desc">
                  Endpoints, parameters, responses, and examples
                </div>
              </button>
            </div>

            <!-- Business -->
            <div class="template-category">
              <h3>üíº Business</h3>
              <button
                class="template-card"
                onclick="selectTemplate('proposal')"
              >
                <div class="template-icon">üìä</div>
                <div class="template-title">Business Proposal</div>
                <div class="template-desc">
                  Problem, solution, timeline, and ROI analysis
                </div>
              </button>
              <button class="template-card" onclick="selectTemplate('roadmap')">
                <div class="template-icon">üó∫Ô∏è</div>
                <div class="template-title">Product Roadmap</div>
                <div class="template-desc">
                  Phased plan with milestones and deliverables
                </div>
              </button>
            </div>

            <!-- Tasks -->
            <div class="template-category">
              <h3>‚úÖ Tasks</h3>
              <button class="template-card" onclick="selectTemplate('tasks')">
                <div class="template-icon">üìù</div>
                <div class="template-title">Task List</div>
                <div class="template-desc">
                  Actionable tasks with priorities and estimates
                </div>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- App script -->
    <script type="module">
      // IndexedDB helpers
      const DB_NAME = "neuronotes_db";
      const DB_STORE = "canvases";
      function openDB() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, 1);
          req.onupgradeneeded = () => {
            req.result.createObjectStore(DB_STORE, {
              keyPath: "id",
              autoIncrement: true,
            });
          };
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }
      async function saveCanvasToDB(canvas) {
        const db = await openDB();
        const tx = db.transaction(DB_STORE, "readwrite");
        const store = tx.objectStore(DB_STORE);
        await store.put(canvas);
        await tx.complete;
        db.close();
      }
      async function loadCanvasesFromDB() {
        const db = await openDB();
        const tx = db.transaction(DB_STORE, "readonly");
        const store = tx.objectStore(DB_STORE);
        const req = store.getAll();
        return new Promise((resolve, reject) => {
          req.onsuccess = () => {
            db.close();
            resolve(req.result);
          };
          req.onerror = () => {
            db.close();
            reject(req.error);
          };
        });
      }
      async function deleteCanvasFromDB(id) {
        const db = await openDB();
        const tx = db.transaction(DB_STORE, "readwrite");
        const store = tx.objectStore(DB_STORE);
        await store.delete(id);
        await tx.complete;
        db.close();
      }
      import { CreateWebWorkerMLCEngine } from "https://esm.run/@mlc-ai/web-llm";

      // Elements
      const noteCanvas = document.getElementById("note-canvas");
      const addNoteButton = document.getElementById("add-note-button");
      const analyzeButton = document.getElementById("analyze-button");
      const beautifyButton = document.getElementById("beautify-button");
      const llmStatus = document.getElementById("llm-status");
      const tooltip = document.getElementById("tooltip");
      const canvasContainer = document.getElementById("canvas-container");

      // App state
      const appState = {
        notes: [], // {id, x, y, title, text, color, parentId}
        connections: [], // {sourceId, targetId, type, reason, weight, directed, confidence}
        engine: null,
        // Updated model
        modelName: "Qwen2.5-1.5B-Instruct-q4f32_1-MLC",
        // Infinite canvas transform
        pan: { x: 0, y: 0 },
        zoom: 1,
        // Step 1.5: Hierarchical structure
        noteHierarchy: {}, // {parentId: [childId1, childId2...]}
        collapsedNotes: new Set(), // Track collapsed parent notes
        // IndexedDB canvas tracking
        currentCanvasId: null,
        currentCanvasName: "Untitled Canvas",
        isDirty: false, // Track unsaved changes
      };

      // LLM Configuration State
      const llmConfig = {
        provider: "webllm",
        model: "",
        apiKey: "",
        endpoint: "",
        temperature: 0.7,
        maxTokens: 512,
        isLoaded: false,
      };

      // Provider Model Lists
      const providerModels = {
        webllm: [
          "Qwen2.5-1.5B-Instruct-q4f32_1-MLC",
          "Qwen2.5-0.5B-Instruct-q4f16_1-MLC",
          "Phi-3.5-mini-instruct-q4f16_1-MLC",
          "Llama-3.2-1B-Instruct-q4f16_1-MLC",
          "gemma-2-2b-it-q4f16_1-MLC",
        ],
        openai: ["gpt-4o-mini", "gpt-4o", "gpt-4-turbo", "gpt-3.5-turbo"],
        github: [
          "gpt-4o-mini",
          "gpt-4o",
          "Phi-3-medium-128k-instruct",
          "Mistral-large",
        ],
        gemini: ["gemini-1.5-flash", "gemini-1.5-pro", "gemini-pro"],
        groq: [
          "llama-3.1-70b-versatile",
          "llama-3.1-8b-instant",
          "mixtral-8x7b-32768",
        ],
        ollama: ["llama3.2", "mistral", "phi3", "qwen2.5"],
        custom: [],
      };

      // Drawer Management
      function toggleDrawer(drawerId) {
        const drawer = document.getElementById(drawerId);
        const overlay = document.getElementById("drawerOverlay");
        const isOpen = drawer.classList.contains("open");

        if (isOpen) {
          drawer.classList.remove("open");
          overlay.classList.remove("show");
        } else {
          // Close other drawer
          document.querySelectorAll("#sidebar, #rightDrawer").forEach((d) => {
            if (d.id !== drawerId) d.classList.remove("open");
          });
          drawer.classList.add("open");
          overlay.classList.add("show");
        }
      }

      document
        .getElementById("leftHamburger")
        .addEventListener("click", () => toggleDrawer("sidebar"));
      document
        .getElementById("rightHamburger")
        .addEventListener("click", () => toggleDrawer("rightDrawer"));
      document.getElementById("drawerOverlay").addEventListener("click", () => {
        document
          .querySelectorAll("#sidebar, #rightDrawer")
          .forEach((d) => d.classList.remove("open"));
        document.getElementById("drawerOverlay").classList.remove("show");
      });

      // LLM Configuration Management
      function updateProviderUI() {
        const provider = document.getElementById("modelProvider").value;
        const apiKeyGroup = document.getElementById("apiKeyGroup");
        const endpointGroup = document.getElementById("endpointGroup");
        const apiKeyHelp = document.getElementById("apiKeyHelp");

        // Show/hide API key based on provider
        const needsApiKey = ["openai", "github", "gemini", "groq"].includes(
          provider
        );
        apiKeyGroup.classList.toggle("hidden", !needsApiKey);
        endpointGroup.classList.toggle("hidden", provider !== "custom");

        // Update help text
        const helpTexts = {
          openai: "Get your API key from platform.openai.com",
          github: "Get your token from github.com/settings/tokens",
          gemini: "Get your API key from makersuite.google.com/app/apikey",
          groq: "Get your API key from console.groq.com",
        };
        apiKeyHelp.textContent = helpTexts[provider] || "API key required";

        // Load models for provider
        loadModelsForProvider(provider);

        // Load saved config
        loadProviderConfig(provider);
      }

      function loadModelsForProvider(provider) {
        const modelSelect = document.getElementById("modelSelect");
        const models = providerModels[provider] || [];

        modelSelect.innerHTML = '<option value="">Select a model...</option>';
        models.forEach((model) => {
          const option = document.createElement("option");
          option.value = model;
          option.textContent = model;
          modelSelect.appendChild(option);
        });

        document.getElementById("loadModelBtn").disabled = true;
      }

      function saveProviderConfig() {
        const provider = document.getElementById("modelProvider").value;
        const config = {
          provider,
          model: document.getElementById("modelSelect").value,
          apiKey: document.getElementById("apiKeyInput").value,
          endpoint: document.getElementById("endpointInput").value,
          temperature: parseFloat(document.getElementById("temperature").value),
          maxTokens: parseInt(document.getElementById("maxTokens").value),
        };

        localStorage.setItem("neuronotes_llm_config", JSON.stringify(config));
        localStorage.setItem(
          `llm_provider_${provider}`,
          JSON.stringify({
            apiKey: config.apiKey,
            endpoint: config.endpoint,
          })
        );

        Object.assign(llmConfig, config);
        console.log("LLM config saved:", provider, config.model);
      }

      function loadProviderConfig(provider) {
        const saved = localStorage.getItem(`llm_provider_${provider}`);
        if (saved) {
          try {
            const config = JSON.parse(saved);
            document.getElementById("apiKeyInput").value = config.apiKey || "";
            document.getElementById("endpointInput").value =
              config.endpoint || "";
          } catch (e) {}
        }
      }

      function loadSavedLLMConfig() {
        const saved = localStorage.getItem("neuronotes_llm_config");
        if (saved) {
          try {
            const config = JSON.parse(saved);
            Object.assign(llmConfig, config);

            document.getElementById("modelProvider").value =
              config.provider || "webllm";
            document.getElementById("modelSelect").value = config.model || "";
            document.getElementById("temperature").value =
              config.temperature || 0.7;
            document.getElementById("maxTokens").value =
              config.maxTokens || 512;
            document.getElementById("tempValue").textContent =
              config.temperature || 0.7;
            document.getElementById("tokensValue").textContent =
              config.maxTokens || 512;

            updateProviderUI();

            if (config.provider === "webllm" && config.model) {
              console.log("Auto-loading saved model:", config.model);
              // Auto-init engine with saved model
              appState.modelName = config.model;
              setTimeout(() => initEngine(), 500);
            }
          } catch (e) {
            console.warn("Failed to load saved LLM config:", e);
          }
        }
      }

      // LLM Configuration Event Listeners
      document
        .getElementById("modelProvider")
        .addEventListener("change", () => {
          updateProviderUI();
          saveProviderConfig();
        });

      document.getElementById("modelSelect").addEventListener("change", (e) => {
        const hasModel = e.target.value !== "";
        document.getElementById("loadModelBtn").disabled = !hasModel;
        if (hasModel) saveProviderConfig();
      });

      document
        .getElementById("apiKeyInput")
        .addEventListener("change", saveProviderConfig);
      document
        .getElementById("endpointInput")
        .addEventListener("change", saveProviderConfig);

      document.getElementById("temperature").addEventListener("input", (e) => {
        document.getElementById("tempValue").textContent = e.target.value;
        saveProviderConfig();
      });

      document.getElementById("maxTokens").addEventListener("input", (e) => {
        document.getElementById("tokensValue").textContent = e.target.value;
        saveProviderConfig();
      });

      document
        .getElementById("loadModelBtn")
        .addEventListener("click", async () => {
          const provider = document.getElementById("modelProvider").value;
          const model = document.getElementById("modelSelect").value;

          if (provider === "webllm" && model) {
            appState.modelName = model;
            llmConfig.model = model;
            llmConfig.isLoaded = false;
            await initEngine();
          } else if (provider !== "webllm") {
            // For API providers, just mark as ready
            llmConfig.isLoaded = true;
            llmConfig.model = model;
            document.getElementById("providerStatus").textContent = "Ready";
            document.getElementById("providerStatus").className =
              "provider-status online";
            document.getElementById("currentModelInfo").textContent = model;
            analyzeButton.disabled = false;
            beautifyButton.disabled = false;
            document.getElementById("testConfigBtn").disabled = false;
            saveProviderConfig();
          }
        });

      document
        .getElementById("refreshModelsBtn")
        .addEventListener("click", () => {
          const provider = document.getElementById("modelProvider").value;
          loadModelsForProvider(provider);
        });

      document
        .getElementById("testConfigBtn")
        .addEventListener("click", async () => {
          const testPrompt = document.getElementById("testPrompt").value;
          const responseDiv = document.getElementById("testResponse");
          const provider = document.getElementById("modelProvider").value;

          responseDiv.classList.add("show");
          responseDiv.textContent = "Testing...";

          try {
            if (provider === "webllm" && appState.engine) {
              const result = await appState.engine.chat.completions.create({
                messages: [{ role: "user", content: testPrompt }],
                temperature: llmConfig.temperature,
              });
              responseDiv.textContent =
                result.choices[0]?.message?.content || "No response";
            } else {
              responseDiv.textContent = `Test response from ${provider} (API call would be made here with model: ${llmConfig.model})`;
            }
          } catch (e) {
            responseDiv.textContent = "Error: " + e.message;
          }
        });

      // IndexedDB Auto-save Persistence
      let autoSaveTimeout = null;

      async function saveState() {
        // Mark as dirty for auto-save
        appState.isDirty = true;

        // Debounce auto-save (wait 2 seconds after last change)
        if (autoSaveTimeout) clearTimeout(autoSaveTimeout);
        autoSaveTimeout = setTimeout(async () => {
          await autoSaveCurrentCanvas();
        }, 2000);
      }

      async function autoSaveCurrentCanvas() {
        if (!appState.isDirty) return;

        const canvas = {
          id: appState.currentCanvasId || Date.now(),
          name: appState.currentCanvasName,
          notes: appState.notes,
          connections: appState.connections,
          noteHierarchy: appState.noteHierarchy,
          collapsedNotes: Array.from(appState.collapsedNotes),
          pan: appState.pan,
          zoom: appState.zoom,
          timestamp: Date.now(),
        };

        try {
          await saveCanvasToDB(canvas);
          appState.currentCanvasId = canvas.id;
          appState.isDirty = false;
          console.log(`Auto-saved: ${canvas.name}`);
        } catch (e) {
          console.error("Auto-save failed:", e);
        }
      }

      async function loadLastCanvas() {
        try {
          const canvases = await loadCanvasesFromDB();
          // Filter out config entries
          const actualCanvases = canvases.filter((c) => c.type !== "config");

          if (actualCanvases.length === 0) {
            // No saved canvases, start fresh
            return false;
          }

          // Load the most recently modified canvas
          const lastCanvas = actualCanvases.sort(
            (a, b) => (b.timestamp || 0) - (a.timestamp || 0)
          )[0];

          await loadCanvas(lastCanvas);
          return true;
        } catch (e) {
          console.error("Failed to load last canvas:", e);
          return false;
        }
      }

      // Helpers
      function genId() {
        return "note_" + Math.random().toString(36).slice(2, 9);
      }
      function clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
      }
      function getNote(id) {
        return appState.notes.find((n) => n.id === id);
      }
      // Transform helpers
      function toScreen(x, y) {
        return {
          x: x * appState.zoom + appState.pan.x,
          y: y * appState.zoom + appState.pan.y,
        };
      }
      function fromScreen(x, y) {
        return {
          x: (x - appState.pan.x) / appState.zoom,
          y: (y - appState.pan.y) / appState.zoom,
        };
      }

      // Note creation
      function createNote({
        id = genId(),
        x = 100,
        y = 100,
        title = "",
        text = "",
        color = "yellow",
      }) {
        const noteData = { id, x, y, title, text, color };
        appState.notes.push(noteData);
        renderNote(noteData);
        saveState();
        return noteData;
      }

      // Note rendering
      function renderNote(noteData) {
        const el = document.createElement("div");
        el.className = `note color-${noteData.color}`;
        const screen = toScreen(noteData.x, noteData.y);
        el.style.left = `${screen.x}px`;
        el.style.top = `${screen.y}px`;
        el.dataset.id = noteData.id;

        // Step 1.5: Add hierarchy styling
        if (noteData.parentId) {
          el.classList.add("child-note");
        }
        if (
          appState.noteHierarchy[noteData.id] &&
          appState.noteHierarchy[noteData.id].length > 0
        ) {
          el.classList.add("parent-note");
        }

        el.innerHTML = `
        <div class="note-header">
          <div class="hierarchy-controls">
            ${
              appState.noteHierarchy[noteData.id] &&
              appState.noteHierarchy[noteData.id].length > 0
                ? `<button class="expand-btn" title="Collapse/Expand"><span class="material-icons">${
                    appState.collapsedNotes.has(noteData.id)
                      ? "chevron_right"
                      : "expand_more"
                  }</span></button>`
                : ""
            }
            <button class="add-child-btn" title="Add child note"><span class="material-icons">add</span></button>
            <button class="deep-dive-btn" title="Explore deeper with AI"><span class="material-icons">psychology</span></button>
          </div>
          <input class="note-title" placeholder="Title‚Ä¶" value="${
            noteData.title ?? ""
          }">
          <div class="note-actions">
            <button class="note-color" title="Cycle color"><span class="material-icons">palette</span></button>
            <button class="note-delete" title="Delete"><span class="material-icons">close</span></button>
          </div>
        </div>
        <textarea class="note-content" placeholder="Type your idea here‚Ä¶">${
          noteData.text ?? ""
        }</textarea>
      `;

        const titleInput = el.querySelector(".note-title");
        const contentArea = el.querySelector(".note-content");
        const deleteBtn = el.querySelector(".note-delete");
        const colorBtn = el.querySelector(".note-color");
        const expandBtn = el.querySelector(".expand-btn");
        const addChildBtn = el.querySelector(".add-child-btn");
        const deepDiveBtn = el.querySelector(".deep-dive-btn");

        // Edit handlers
        titleInput.addEventListener("input", () => {
          const n = getNote(noteData.id);
          if (n) {
            n.title = titleInput.value;
            saveState();
          }
        });
        contentArea.addEventListener("input", () => {
          const n = getNote(noteData.id);
          if (n) {
            n.text = contentArea.value;
            saveState();
          }
        });

        // Delete (with children)
        deleteBtn.addEventListener("click", () => {
          deleteNoteAndChildren(noteData.id);
        });

        // Step 1.5: Expand/Collapse
        if (expandBtn) {
          expandBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            toggleNoteCollapse(noteData.id);
          });
        }

        // Step 1.5: Add Child
        addChildBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          addChildNote(noteData.id);
        });

        // Step 1.5: Deep Dive
        deepDiveBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          deepDiveNote(noteData.id);
        });

        // Color cycle
        colorBtn.addEventListener("click", () => {
          const palette = ["yellow", "pink", "teal", "purple"];
          const idx = palette.indexOf(noteData.color);
          noteData.color = palette[(idx + 1) % palette.length];
          el.className = `note color-${noteData.color}`;
          saveState();
        });

        // Dragging
        let startX = 0,
          startY = 0,
          dragging = false;
        el.addEventListener("mousedown", (e) => {
          if (e.target === contentArea || e.target === titleInput) return;
          dragging = true;
          el.classList.add("dragging");
          // Transform mouse to canvas coordinates
          const mouse = fromScreen(e.clientX, e.clientY);
          startX = mouse.x - noteData.x;
          startY = mouse.y - noteData.y;

          window.addEventListener("mousemove", onMouseMove);
          window.addEventListener("mouseup", onMouseUp);
        });

        function onMouseMove(e) {
          if (!dragging) return;
          const mouse = fromScreen(e.clientX, e.clientY);
          noteData.x = mouse.x - startX;
          noteData.y = mouse.y - startY;
          const screen = toScreen(noteData.x, noteData.y);
          el.style.left = `${screen.x}px`;
          el.style.top = `${screen.y}px`;
          renderConnections();
        }
        function onMouseUp() {
          dragging = false;
          el.classList.remove("dragging");
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("mouseup", onMouseUp);
          saveState();
        }

        noteCanvas.appendChild(el);
      }

      // Step 1.5: Delete note and all children
      function deleteNoteAndChildren(id) {
        const noteElement = document.querySelector(`.note[data-id="${id}"]`);
        if (noteElement) noteElement.remove();

        // Delete children recursively
        if (appState.noteHierarchy[id]) {
          appState.noteHierarchy[id].forEach((childId) =>
            deleteNoteAndChildren(childId)
          );
          delete appState.noteHierarchy[id];
        }

        // Remove from parent's children list
        Object.keys(appState.noteHierarchy).forEach((parentId) => {
          appState.noteHierarchy[parentId] = appState.noteHierarchy[
            parentId
          ].filter((childId) => childId !== id);
        });

        appState.notes = appState.notes.filter((n) => n.id !== id);
        appState.connections = appState.connections.filter(
          (c) => c.sourceId !== id && c.targetId !== id
        );
        appState.collapsedNotes.delete(id);
        renderConnections();
        saveState();
      }

      // Step 1.5: Toggle collapse/expand
      function toggleNoteCollapse(parentId) {
        if (appState.collapsedNotes.has(parentId)) {
          appState.collapsedNotes.delete(parentId);
          showChildren(parentId);
        } else {
          appState.collapsedNotes.add(parentId);
          hideChildren(parentId);
        }

        const noteElement = document.querySelector(
          `.note[data-id="${parentId}"]`
        );
        const expandBtn = noteElement?.querySelector(
          ".expand-btn .material-icons"
        );
        if (expandBtn) {
          expandBtn.textContent = appState.collapsedNotes.has(parentId)
            ? "chevron_right"
            : "expand_more";
        }

        renderConnections();
        saveState();
      }

      function hideChildren(parentId) {
        if (!appState.noteHierarchy[parentId]) return;
        appState.noteHierarchy[parentId].forEach((childId) => {
          const childElement = document.querySelector(
            `.note[data-id="${childId}"]`
          );
          if (childElement) {
            childElement.style.display = "none";
            hideChildren(childId);
          }
        });
      }

      function showChildren(parentId) {
        if (!appState.noteHierarchy[parentId]) return;
        appState.noteHierarchy[parentId].forEach((childId) => {
          const childElement = document.querySelector(
            `.note[data-id="${childId}"]`
          );
          if (childElement) {
            childElement.style.display = "block";
            if (!appState.collapsedNotes.has(childId)) {
              showChildren(childId);
            }
          }
        });
      }

      // Step 1.5: Add child note
      function addChildNote(parentId) {
        const parentNote = getNote(parentId);
        if (!parentNote) return;

        const childCount = (appState.noteHierarchy[parentId] || []).length;
        const offsetX = (childCount % 3) * 240;
        const offsetY = Math.floor(childCount / 3) * 200 + 180;

        const id = Date.now();
        const newNote = {
          id,
          x: parentNote.x + offsetX,
          y: parentNote.y + offsetY,
          title: "",
          text: "New child note...",
          color: parentNote.color,
          parentId: parentId,
        };

        appState.notes.push(newNote);

        if (!appState.noteHierarchy[parentId]) {
          appState.noteHierarchy[parentId] = [];
        }
        appState.noteHierarchy[parentId].push(id);

        appState.connections.push({
          sourceId: parentId,
          targetId: id,
          type: "parent-child",
          reason: "Child note",
          weight: 1,
          directed: true,
        });

        renderNote(newNote);
        renderConnections();
        saveState();
      }

      // Step 1.5: Deep dive with AI
      async function deepDiveNote(noteId) {
        const noteData = getNote(noteId);
        if (!noteData) return;

        const noteElement = document.querySelector(
          `.note[data-id="${noteId}"]`
        );
        const deepDiveBtn = noteElement?.querySelector(".deep-dive-btn");

        if (!llmConfig.isLoaded) {
          alert("Please load an LLM model first (open right drawer)");
          return;
        }

        if (!deepDiveBtn) return;

        deepDiveBtn.innerHTML =
          '<span class="material-icons">hourglass_empty</span>';
        deepDiveBtn.disabled = true;

        try {
          const noteText = noteData.title
            ? `${noteData.title}: ${noteData.text}`
            : noteData.text;
          const prompt = `Analyze this concept and break it down into 3-5 sub-concepts or related ideas:\n\n"${noteText}"\n\nProvide each sub-concept as a single line (brief phrase or sentence). Focus on different aspects, related topics, or deeper explorations.`;

          const response = await appState.engine.chat.completions.create({
            messages: [{ role: "user", content: prompt }],
            temperature: llmConfig.temperature,
            max_tokens: 300,
          });

          const subConcepts = response.choices[0].message.content
            .split("\n")
            .filter((line) => line.trim().length > 0)
            .map((line) => line.replace(/^\d+\.\s*|^-\s*|^\*\s*/, "").trim())
            .slice(0, 5);

          if (subConcepts.length === 0) {
            alert("No sub-concepts generated. Try again.");
            return;
          }

          const startChildCount = (appState.noteHierarchy[noteId] || []).length;

          subConcepts.forEach((concept, index) => {
            const childIndex = startChildCount + index;
            const offsetX = (childIndex % 3) * 240;
            const offsetY = Math.floor(childIndex / 3) * 200 + 180;

            const childId = Date.now() + index;
            const childNote = {
              id: childId,
              x: noteData.x + offsetX,
              y: noteData.y + offsetY,
              title: "",
              text: concept,
              color: noteData.color,
              parentId: noteId,
            };

            appState.notes.push(childNote);

            if (!appState.noteHierarchy[noteId]) {
              appState.noteHierarchy[noteId] = [];
            }
            appState.noteHierarchy[noteId].push(childId);

            appState.connections.push({
              sourceId: noteId,
              targetId: childId,
              type: "parent-child",
              reason: "AI-generated sub-concept",
              weight: 1,
              directed: true,
            });

            renderNote(childNote);
          });

          renderConnections();
          saveState();

          const parentEl = document.querySelector(`.note[data-id="${noteId}"]`);
          if (parentEl) {
            parentEl.remove();
            renderNote(noteData);
          }
        } catch (error) {
          console.error("Deep dive error:", error);
          alert("Failed to analyze note: " + error.message);
        } finally {
          if (deepDiveBtn) {
            deepDiveBtn.innerHTML =
              '<span class="material-icons">psychology</span>';
            deepDiveBtn.disabled = false;
          }
        }
      }

      // Helper to check if a note is being dragged
      function isNoteDragging() {
        return Array.from(noteCanvas.children).some((n) =>
          n.classList.contains("dragging")
        );
      }

      // Connection color by type
      function colorForType(type) {
        switch ((type || "").toLowerCase()) {
          case "parent-child":
            return "#9E9E9E"; // Step 1.5: Gray for hierarchy
          case "similarity":
            return "#5C6BC0";
          case "causal":
            return "#EF6C00";
          case "contradiction":
            return "#E53935";
          case "supports":
            return "#2E7D32";
          case "refines":
            return "#00897B";
          case "temporal":
            return "#8E24AA";
          default:
            return getComputedStyle(document.documentElement).getPropertyValue(
              "--line-color"
            );
        }
      }

      // Overlay rendering (Bezier + multi-edge)
      // Beautiful SVG connection rendering with smooth bezier curves
      function renderConnections() {
        const svg = document.getElementById("semantic-overlay");
        const container = document.getElementById("canvas-container");

        // Set SVG dimensions to match container
        svg.setAttribute("width", container.clientWidth);
        svg.setAttribute("height", container.clientHeight);

        // Clear existing content
        svg.innerHTML = "";

        // Create defs for arrow markers with beautiful styling
        const defs = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "defs"
        );
        const marker = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "marker"
        );
        marker.setAttribute("id", "arrowhead");
        marker.setAttribute("markerWidth", "12");
        marker.setAttribute("markerHeight", "12");
        marker.setAttribute("refX", "11");
        marker.setAttribute("refY", "6");
        marker.setAttribute("orient", "auto");

        const arrowPath = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        arrowPath.setAttribute("d", "M 0 0 L 12 6 L 0 12 z");
        arrowPath.setAttribute("fill", "#666");
        marker.appendChild(arrowPath);
        defs.appendChild(marker);
        svg.appendChild(defs);

        // Create groups for better organization
        const pathGroup = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "g"
        );
        pathGroup.setAttribute("class", "connections");
        svg.appendChild(pathGroup);

        const labelGroup = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "g"
        );
        labelGroup.setAttribute("class", "labels");
        svg.appendChild(labelGroup);

        function noteCenter(id) {
          const n = getNote(id);
          if (!n) return { x: 0, y: 0 };
          return toScreen(n.x + 110, n.y + 110); // center of note
        }

        // Group edges by (sourceId,targetId) for multi-edge support
        const edgeGroups = {};
        appState.connections.forEach((c, idx) => {
          const key = `${c.sourceId}__${c.targetId}`;
          if (!edgeGroups[key]) edgeGroups[key] = [];
          edgeGroups[key].push({ ...c, _index: idx });
        });

        Object.values(edgeGroups).forEach((group) => {
          const a = noteCenter(group[0].sourceId);
          const b = noteCenter(group[0].targetId);
          const baseOffset = 20;
          const offsets = group.map((_, i) => {
            const mid = (group.length - 1) / 2;
            return (i - mid) * baseOffset;
          });

          group.forEach((conn, i) => {
            const color = colorForType(conn.type);

            // Create beautiful smooth bezier curve with MAXIMUM curvature
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 10) return; // Skip if notes are too close

            // Perpendicular offset for multiple edges
            const normX = dx / (dist || 1);
            const normY = dy / (dist || 1);
            const perpX = -normY;
            const perpY = normX;
            const offset = offsets[i];

            // EXTREME CURVATURE FOR TESTING - make it SUPER obvious!
            const midX = (a.x + b.x) / 2;
            const midY = (a.y + b.y) / 2;

            // Create control point perpendicular to the line, pushed WAY out
            const controlOffset = dist * 0.5; // 50% of distance!
            const cp1x = midX + perpX * controlOffset;
            const cp1y = midY + perpY * controlOffset;

            // Quadratic bezier - simpler, more visible curve
            const pathData = `M ${a.x} ${a.y} Q ${cp1x} ${cp1y} ${b.x} ${b.y}`;

            console.log("üé® CURVE:", {
              from: [a.x, a.y],
              control: [cp1x, cp1y],
              to: [b.x, b.y],
              path: pathData,
            });

            // Create path element with proper styling
            const path = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            const pathClass =
              conn.type === "temporal" ? "connection temporal" : "connection";
            path.setAttribute("class", pathClass);
            path.setAttribute("d", pathData);
            path.setAttribute("stroke", color);
            path.setAttribute("stroke-width", "13");
            path.setAttribute("fill", "none");
            path.setAttribute("stroke-linecap", "round");
            path.setAttribute("stroke-linejoin", "round");
            path.style.opacity = "0.8";

            if (conn.directed) {
              path.setAttribute("marker-end", "url(#arrowhead)");
            }

            // Add hover effects
            path.addEventListener("mouseenter", (e) => {
              path.setAttribute("stroke-width", "15");
              path.setAttribute("opacity", "1");
              const hoverColor = getComputedStyle(
                document.documentElement
              ).getPropertyValue("--line-hover-color");
              path.setAttribute("stroke", hoverColor || "#2F4F4F");
              showTooltip(
                conn.reason || "No reason provided",
                e.pageX,
                e.pageY
              );
            });

            path.addEventListener("mouseleave", () => {
              path.setAttribute("stroke-width", "3");
              path.setAttribute("opacity", "0.7");
              path.setAttribute("stroke", color);
              hideTooltip();
            });

            pathGroup.appendChild(path);

            // Add label at midpoint of quadratic bezier
            const midT = 0.5;
            const labelX =
              Math.pow(1 - midT, 2) * a.x +
              2 * (1 - midT) * midT * cp1x +
              Math.pow(midT, 2) * b.x;
            const labelY =
              Math.pow(1 - midT, 2) * a.y +
              2 * (1 - midT) * midT * cp1y +
              Math.pow(midT, 2) * b.y;

            const labelText = `${conn.type ?? "relation"}${
              conn.weight ? ` (${conn.weight})` : ""
            }`;

            const text = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text"
            );
            text.setAttribute("class", "connection-label");
            text.setAttribute("x", labelX);
            text.setAttribute("y", labelY - 10);
            text.setAttribute("fill", color);
            text.setAttribute("font-size", "11px");
            text.setAttribute("font-weight", "600");
            text.setAttribute("text-anchor", "middle");
            text.textContent = labelText;

            // Background for label
            const bbox = text.getBBox();
            const rect = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "rect"
            );
            rect.setAttribute("class", "label-bg");
            rect.setAttribute("x", bbox.x - 6);
            rect.setAttribute("y", bbox.y - 2);
            rect.setAttribute("width", bbox.width + 12);
            rect.setAttribute("height", bbox.height + 4);
            rect.setAttribute("fill", "rgba(255, 255, 255, 0.9)");
            rect.setAttribute("rx", "4");
            rect.setAttribute("ry", "4");

            labelGroup.appendChild(rect);
            labelGroup.appendChild(text);

            // Label hover
            const labelHoverHandler = (e) => {
              showTooltip(formatReason(conn), e.pageX, e.pageY);
            };
            text.addEventListener("mouseenter", labelHoverHandler);
            rect.addEventListener("mouseenter", labelHoverHandler);
            text.addEventListener("mouseleave", hideTooltip);
            rect.addEventListener("mouseleave", hideTooltip);
          });
        });
      }

      function showTooltip(text, x, y) {
        tooltip.textContent = text || "";
        const containerRect = canvasContainer.getBoundingClientRect();
        tooltip.style.left = `${x - containerRect.left + 8}px`;
        tooltip.style.top = `${y - containerRect.top + 8}px`;
        tooltip.style.opacity = "1";
      }
      function hideTooltip() {
        tooltip.style.opacity = "0";
      }

      function formatReason(conn) {
        const parts = [];
        if (conn.reason) parts.push(conn.reason);
        if (conn.confidence !== undefined)
          parts.push(`Confidence: ${conn.confidence}`);
        if (conn.weight !== undefined) parts.push(`Weight: ${conn.weight}`);
        if (conn.directed) parts.push("Directed");
        return parts.join(" ‚Ä¢ ") || "No details";
      }

      // Engine initialization (WebLLM)
      async function initEngine() {
        llmStatus.textContent = "Downloading model‚Ä¶";
        document.getElementById("providerStatus").textContent = "Loading";
        document.getElementById("providerStatus").className =
          "provider-status offline";

        try {
          const workerScript = `
          import { WebWorkerMLCEngineHandler } from "https://esm.run/@mlc-ai/web-llm";
          const handler = new WebWorkerMLCEngineHandler();
          self.onmessage = msg => handler.onmessage(msg);
        `;
          const blob = new Blob([workerScript], {
            type: "application/javascript",
          });
          const workerUrl = URL.createObjectURL(blob);
          const worker = new Worker(workerUrl, { type: "module" });

          appState.engine = await CreateWebWorkerMLCEngine(
            worker,
            appState.modelName,
            {
              initProgressCallback: (p) => {
                llmStatus.textContent = p.text;
                document.getElementById("currentModelInfo").textContent =
                  p.text;
              },
            }
          );

          llmStatus.textContent = "AI Ready";
          llmConfig.isLoaded = true;
          document.getElementById("providerStatus").textContent = "Online";
          document.getElementById("providerStatus").className =
            "provider-status online";
          document.getElementById("currentModelInfo").textContent =
            appState.modelName;
          analyzeButton.disabled = false;
          beautifyButton.disabled = false;
          document.getElementById("testConfigBtn").disabled = false;
          saveProviderConfig();
        } catch (err) {
          console.error("Engine init error:", err);
          llmStatus.textContent = "AI init failed (using fallback)";
          document.getElementById("providerStatus").textContent = "Error";
          document.getElementById("providerStatus").className =
            "provider-status offline";
          analyzeButton.disabled = false;
          beautifyButton.disabled = true;
        }
      }

      // Analyze notes via WebLLM (graph-focused prompt)
      async function analyzeNotes(engine, notes) {
        const systemPrompt =
          "You are a rigorous graph-building assistant. Return strict JSON only.";
        const userPrompt = `
You are given user notes. Build a semantic graph that captures clusters and multiple relationships between the notes.

Requirements:
- Return STRICT JSON (no markdown, no preface).
- Schema:
{
  "clusters": [
    { "theme": "string", "notes": ["note_id", ...], "summary": "string optional" }
  ],
  "connections": [
    {
      "sourceId": "note_id",
      "targetId": "note_id",
      "type": "similarity|causal|contradiction|supports|refines|temporal|related",
      "reason": "short explanation",
      "weight": 0.0-1.0,
      "confidence": 0.0-1.0,
      "directed": true|false
    }
  ]
}
- Allow MULTIPLE connections between the same pair (e.g., similarity + causal).
- "weight": strength of relation; "confidence": confidence in reasoning.
- Prefer short, precise "reason".

Notes:
${JSON.stringify(notes, null, 2)}
      `.trim();

        if (engine?.chat?.completions?.create) {
          const res = await engine.chat.completions.create({
            messages: [
              { role: "system", content: systemPrompt },
              { role: "user", content: userPrompt },
            ],
            temperature: 0.2,
          });
          const text = res.choices?.[0]?.message?.content ?? "";
          return safeParseJSON(text);
        }

        if (engine?.generate) {
          const text = await engine.generate(
            `${systemPrompt}\n\n${userPrompt}`
          );
          return safeParseJSON(text);
        }

        return null;
      }

      function safeParseJSON(text) {
        try {
          const start = text.indexOf("{");
          const end = text.lastIndexOf("}");
          if (start !== -1 && end !== -1) {
            return JSON.parse(text.slice(start, end + 1));
          }
          return JSON.parse(text);
        } catch (e) {
          console.warn("JSON parse failed, raw:", text);
          return null;
        }
      }

      // Analyze button
      analyzeButton.addEventListener("click", async () => {
        const notesPayload = appState.notes.map((n) => ({
          id: n.id,
          title: n.title || "",
          text: n.text || "",
          x: n.x,
          y: n.y,
          color: n.color,
        }));

        llmStatus.textContent = "Analyzing‚Ä¶";

        let result = null;
        try {
          if (appState.engine) {
            result = await analyzeNotes(appState.engine, notesPayload);
          }
        } catch (e) {
          console.error("Analyze error:", e);
        }

        if (!result) {
          // Fallback heuristic: multi-edge similarity & temporal if horizontally aligned
          const cons = [];
          for (let i = 0; i < appState.notes.length; i++) {
            for (let j = i + 1; j < appState.notes.length; j++) {
              const a = appState.notes[i],
                b = appState.notes[j];
              const dx = a.x - b.x,
                dy = a.y - b.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < 340) {
                cons.push({
                  sourceId: a.id,
                  targetId: b.id,
                  type: "similarity",
                  reason: "Proximity-based heuristic (fallback)",
                  weight: 0.6,
                  confidence: 0.5,
                  directed: false,
                });
                if (Math.abs(dy) < 40) {
                  cons.push({
                    sourceId: a.id,
                    targetId: b.id,
                    type: "temporal",
                    reason: "Horizontal alignment suggests timeline",
                    weight: 0.4,
                    confidence: 0.4,
                    directed: true,
                  });
                }
              }
            }
          }
          result = { clusters: [], connections: cons };
        }

        appState.connections = Array.isArray(result.connections)
          ? result.connections
          : [];

        // Automatically beautify layout after analysis
        llmStatus.textContent = "Optimizing layout...";
        forceDirectedLayout(120);

        rerenderAll();
        saveState();
        llmStatus.textContent = "Analysis complete";

        // Step 2: Show template wizard after analysis
        if (appState.notes.length > 0) {
          setTimeout(() => openTemplateWizard(), 500);
        }
      });

      // Beautify button
      // Force-directed graph layout algorithm
      function forceDirectedLayout(iterations = 100) {
        if (appState.notes.length === 0) return;

        const notes = appState.notes;
        const connections = appState.connections;

        // Parameters
        const repulsionStrength = 8000;
        const attractionStrength = 0.01;
        const springLength = 300;
        const damping = 0.85;
        const centerStrength = 0.001;
        const minDistance = 250;

        // Initialize velocities
        notes.forEach((n) => {
          n.vx = n.vx || 0;
          n.vy = n.vy || 0;
        });

        // Calculate center of mass
        const centerX = 600;
        const centerY = 400;

        // Simulation loop
        for (let iter = 0; iter < iterations; iter++) {
          // Reset forces
          notes.forEach((n) => {
            n.fx = 0;
            n.fy = 0;
          });

          // Repulsion between all notes (prevent overlap)
          for (let i = 0; i < notes.length; i++) {
            for (let j = i + 1; j < notes.length; j++) {
              const a = notes[i];
              const b = notes[j];
              const dx = b.x - a.x;
              const dy = b.y - a.y;
              const dist = Math.sqrt(dx * dx + dy * dy) || 1;

              if (dist < minDistance) {
                const force = repulsionStrength / (dist * dist);
                const fx = (dx / dist) * force;
                const fy = (dy / dist) * force;
                a.fx -= fx;
                a.fy -= fy;
                b.fx += fx;
                b.fy += fy;
              }
            }
          }

          // Attraction along connections (spring force)
          connections.forEach((conn) => {
            const source = notes.find((n) => n.id === conn.sourceId);
            const target = notes.find((n) => n.id === conn.targetId);
            if (!source || !target) return;

            const dx = target.x - source.x;
            const dy = target.y - source.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const force = attractionStrength * (dist - springLength);
            const fx = (dx / dist) * force;
            const fy = (dy / dist) * force;

            source.fx += fx;
            source.fy += fy;
            target.fx -= fx;
            target.fy -= fy;
          });

          // Gentle pull toward center
          notes.forEach((n) => {
            const dx = centerX - n.x;
            const dy = centerY - n.y;
            n.fx += dx * centerStrength;
            n.fy += dy * centerStrength;
          });

          // Update positions
          notes.forEach((n) => {
            n.vx = (n.vx + n.fx) * damping;
            n.vy = (n.vy + n.fy) * damping;
            n.x += n.vx;
            n.y += n.vy;

            // Keep within bounds
            n.x = Math.max(50, Math.min(1800, n.x));
            n.y = Math.max(50, Math.min(1200, n.y));
          });
        }

        // Clean up velocity properties
        notes.forEach((n) => {
          delete n.vx;
          delete n.vy;
          delete n.fx;
          delete n.fy;
        });
      }

      beautifyButton.addEventListener("click", async () => {
        llmStatus.textContent = "Beautifying layout...";

        // Apply force-directed layout
        forceDirectedLayout(150);

        // Rerender everything
        rerenderAll();
        saveState();

        llmStatus.textContent = "Layout complete!";
        setTimeout(() => {
          llmStatus.textContent = "Ready";
        }, 2000);
      });

      // Init
      // Sidebar UI logic
      const canvasList = document.getElementById("canvas-list");
      const saveCanvasBtn = document.getElementById("save-canvas");

      async function refreshCanvasList() {
        const canvases = await loadCanvasesFromDB();
        // Filter out config entries
        const actualCanvases = canvases.filter((c) => c.type !== "config");

        canvasList.innerHTML = "";

        if (actualCanvases.length === 0) {
          canvasList.innerHTML =
            '<div style="padding: 20px; text-align: center; color: #999;">No saved canvases yet</div>';
          return;
        }

        // Sort by most recent
        actualCanvases.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

        actualCanvases.forEach((c) => {
          const item = document.createElement("div");
          item.className = "canvas-list-item";
          const isCurrent = c.id === appState.currentCanvasId;
          if (isCurrent) item.classList.add("current");

          const timestamp = c.timestamp
            ? new Date(c.timestamp).toLocaleString()
            : "";
          item.innerHTML = `
          <div style="display: flex; flex-direction: column; flex: 1;">
            <span class="canvas-name">${c.name || "Untitled"}</span>
            <span style="font-size: 0.75rem; color: #888;">${timestamp}</span>
          </div>
          ${
            isCurrent
              ? '<span style="color: #4CAF50; font-weight: bold; margin-right: 8px;">‚óè</span>'
              : ""
          }
        `;

          item.onclick = () => {
            loadCanvas(c);
            toggleDrawer("sidebar");
          };

          const delBtn = document.createElement("button");
          delBtn.innerHTML =
            '<span class="material-icons" style="font-size: 18px;">delete</span>';
          delBtn.className = "canvas-delete";
          delBtn.title = "Delete canvas";
          delBtn.onclick = (e) => {
            e.stopPropagation();
            if (confirm(`Delete "${c.name || "Untitled"}"?`)) {
              deleteCanvasFromDB(c.id).then(() => {
                if (c.id === appState.currentCanvasId) {
                  // Deleted current canvas, create new one
                  newCanvas();
                }
                refreshCanvasList();
              });
            }
          };
          item.appendChild(delBtn);
          canvasList.appendChild(item);
        });
      }

      // Helper to rerender everything
      function rerenderAll() {
        noteCanvas.innerHTML = "";
        appState.notes.forEach(renderNote);
        renderConnections();
      }

      // Update canvas transform without destroying DOM (for pan/zoom)
      function updateCanvasTransform() {
        noteCanvas.style.transform = `translate(${appState.pan.x}px, ${appState.pan.y}px) scale(${appState.zoom})`;
        // Also update SVG overlay
        const svgOverlay = document.getElementById("semantic-overlay");
        if (svgOverlay) {
          svgOverlay.style.transform = `translate(${appState.pan.x}px, ${appState.pan.y}px) scale(${appState.zoom})`;
        }
      }

      // Update canvas title display
      function updateCanvasTitle() {
        const titleElement = document.querySelector(".logo");
        if (titleElement) {
          const isDirty = appState.isDirty ? " *" : "";
          titleElement.innerHTML = `Neuro<span>Notes</span> <span style="font-size: 0.8rem; font-weight: normal; opacity: 0.7;">‚Äî ${appState.currentCanvasName}${isDirty}</span>`;
        }
      }

      async function loadCanvas(c) {
        appState.notes = c.notes || [];
        appState.connections = c.connections || [];
        appState.pan = c.pan || { x: 0, y: 0 };
        appState.zoom = c.zoom || 1;
        appState.noteHierarchy = c.noteHierarchy || {};
        appState.collapsedNotes = new Set(c.collapsedNotes || []);
        appState.currentCanvasId = c.id;
        appState.currentCanvasName = c.name || "Untitled Canvas";
        appState.isDirty = false;

        updateCanvasTitle();
        rerenderAll();
      }

      saveCanvasBtn.addEventListener("click", async () => {
        const name = prompt("Canvas name?", "Untitled");
        if (!name) return;
        const canvas = {
          id: currentCanvasId || Date.now(),
          name,
          notes: appState.notes,
          connections: appState.connections,
          pan: appState.pan,
          zoom: appState.zoom,
          noteHierarchy: appState.noteHierarchy,
          collapsedNotes: Array.from(appState.collapsedNotes),
        };
        await saveCanvasToDB(canvas);
        currentCanvasId = canvas.id;
        refreshCanvasList();
        alert("Canvas saved!");
      });

      // New Canvas button
      function newCanvas() {
        appState.notes = [];
        appState.connections = [];
        appState.noteHierarchy = {};
        appState.collapsedNotes = new Set();
        appState.pan = { x: 0, y: 0 };
        appState.zoom = 1;
        appState.currentCanvasId = null;
        appState.currentCanvasName = "Untitled Canvas";
        appState.isDirty = false;
        rerenderAll();
        updateCanvasTitle();
      }

      const newCanvasBtn = document.getElementById("new-canvas");
      newCanvasBtn.addEventListener("click", async () => {
        if (appState.isDirty) {
          if (confirm("Save current canvas before creating new one?")) {
            await autoSaveCurrentCanvas();
          }
        }
        newCanvas();
        toggleDrawer("sidebar");
      });

      // On load, refresh sidebar and create examples if first time
      async function initializeApp() {
        const canvases = await loadCanvasesFromDB();
        const actualCanvases = canvases.filter((c) => c.type !== "config");

        // First time user - create example canvases
        if (actualCanvases.length === 0) {
          await createExampleCanvases();
        }

        // Load last canvas
        const loaded = await loadLastCanvas();
        if (loaded) {
          rerenderAll();
        }

        refreshCanvasList();
        updateCanvasTitle();

        // Auto-save on page unload
        window.addEventListener("beforeunload", async () => {
          if (appState.isDirty) {
            await autoSaveCurrentCanvas();
          }
        });
      }

      initializeApp();

      // Step 2: Template System
      const templates = {
        prd: {
          name: "Product Requirements Document",
          icon: "üìã",
          sections: [
            "Overview",
            "User Stories",
            "Features",
            "Requirements",
            "Acceptance Criteria",
            "Timeline",
          ],
          prompt: (notes) =>
            `Create a Product Requirements Document based on these notes:\n\n${formatNotes(
              notes
            )}\n\nInclude: Executive Summary, User Stories, Detailed Features, Technical Requirements, Acceptance Criteria, and Timeline.`,
        },
        blog: {
          name: "Blog Post",
          icon: "‚úçÔ∏è",
          sections: [
            "Introduction",
            "Main Content",
            "Key Points",
            "Conclusion",
          ],
          prompt: (notes) =>
            `Write an engaging blog post based on these notes:\n\n${formatNotes(
              notes
            )}\n\nMake it conversational and well-structured with a hook, body paragraphs, and strong conclusion.`,
        },
        research: {
          name: "Research Paper",
          icon: "üî¨",
          sections: [
            "Abstract",
            "Introduction",
            "Methodology",
            "Findings",
            "Discussion",
            "Conclusion",
          ],
          prompt: (notes) =>
            `Write a research paper based on these notes:\n\n${formatNotes(
              notes
            )}\n\nInclude all standard academic sections with proper structure.`,
        },
        architecture: {
          name: "System Architecture",
          icon: "üèóÔ∏è",
          sections: [
            "Overview",
            "Components",
            "Data Flow",
            "Technology Stack",
            "Design Decisions",
          ],
          prompt: (notes) =>
            `Create a system architecture document based on these notes:\n\n${formatNotes(
              notes
            )}\n\nDescribe components, their interactions, data flow, and key technical decisions.`,
        },
        api: {
          name: "API Documentation",
          icon: "üîå",
          sections: [
            "Overview",
            "Authentication",
            "Endpoints",
            "Request/Response",
            "Examples",
          ],
          prompt: (notes) =>
            `Create API documentation based on these notes:\n\n${formatNotes(
              notes
            )}\n\nInclude endpoints, parameters, responses, and code examples.`,
        },
        proposal: {
          name: "Business Proposal",
          icon: "üìä",
          sections: [
            "Problem Statement",
            "Proposed Solution",
            "Benefits",
            "Timeline",
            "Budget",
          ],
          prompt: (notes) =>
            `Create a business proposal based on these notes:\n\n${formatNotes(
              notes
            )}\n\nMake it persuasive with clear problem, solution, benefits, and ROI.`,
        },
        roadmap: {
          name: "Product Roadmap",
          icon: "üó∫Ô∏è",
          sections: [
            "Vision",
            "Q1 Goals",
            "Q2 Goals",
            "Q3 Goals",
            "Q4 Goals",
            "Future",
          ],
          prompt: (notes) =>
            `Create a product roadmap based on these notes:\n\n${formatNotes(
              notes
            )}\n\nOrganize into quarters with clear milestones and deliverables.`,
        },
        tasks: {
          name: "Task List",
          icon: "üìù",
          sections: [
            "High Priority",
            "Medium Priority",
            "Low Priority",
            "Backlog",
          ],
          prompt: (notes) =>
            `Convert these notes into actionable tasks:\n\n${formatNotes(
              notes
            )}\n\nFor each task, include: clear description, priority, estimated time, and dependencies.`,
        },
      };

      function formatNotes(notes) {
        return notes
          .map((n) => {
            const title = n.title ? `**${n.title}**` : "";
            return `${title}\n${n.text}`;
          })
          .join("\n\n");
      }

      function openTemplateWizard() {
        document.getElementById("templateWizard").classList.add("show");
      }

      function closeTemplateWizard() {
        document.getElementById("templateWizard").classList.remove("show");
      }

      async function selectTemplate(templateId) {
        const template = templates[templateId];
        if (!template) return;

        closeTemplateWizard();

        if (!llmConfig.isLoaded) {
          alert("Please load an LLM model first (open right drawer)");
          return;
        }

        llmStatus.textContent = `Generating ${template.name}...`;

        try {
          const prompt = template.prompt(appState.notes);

          const response = await appState.engine.chat.completions.create({
            messages: [
              {
                role: "system",
                content:
                  "You are a professional document writer. Create well-structured, comprehensive documents.",
              },
              { role: "user", content: prompt },
            ],
            temperature: llmConfig.temperature,
            max_tokens: 2048,
          });

          const content = response.choices[0].message.content;

          // Show result in a new modal or download
          showGeneratedDocument(template.name, content);

          llmStatus.textContent = `${template.icon} Document generated!`;
        } catch (error) {
          console.error("Generation error:", error);
          alert("Failed to generate document: " + error.message);
          llmStatus.textContent = "Generation failed";
        }
      }

      function showGeneratedDocument(title, content) {
        // For now, download as markdown
        const blob = new Blob([`# ${title}\n\n${content}`], {
          type: "text/markdown",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${title.toLowerCase().replace(/\s+/g, "-")}.md`;
        a.click();
        URL.revokeObjectURL(url);

        // Also show preview in alert for now
        if (
          confirm(
            "Document generated! Download complete. Would you like to see a preview?"
          )
        ) {
          const previewWindow = window.open("", "_blank");
          previewWindow.document.write(`
          <html>
            <head>
              <title>${title}</title>
              <style>
                body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; max-width: 800px; margin: 0 auto; line-height: 1.6; }
                h1 { border-bottom: 2px solid #4CAF50; padding-bottom: 10px; }
                pre { background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; }
                code { background: #f5f5f5; padding: 2px 6px; border-radius: 3px; }
              </style>
            </head>
            <body>
              <h1>${title}</h1>
              <pre>${content.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>
            </body>
          </html>
        `);
        }
      }

      // Create example canvases for first-time users
      async function createExampleCanvases() {
        const examples = [
          {
            id: Date.now() + 1,
            name: "üöÄ SaaS Product Planning",
            notes: [
              {
                id: 1001,
                x: 100,
                y: 100,
                title: "Product Vision",
                text: "Build a productivity app for remote teams with AI assistance",
                color: "yellow",
                parentId: null,
              },
              {
                id: 1002,
                x: 100,
                y: 280,
                title: "Core Features",
                text: "Task management, real-time collaboration, AI summaries",
                color: "pink",
                parentId: 1001,
              },
              {
                id: 1003,
                x: 340,
                y: 280,
                title: "Target Users",
                text: "Remote teams (5-50 people), project managers, developers",
                color: "pink",
                parentId: 1001,
              },
              {
                id: 1004,
                x: 580,
                y: 280,
                title: "Revenue Model",
                text: "Freemium with pro features, $10/user/month",
                color: "pink",
                parentId: 1001,
              },
              {
                id: 1005,
                x: 100,
                y: 460,
                title: "Task Board",
                text: "Kanban view with drag-drop, priority labels",
                color: "teal",
                parentId: 1002,
              },
              {
                id: 1006,
                x: 340,
                y: 460,
                title: "Real-time Sync",
                text: "WebSocket updates, collaborative editing like Figma",
                color: "teal",
                parentId: 1002,
              },
              {
                id: 1007,
                x: 580,
                y: 460,
                title: "AI Assistant",
                text: "Summarize meetings, suggest tasks, auto-categorize",
                color: "teal",
                parentId: 1002,
              },
              {
                id: 1008,
                x: 820,
                y: 100,
                title: "Technical Stack",
                text: "React + Node.js + PostgreSQL + Redis",
                color: "purple",
                parentId: null,
              },
              {
                id: 1009,
                x: 820,
                y: 280,
                title: "Go-to-Market",
                text: "Product Hunt launch, Reddit communities, content marketing",
                color: "yellow",
                parentId: null,
              },
            ],
            connections: [
              {
                sourceId: 1001,
                targetId: 1002,
                type: "parent-child",
                reason: "Features",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 1001,
                targetId: 1003,
                type: "parent-child",
                reason: "Users",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 1001,
                targetId: 1004,
                type: "parent-child",
                reason: "Revenue",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 1002,
                targetId: 1005,
                type: "parent-child",
                reason: "Feature detail",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 1002,
                targetId: 1006,
                type: "parent-child",
                reason: "Feature detail",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 1002,
                targetId: 1007,
                type: "parent-child",
                reason: "Feature detail",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 1002,
                targetId: 1008,
                type: "supports",
                reason: "Technical implementation",
                weight: 0.8,
              },
              {
                sourceId: 1004,
                targetId: 1009,
                type: "causal",
                reason: "Revenue enables marketing",
                weight: 0.7,
              },
            ],
            noteHierarchy: {
              1001: [1002, 1003, 1004],
              1002: [1005, 1006, 1007],
            },
            collapsedNotes: [],
            pan: { x: 0, y: 0 },
            zoom: 1,
          },
          {
            id: Date.now() + 2,
            name: "üì± Mobile App Architecture",
            notes: [
              {
                id: 2001,
                x: 100,
                y: 100,
                title: "Mobile App",
                text: "Cross-platform fitness tracking app",
                color: "yellow",
                parentId: null,
              },
              {
                id: 2002,
                x: 100,
                y: 280,
                title: "Frontend",
                text: "React Native for iOS and Android",
                color: "pink",
                parentId: 2001,
              },
              {
                id: 2003,
                x: 400,
                y: 280,
                title: "Backend",
                text: "Node.js REST API with GraphQL",
                color: "pink",
                parentId: 2001,
              },
              {
                id: 2004,
                x: 700,
                y: 280,
                title: "Database",
                text: "MongoDB for user data, Redis for sessions",
                color: "pink",
                parentId: 2001,
              },
              {
                id: 2005,
                x: 100,
                y: 460,
                title: "UI Components",
                text: "Navigation, workout screens, profile",
                color: "teal",
                parentId: 2002,
              },
              {
                id: 2006,
                x: 280,
                y: 460,
                title: "State Management",
                text: "Redux for global state, local for UI",
                color: "teal",
                parentId: 2002,
              },
              {
                id: 2007,
                x: 400,
                y: 460,
                title: "Authentication",
                text: "JWT tokens, OAuth2, biometric login",
                color: "teal",
                parentId: 2003,
              },
              {
                id: 2008,
                x: 580,
                y: 460,
                title: "API Endpoints",
                text: "Users, workouts, progress, social features",
                color: "teal",
                parentId: 2003,
              },
              {
                id: 2009,
                x: 100,
                y: 640,
                title: "Push Notifications",
                text: "Firebase Cloud Messaging for reminders",
                color: "purple",
                parentId: 2005,
              },
              {
                id: 2010,
                x: 400,
                y: 640,
                title: "Analytics",
                text: "Mixpanel for user behavior tracking",
                color: "purple",
                parentId: 2007,
              },
            ],
            connections: [
              {
                sourceId: 2001,
                targetId: 2002,
                type: "parent-child",
                reason: "Client layer",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 2001,
                targetId: 2003,
                type: "parent-child",
                reason: "Server layer",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 2001,
                targetId: 2004,
                type: "parent-child",
                reason: "Data layer",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 2002,
                targetId: 2005,
                type: "parent-child",
                reason: "UI implementation",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 2002,
                targetId: 2006,
                type: "parent-child",
                reason: "State handling",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 2003,
                targetId: 2007,
                type: "parent-child",
                reason: "Security",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 2003,
                targetId: 2008,
                type: "parent-child",
                reason: "Endpoints",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 2005,
                targetId: 2009,
                type: "parent-child",
                reason: "Notifications",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 2007,
                targetId: 2010,
                type: "parent-child",
                reason: "Tracking",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 2002,
                targetId: 2003,
                type: "causal",
                reason: "Frontend calls backend",
                weight: 0.9,
              },
              {
                sourceId: 2003,
                targetId: 2004,
                type: "causal",
                reason: "API queries database",
                weight: 0.9,
              },
            ],
            noteHierarchy: {
              2001: [2002, 2003, 2004],
              2002: [2005, 2006],
              2003: [2007, 2008],
              2005: [2009],
              2007: [2010],
            },
            collapsedNotes: [],
            pan: { x: 0, y: 0 },
            zoom: 1,
          },
          {
            id: Date.now() + 3,
            name: "‚úçÔ∏è Blog Post Research",
            notes: [
              {
                id: 3001,
                x: 100,
                y: 100,
                title: "Blog Topic",
                text: "The Future of AI in Software Development",
                color: "yellow",
                parentId: null,
              },
              {
                id: 3002,
                x: 100,
                y: 280,
                title: "Current State",
                text: "AI tools: GitHub Copilot, ChatGPT, Cursor IDE",
                color: "pink",
                parentId: 3001,
              },
              {
                id: 3003,
                x: 400,
                y: 280,
                title: "Predictions",
                text: "AI pair programming will become standard by 2026",
                color: "pink",
                parentId: 3001,
              },
              {
                id: 3004,
                x: 700,
                y: 280,
                title: "Challenges",
                text: "Code quality, security risks, job displacement fears",
                color: "pink",
                parentId: 3001,
              },
              {
                id: 3005,
                x: 100,
                y: 460,
                title: "Case Studies",
                text: "Shopify: 40% faster coding with AI assistants",
                color: "teal",
                parentId: 3002,
              },
              {
                id: 3006,
                x: 300,
                y: 460,
                title: "Developer Survey",
                text: "67% of devs use AI tools daily (Stack Overflow 2024)",
                color: "teal",
                parentId: 3002,
              },
              {
                id: 3007,
                x: 400,
                y: 460,
                title: "Natural Language",
                text: "Write code by describing what you want in plain English",
                color: "teal",
                parentId: 3003,
              },
              {
                id: 3008,
                x: 620,
                y: 460,
                title: "Auto-Testing",
                text: "AI generates unit tests automatically",
                color: "teal",
                parentId: 3003,
              },
              {
                id: 3009,
                x: 700,
                y: 460,
                title: "Solutions",
                text: "Code review, human oversight, ethical guidelines",
                color: "teal",
                parentId: 3004,
              },
              {
                id: 3010,
                x: 1000,
                y: 100,
                title: "Conclusion",
                text: "AI is a tool, not a replacement - augments developers",
                color: "purple",
                parentId: null,
              },
            ],
            connections: [
              {
                sourceId: 3001,
                targetId: 3002,
                type: "parent-child",
                reason: "Context",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 3001,
                targetId: 3003,
                type: "parent-child",
                reason: "Future",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 3001,
                targetId: 3004,
                type: "parent-child",
                reason: "Problems",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 3002,
                targetId: 3005,
                type: "parent-child",
                reason: "Evidence",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 3002,
                targetId: 3006,
                type: "parent-child",
                reason: "Data",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 3003,
                targetId: 3007,
                type: "parent-child",
                reason: "Example",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 3003,
                targetId: 3008,
                type: "parent-child",
                reason: "Example",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 3004,
                targetId: 3009,
                type: "parent-child",
                reason: "Mitigation",
                weight: 1,
                directed: true,
              },
              {
                sourceId: 3002,
                targetId: 3003,
                type: "temporal",
                reason: "Current leads to future",
                weight: 0.8,
              },
              {
                sourceId: 3003,
                targetId: 3004,
                type: "contradiction",
                reason: "Benefits vs risks",
                weight: 0.6,
              },
              {
                sourceId: 3004,
                targetId: 3010,
                type: "refines",
                reason: "Challenges resolved in conclusion",
                weight: 0.7,
              },
            ],
            noteHierarchy: {
              3001: [3002, 3003, 3004],
              3002: [3005, 3006],
              3003: [3007, 3008],
              3004: [3009],
            },
            collapsedNotes: [],
            pan: { x: 0, y: 0 },
            zoom: 1,
          },
        ];

        for (const example of examples) {
          await saveCanvasToDB(example);
        }
      }

      // Make functions global for onclick handlers
      window.openTemplateWizard = openTemplateWizard;
      window.closeTemplateWizard = closeTemplateWizard;
      window.selectTemplate = selectTemplate;

      async function init() {
        // Load last canvas from IndexedDB (handled by initializeApp)
        // No need to call loadState() here anymore

        // Demo content if empty (more notes for complex relations)
        if (appState.notes.length === 0) {
          createNote({
            title: "Big Idea",
            text: "Semantic sticky notes with LLM",
            x: 120,
            y: 120,
            color: "yellow",
          });
          createNote({
            title: "Exploration",
            text: "Cluster by theme & relation",
            x: 400,
            y: 160,
            color: "pink",
          });
          createNote({
            title: "Privacy",
            text: "Local models reduce exposure",
            x: 220,
            y: 360,
            color: "teal",
          });
          createNote({
            title: "Workflow",
            text: "Auto tasks from clusters",
            x: 520,
            y: 420,
            color: "purple",
          });
          createNote({
            title: "Dataset",
            text: "Notes as knowledge base",
            x: 720,
            y: 200,
            color: "yellow",
          });
          createNote({
            title: "Contradictions",
            text: "Detect conflicting ideas",
            x: 320,
            y: 520,
            color: "pink",
          });
          createNote({
            title: "Timeline",
            text: "Track idea evolution",
            x: 860,
            y: 380,
            color: "teal",
          });
          createNote({
            title: "UX",
            text: "Mind-map, curved edges",
            x: 160,
            y: 520,
            color: "purple",
          });
          createNote({
            title: "Evaluation",
            text: "Confidence & weights",
            x: 640,
            y: 520,
            color: "yellow",
          });
        }

        renderConnections();

        // Initialize LLM configuration UI
        updateProviderUI();
        loadSavedLLMConfig();

        // Touch-friendly pan/zoom (pointer events)
        let pointerState = {
          isPanning: false,
          panStart: { x: 0, y: 0 },
          pointerStart: { x: 0, y: 0 },
          pinchStart: null,
          zoomStart: 1,
          panOrigin: { x: 0, y: 0 },
        };

        // Pan on pointerdown anywhere in canvas (except when dragging a note)
        function panPointerDown(e) {
          if (isNoteDragging()) return;
          if (e.pointerType === "touch" && e.isPrimary) {
            pointerState.isPanning = true;
            pointerState.panStart = { x: appState.pan.x, y: appState.pan.y };
            pointerState.pointerStart = { x: e.clientX, y: e.clientY };
            canvasContainer.setPointerCapture(e.pointerId);
          } else if (e.pointerType === "mouse" && e.button === 0) {
            pointerState.isPanning = true;
            pointerState.panStart = { x: appState.pan.x, y: appState.pan.y };
            pointerState.pointerStart = { x: e.clientX, y: e.clientY };
            canvasContainer.style.cursor = "grab";
          }
        }
        function panPointerMove(e) {
          if (pointerState.isPanning && !isNoteDragging()) {
            appState.pan.x =
              pointerState.panStart.x +
              (e.clientX - pointerState.pointerStart.x);
            appState.pan.y =
              pointerState.panStart.y +
              (e.clientY - pointerState.pointerStart.y);
            updateCanvasTransform();
          }
        }
        function panPointerUp(e) {
          if (pointerState.isPanning) {
            pointerState.isPanning = false;
            canvasContainer.style.cursor = "";
            canvasContainer.releasePointerCapture(e.pointerId);
          }
        }

        // Attach to both canvasContainer and noteCanvas for event propagation
        [canvasContainer, noteCanvas].forEach((el) => {
          el.addEventListener("pointerdown", panPointerDown);
          el.addEventListener("pointermove", panPointerMove);
          el.addEventListener("pointerup", panPointerUp);
        });

        // Pinch-to-zoom (touch)
        let pinchPoints = [];
        canvasContainer.addEventListener(
          "touchstart",
          (e) => {
            if (e.touches.length === 2) {
              pinchPoints = [
                { x: e.touches[0].clientX, y: e.touches[0].clientY },
                { x: e.touches[1].clientX, y: e.touches[1].clientY },
              ];
              pointerState.zoomStart = appState.zoom;
              pointerState.panOrigin = { x: appState.pan.x, y: appState.pan.y };
            }
          },
          { passive: false }
        );
        canvasContainer.addEventListener(
          "touchmove",
          (e) => {
            if (e.touches.length === 2) {
              e.preventDefault();
              const p0 = { x: e.touches[0].clientX, y: e.touches[0].clientY };
              const p1 = { x: e.touches[1].clientX, y: e.touches[1].clientY };
              const distStart = Math.hypot(
                pinchPoints[0].x - pinchPoints[1].x,
                pinchPoints[0].y - pinchPoints[1].y
              );
              const distNow = Math.hypot(p0.x - p1.x, p0.y - p1.y);
              const zoomFactor = distNow / distStart;
              appState.zoom = Math.max(
                0.2,
                Math.min(3, pointerState.zoomStart * zoomFactor)
              );
              // Center pan on pinch midpoint
              const midStart = {
                x: (pinchPoints[0].x + pinchPoints[1].x) / 2,
                y: (pinchPoints[0].y + pinchPoints[1].y) / 2,
              };
              const midNow = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
              appState.pan.x =
                pointerState.panOrigin.x + (midNow.x - midStart.x);
              appState.pan.y =
                pointerState.panOrigin.y + (midNow.y - midStart.y);
              updateCanvasTransform();
            }
          },
          { passive: false }
        );
        canvasContainer.addEventListener("touchend", (e) => {
          pinchPoints = [];
        });

        // Zoom with wheel (desktop)
        canvasContainer.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const zoomFactor = 1.08;
            const mouse = fromScreen(e.clientX, e.clientY);
            if (e.deltaY < 0) {
              appState.zoom = Math.min(3, appState.zoom * zoomFactor);
            } else {
              appState.zoom = Math.max(0.2, appState.zoom / zoomFactor);
            }
            // Keep mouse position stable
            appState.pan.x = e.clientX - mouse.x * appState.zoom;
            appState.pan.y = e.clientY - mouse.y * appState.zoom;
            updateCanvasTransform();
          },
          { passive: false }
        );

        // Make noteCanvas transparent to pointer events except for notes
        noteCanvas.style.pointerEvents = "auto";
        Array.from(noteCanvas.children).forEach((child) => {
          child.style.pointerEvents = "auto";
        });

        // Keyboard shortcuts: reset, zoom in/out
        window.addEventListener("keydown", (e) => {
          if (e.ctrlKey && e.key === "0") {
            appState.zoom = 1;
            appState.pan = { x: 0, y: 0 };
            rerenderAll();
          }
          if (e.ctrlKey && e.key === "+") {
            appState.zoom = Math.min(3, appState.zoom * 1.15);
            rerenderAll();
          }
          if (e.ctrlKey && e.key === "-") {
            appState.zoom = Math.max(0.2, appState.zoom / 1.15);
            rerenderAll();
          }
        });

        // Double-click to add note at cursor
        canvasContainer.addEventListener("dblclick", (e) => {
          if (e.target !== canvasContainer) return;
          const pos = fromScreen(e.clientX, e.clientY);
          createNote({
            x: pos.x,
            y: pos.y,
            color: ["yellow", "pink", "teal", "purple"][
              Math.floor(Math.random() * 4)
            ],
          });
          rerenderAll();
        });

        // Visual feedback for touch panning
        function setTouchPanFeedback(active) {
          canvasContainer.style.backgroundColor = active ? "#e3f2fd" : "";
        }
        canvasContainer.addEventListener("pointerdown", (e) => {
          if (e.pointerType === "touch") setTouchPanFeedback(true);
        });
        canvasContainer.addEventListener("pointerup", (e) => {
          if (e.pointerType === "touch") setTouchPanFeedback(false);
        });
      }

      // Add note button
      addNoteButton.addEventListener("click", () => {
        const containerRect = canvasContainer.getBoundingClientRect();
        const x = Math.round(
          containerRect.width / 2 - 110 + (Math.random() * 300 - 150)
        );
        const y = Math.round(
          containerRect.height / 2 - 110 + (Math.random() * 220 - 110)
        );
        createNote({
          x,
          y,
          color: ["yellow", "pink", "teal", "purple"][
            Math.floor(Math.random() * 4)
          ],
        });
      });

      // Keep overlay aligned on scroll
      canvasContainer.addEventListener("scroll", renderConnections);

      // Start - call async init
      (async () => {
        await init();
        await initializeApp();
      })();
    </script>
  </body>
</html>
